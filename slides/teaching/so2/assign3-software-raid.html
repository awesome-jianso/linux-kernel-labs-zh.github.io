<!DOCTYPE html>


<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Assignment 3 - Software RAID &mdash; The Linux Kernel  documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/styles.css" type="text/css" />
    <link rel="stylesheet" href="../_static/slides.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    
    
    <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/asciinema-player.js"></script>
    <script type="text/javascript" src="../_static/common.js"></script>
    
    <script type="text/javascript" src="../_static/slides.js"></script>
    <script type="text/javascript" src="../_static/sync.js"></script>
    <script type="text/javascript" src="../_static/controller.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>
    
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html" />
    <link rel="up" title="Operating Systems 2" href="index.html" />
    <link rel="next" title="Assignment 4 - SO2 Transport Protocol" href="assign4-transport-protocol.html" />
    <link rel="prev" title="Assignment 2 - Driver UART" href="assign2-driver-uart.html" /> 
  </head>
  <body>

<section
   id="slide_container"
   class='slides layout-regular'>


  
<article class="slide level-1" id="assignment-3-software-raid">

<h1>Assignment 3 - Software RAID</h1>

<ul class="simple">
<li>Deadline: <strong class="command">Monday, 15 May 2023, 23:00</strong></li>
<li>This assignment can be made in teams (max 2). Only one of them must submit the assignment, and the names of the student should be listed in a README file.</li>
</ul>
<p>Implementing a software RAID module that uses a logical block device that will read and write data from two physical devices,
ensuring the consistency and synchronization of data from the two physical devices. The type of RAID implemented will be similar to a <cite>RAID 1</cite>.</p>




</article>
<article class="slide level-2" id="assignment-s-objectives">

<h2>Assignment's Objectives</h2>

<ul class="simple">
<li>in-depth understanding of how the I/O subsystem works.</li>
<li>acquire advanced skills working with <cite>bio</cite> structures.</li>
<li>work  with the block / disk devices in the Linux kernel.</li>
<li>acquire skills to navigate and understand the code and API dedicated to the I/O subsystem in Linux.</li>
</ul>




</article>
<article class="slide level-2" id="statement">

<h2>Statement</h2>

<p>Write a kernel module that implements the RAID software functionality. <a class="reference external" href="https://en.wikipedia.org/wiki/RAID#Software-based_RAID">Software RAID</a> provides an abstraction between
the logical device and the physical devices. The implementation will use <a class="reference external" href="https://en.wikipedia.org/wiki/RAID#Standard_levels">RAID scheme 1</a>.</p>
<p>The virtual machine has two hard disks that will represent the physical devices: <cite>/dev/vdb</cite> and <cite>/dev/vdc</cite>. The operating system
will provide a logical device (block type) that will interface the access from the user space. Writing requests to the logical device
will result in two writes, one for each hard disk. Hard disks are not partitioned. It will be considered that each hard disk has a
single partition that covers the entire disk.</p>
<p>Each partition will store a sector along with an associated checksum (CRC32) to ensure error recovery. At each reading, the related
information from both partitions is read. If a sector of the first partition has corrupt data (CRC value is wrong) then the sector
on the second partition will be read; at the same time the sector of the first partition will be corrected. Similar in the case of
a reading of a corrupt sector on the second partition. If a sector has incorrect CRC values on both partitions, an appropriate error
code will be returned.</p>




</article>
<article class="slide level-3" id="important-to-know">

<h3>Important to know</h3>

<p>To ensure error recovery, a CRC code is associated with each sector. CRC codes are stored by LOGICAL_DISK_SIZE byte of the partition
(macro defined in the assignment <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/src/ssr.h">header</a>). The disk structure will have the following layout:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">+-----------+-----------+-----------+     +---+---+---+</span>
<span class="go">|  sector1  |  sector2  |  sector3  |.....|C1 |C2 |C3 |</span>
<span class="go">+-----------+-----------+-----------+     +---+---+---+</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">C1</span></code>, <code class="docutils literal"><span class="pre">C2</span></code>, <code class="docutils literal"><span class="pre">C3</span></code> are the values CRC sectors <code class="docutils literal"><span class="pre">sector1</span></code>, <code class="docutils literal"><span class="pre">sector2</span></code>, <code class="docutils literal"><span class="pre">sector3</span></code>. The CRC area is found immediately after the <code class="docutils literal"><span class="pre">LOGICAL_DISK_SIZE</span></code> bytes of the partition.</p>
<p>As a seed for CRC use 0(zero).</p>




</article>
<article class="slide level-2" id="implementation-details">

<h2>Implementation Details</h2>

<ul class="simple">
<li>the kernel module will be named <code class="docutils literal"><span class="pre">ssr.ko</span></code></li>
<li>the logical device will be accessed as a block device with the major <code class="docutils literal"><span class="pre">SSR_MAJOR</span></code> and minor <code class="docutils literal"><span class="pre">SSR_FIRST_MINOR</span></code> under the name <code class="docutils literal"><span class="pre">/dev/ssr</span></code> (via the macro <code class="docutils literal"><span class="pre">LOGICAL_DISK_NAME</span></code>)</li>
<li>the virtual device (<code class="docutils literal"><span class="pre">LOGICAL_DISK_NAME</span></code> - <code class="docutils literal"><span class="pre">/dev/ssr</span></code>) will have the capacity of <code class="docutils literal"><span class="pre">LOGICAL_DISK_SECTORS</span></code> (use <code class="docutils literal"><span class="pre">set_capacity</span></code> with the <code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> structure)</li>
<li>the two disks are represented by the devices <code class="docutils literal"><span class="pre">/dev/vdb</span></code>, respectively <code class="docutils literal"><span class="pre">/dev/vdc</span></code>, defined by means of macros <code class="docutils literal"><span class="pre">PHYSICAL_DISK1_NAME</span></code>, respectively <code class="docutils literal"><span class="pre">PHYSICAL_DISK2_NAME</span></code></li>
<li>to work with the <code class="docutils literal"><span class="pre">struct</span> <span class="pre">block</span> <span class="pre">_device</span></code> structure associated with a physical device, you can use the <code class="docutils literal"><span class="pre">blkdev_get_by_path</span></code> and <code class="docutils literal"><span class="pre">blkdev_put</span></code> functions</li>
<li>for the handling of requests from the user space, we recommend not to use a <code class="docutils literal"><span class="pre">request_queue</span></code>, but to do processing at <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> level
using the <code class="docutils literal"><span class="pre">submit_bio</span></code> field of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code></li>
<li>since data sectors are separated from CRC sectors you will have to build separate <code class="docutils literal"><span class="pre">bio</span></code> structures for data and CRC values</li>
<li>to allocate a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> for physical disks you can use <code class="xref c c-func docutils literal"><span class="pre">bio_alloc()</span></code>; to add data pages to bio use <code class="xref c c-func docutils literal"><span class="pre">alloc_page()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">bio_add_page()</span></code></li>
<li>to free up the space allocated for a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> you need to release the pages allocated to the bio (using the <code class="xref c c-func docutils literal"><span class="pre">__free_page()</span></code> macro ) and call
<code class="xref c c-func docutils literal"><span class="pre">bio_put()</span></code></li>
<li>when generating a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> structure, consider that its size must be multiple of the disk sector size (<code class="docutils literal"><span class="pre">KERNEL_SECTOR_SIZE</span></code>)</li>
<li>to send a request to a block device and wait for it to end, you can use the <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> function</li>
<li>use <code class="xref c c-func docutils literal"><span class="pre">bio_endio()</span></code> to signal the completion of processing a <code class="docutils literal"><span class="pre">bio</span></code> structure</li>
<li>for the CRC32 calculation you can use the <code class="xref c c-func docutils literal"><span class="pre">crc32()</span></code> macro provided by the kernel</li>
<li>useful macro definitions can be found in the assignment support <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/src/ssr.h">header</a></li>
<li>a single request processing function for block devices can be active at one time in a call stack (more details <a class="reference external" href="https://elixir.bootlin.com/linux/v5.10/source/block/blk-core.c#L1048">here</a>).
You will need to submit requests for physical devices in a kernel thread; we recommend using <code class="docutils literal"><span class="pre">workqueues</span></code>.</li>
<li>For a quick run, use a single bio to batch send the read/write request for CRC values for adjacent sectors. For example,
if you need to send requests for CRCs in sectors 0, 1, ..., 7, use a single bio, not 8 bios.</li>
<li>our recommendations are not mandatory (any solution that meets the requirements of the assignment is accepted)</li>
</ul>




</article>
<article class="slide level-2" id="testing">

<h2>Testing</h2>

<p>In order to simplify the assignment evaluation process, but also to reduce the mistakes of the submitted assignments,
the assignment evaluation will be done automatically with the help of a
<a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/checker/3-raid-checker/_checker">test script</a> called <cite>_checker</cite>.
The test script assumes that the kernel module is called <cite>ssr.ko</cite>.</p>
<p>If, as a result of the testing process, the sectors on both disks contain invalid data, resulting in
read errors that make the module impossible to use, you will need to redo the two disks in the
virtual machine using the commands:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/dev/vdb <span class="nv">bs</span><span class="o">=</span>1M
<span class="gp">$</span> dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/dev/vdc <span class="nv">bs</span><span class="o">=</span>1M
</pre></div>
</div>
<p>You can also get the same result using the following command to start the virtual machine:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> rm disk<span class="o">{</span><span class="m">1</span>,2<span class="o">}</span>.img<span class="p">;</span> make console <span class="c1"># or rm disk{1,2}.img; make boot</span>
</pre></div>
</div>




</article>
<article class="slide level-2" id="quickstart">

<h2>QuickStart</h2>

<p>It is mandatory to start the implementation of the assignment from the code skeleton found in the <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/tree/master/src">src</a> directory.
There is only one header in the skeleton called <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/src/ssr.h">ssr.h</a>.
You will provide the rest of the implementation. You can add as many <cite>*.c`</cite> sources and additional <cite>*.h`</cite> headers.
You should also provide a Kbuild file that will compile the kernel module called <cite>ssr.ko</cite>.
Follow the instructions in the <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/README.md">README.md file</a> of the <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid">assignment's repo</a>.</p>




</article>
<article class="slide level-3" id="tips">

<h3>Tips</h3>

<p>To increase your chances of getting the highest grade, read and follow the Linux kernel
coding style described in the <a class="reference external" href="https://elixir.bootlin.com/linux/v4.19.19/source/Documentation/process/coding-style.rst">Coding Style document</a>.</p>
<p>Also, use the following static analysis tools to verify the code:</p>
<ul class="simple">
<li>checkpatch.pl</li>
</ul>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> linux/scripts/checkpatch.pl --no-tree --terse -f /path/to/your/file.c
</pre></div>
</div>
<ul class="simple">
<li>sparse</li>
</ul>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo apt-get install sparse
<span class="gp">$</span> <span class="nb">cd</span> linux
<span class="gp">$</span> make <span class="nv">C</span><span class="o">=</span><span class="m">2</span> /path/to/your/file.c
</pre></div>
</div>
<ul class="simple">
<li>cppcheck</li>
</ul>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> sudo apt-get install cppcheck
<span class="gp">$</span> cppcheck /path/to/your/file.c
</pre></div>
</div>




</article>
<article class="slide level-3" id="penalties">

<h3>Penalties</h3>

<p>Information about assigments penalties can be found on the
<a class="reference external" href="https://ocw.cs.pub.ro/courses/so2/teme/general">General Directions page</a>.</p>
<p>In exceptional cases (the assigment passes the tests by not complying with the requirements)
and if the assigment does not pass all the tests, the grade will may decrease more than mentioned above.</p>




</article>
<article class="slide level-3" id="submitting-the-assigment">

<h3>Submitting the assigment</h3>

<p>The assignment will be graded automatically using the <a class="reference external" href="https://github.com/systems-cs-pub-ro/vmchecker-next/wiki/Student-Handbook">vmchecker-next</a> infrastructure.
The submission will be made on moodle on the <a class="reference external" href="https://curs.upb.ro/2022/course/view.php?id=5121">course's page</a> to the related assignment.
You will find the submission details in the <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/README.md">README.md file</a> of the <a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid">repo</a>.</p>




</article>
<article class="slide level-2" id="resources">

<h2>Resources</h2>

<ul class="simple">
<li>implementation of the <a class="reference external" href="https://elixir.bootlin.com/linux/v5.10/source/drivers/md">RAID</a> software in the Linux kernel</li>
</ul>
<p>We recommend that you use gitlab to store your homework. Follow the directions in
<a class="reference external" href="https://gitlab.cs.pub.ro/so2/3-raid/-/blob/master/README.md">README</a>.</p>




</article>
<article class="slide level-2" id="questions">

<h2>Questions</h2>

<p>For questions about the topic, you can consult the mailing <a class="reference external" href="http://cursuri.cs.pub.ro/pipermail/so2/">list archives</a>
or you can write a question on the dedicated Teams channel.</p>
<p>Before you ask a question, make sure that:</p>
<blockquote>
<div><ul class="simple">
<li>you have read the statement of the assigment well</li>
<li>the question is not already presented on the <a class="reference external" href="https://ocw.cs.pub.ro/courses/so2/teme/tema2/faq">FAQ page</a></li>
<li>the answer cannot be found in the <a class="reference external" href="http://cursuri.cs.pub.ro/pipermail/so2/">mailing list archives</a></li>
</ul>
</div></blockquote>




</article>

</section>

<section id="slide_notes">

</section>

  </body>
</html>