<!DOCTYPE html>


<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>进程 &mdash; Linux 系统内核  documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/styles.css" type="text/css" />
    <link rel="stylesheet" href="../_static/single.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    
    
    <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/asciinema-player.js"></script>
    <script type="text/javascript" src="../_static/common.js"></script>
    
    <script type="text/javascript" src="../_static/slides.js"></script>
    <script type="text/javascript" src="../_static/sync.js"></script>
    <script type="text/javascript" src="../_static/controller.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>
    
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="Linux 系统内核  documentation" href="../index.html" />
    <link rel="next" title="中断" href="interrupts.html" />
    <link rel="prev" title="系统调用" href="syscalls.html" /> 
  </head>
  <body>

<section
   id="slide_container"
   class='slides layout-regular'>


  
<article class="admonition- slide level-2">

<h2>进程和线程</h2>

<ul class="simple">
<li>进程和线程</li>
<li>上下文切换</li>
<li>阻塞和唤醒</li>
<li>进程上下文</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>什么是进程？</h2>

<table class="hlist"><tr><td><ul class="simple">
<li>地址空间</li>
<li>一个或多个线程</li>
<li>打开的文件</li>
<li>套接字（Socket）</li>
<li>信号量（semaphore）</li>
</ul>
</td><td><ul class="simple">
<li>共享内存区域</li>
<li>定时器</li>
<li>信号处理程序</li>
<li>许多其他资源和状态信息</li>
</ul>
</td></tr></table>
<p>所有这些信息都被组织在进程控制块（PCB）中。在 Linux 中，PCB 对应的结构体是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>。</p>




</article>
<article class="admonition- slide level-2">

<h2>进程资源概述</h2>

<div class="highlight-none"><div class="highlight"><pre><span></span>                +-------------------------------------------------------------------+
                | dr-x------    2 tavi tavi 0  2021 03 14 12:34 .                   |
                | dr-xr-xr-x    6 tavi tavi 0  2021 03 14 12:34 ..                  |
                | lrwx------    1 tavi tavi 64 2021 03 14 12:34 0 -&gt; /dev/pts/4     |
           +---&gt;| lrwx------    1 tavi tavi 64 2021 03 14 12:34 1 -&gt; /dev/pts/4     |
           |    | lrwx------    1 tavi tavi 64 2021 03 14 12:34 2 -&gt; /dev/pts/4     |
           |    | lr-x------    1 tavi tavi 64 2021 03 14 12:34 3 -&gt; /proc/18312/fd |
           |    +-------------------------------------------------------------------+
           |                 +----------------------------------------------------------------+
           |                 | 08048000-0804c000 r-xp 00000000 08:02 16875609 /bin/cat        |
$ ls -1 /proc/self/          | 0804c000-0804d000 rw-p 00003000 08:02 16875609 /bin/cat        |
cmdline    |                 | 0804d000-0806e000 rw-p 0804d000 00:00 0 [heap]                 |
cwd        |                 | ...                                                            |
environ    |    +-----------&gt;| b7f46000-b7f49000 rw-p b7f46000 00:00 0                        |
exe        |    |            | b7f59000-b7f5b000 rw-p b7f59000 00:00 0                        |
fd --------+    |            | b7f5b000-b7f77000 r-xp 00000000 08:02 11601524 /lib/ld-2.7.so  |
fdinfo          |            | b7f77000-b7f79000 rw-p 0001b000 08:02 11601524 /lib/ld-2.7.so  |
maps -----------+            | bfa05000-bfa1a000 rw-p bffeb000 00:00 0 [stack]                |
mem                          | ffffe000-fffff000 r-xp 00000000 00:00 0 [vdso]                 |
root                         +----------------------------------------------------------------+
stat                 +----------------------------+
statm                |  Name: cat                 |
status ------+       |  State: R (running)        |
task         |       |  Tgid: 18205               |
wchan        +------&gt;|  Pid: 18205                |
                     |  PPid: 18133               |
                     |  Uid: 1000 1000 1000 1000  |
                     |  Gid: 1000 1000 1000 1000  |
                     +----------------------------+
</pre></div>
</div>




</article>
<article class="admonition-struct-task-struct slide level-2">

<h2>struct task_struct</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span>$ pahole -C task_struct vmlinux

struct task_struct {
    struct thread_info thread_info;                  /*     0     8 */
    volatile long int          state;                /*     8     4 */
    void *                     stack;                /*    12     4 */

    ...

    /* --- cacheline 45 boundary (2880 bytes) --- */
    struct thread_struct thread __attribute__((__aligned__(64))); /*  2880  4288 */

    /* size: 7168, cachelines: 112, members: 155 */
    /* sum members: 7148, holes: 2, sum holes: 12 */
    /* sum bitfield members: 7 bits, bit holes: 2, sum bit holes: 57 bits */
    /* paddings: 1, sum paddings: 2 */
    /* forced alignments: 6, forced holes: 2, sum forced holes: 12 */
} __attribute__((__aligned__(64)));
</pre></div>
</div>




</article>
<article class="admonition-inspecting-task-struct slide level-2">

<h2>Inspecting task_struct</h2>

<p>&nbsp;</p>
<asciinema-player src="../_images/inspect_task_struct.cast"></asciinema-player>



</article>
<article class="admonition- slide level-2">

<h2>测验：查看打开的文件</h2>

<p>使用调试器来检查名为 syslogd 的进程。</p>
<ul class="simple">
<li>我们应该使用什么命令列出已打开的文件描述符？</li>
<li>有多少个文件描述符已打开？</li>
<li>我们应该使用什么命令来确定打开文件描述符 3 的文件名？</li>
<li>文件描述符 3 的文件名是什么？</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>线程</h2>

<ul class="simple">
<li>每个线程都拥有独立的堆栈，这个堆栈与线程的寄存器的值共同决定了线程的运行状态</li>
<li>线程在进程的上下文中运行，同一进程中的所有线程共享资源</li>
<li>内核调度的是线程而不是进程，用户级线程（例如纤程（fiber）、协程（coroutine）等）在内核级别不可见</li>
</ul>




</article>
<article class="admonition-windows slide level-2">

<h2>典型实现方式（Windows）</h2>

<p>&nbsp;</p>
<img alt="../_images/ditaa-4b5c1874d3924d9716f26d4893a3e4f313bf1c43.png" src="../_images/ditaa-4b5c1874d3924d9716f26d4893a3e4f313bf1c43.png" />




</article>
<article class="admonition-linux slide level-2">

<h2>Linux 实现</h2>

<p>&nbsp;</p>
<img alt="../_images/ditaa-fd771038e88b95def30ae9bd4df0b7bd6b7b3503.png" src="../_images/ditaa-fd771038e88b95def30ae9bd4df0b7bd6b7b3503.png" />




</article>
<article class="admonition- slide level-2">

<h2>克隆系统调用</h2>

<ul class="simple">
<li>CLONE_FILES——与父进程共享文件描述符表</li>
<li>CLONE_VM——与父进程共享地址空间</li>
<li>CLONE_FS——与父进程共享文件系统信息（根目录，当前目录）</li>
<li>CLONE_NEWNS——不与父进程共享挂载命名空间（mount namespace）</li>
<li>CLONE_NEWIPC——不与父进程共享 IPC 命名空间（System V IPC 对象，POSIX 消息队列）</li>
<li>CLONE_NEWNET——不与父进程共享网络命名空间（网络接口，路由表）</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>命名空间和“容器”</h2>

<ul class="simple">
<li>容器是轻量级虚拟机的一种形式</li>
<li>基于容器的技术：LXC、Docker</li>
<li>容器是建立在内核命名空间之上的</li>
<li>内核命名空间允许隔离资源，如果不隔离资源的话，这些资源会在全局可见</li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nsproxy</span></code> 具有多个命名空间，每个命名空间可以在进程组之间选择性地共享</li>
<li>在启动时初始命名空间会被创建（例如： c:<code class="xref c c-data docutils literal"><span class="pre">init_net</span></code>）。默认情况下，新进程之间共享这些命名空间（例如：可用网络接口的列表）</li>
<li>可以在运行时创建新的命名空间，并且新进程可以指向这些新的命名空间</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>访问当前进程</h2>

<p>访问当前进程是一个频繁的操作：</p>
<ul class="simple">
<li>打开文件需要访问 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的 file 字段</li>
<li>映射新文件需要访问 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的 mm 字段</li>
<li>超过 90% 的系统调用需要访问当前进程结构体，因此访问需要很快</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 宏可用于访问当前进程的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code></li>
</ul>




</article>
<article class="admonition-x86 slide level-2">

<h2>在 x86 上访问当前进程</h2>

<p>&nbsp;</p>
<img alt="../_images/ditaa-019489e686a2f60f1594e37458cfcb10320eae0f.png" src="../_images/ditaa-019489e686a2f60f1594e37458cfcb10320eae0f.png" />




</article>
<article class="admonition-current-x86 slide level-2">

<h2>current 宏的先前实现（x86）</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span>/* 如何用 C 语言获取当前堆栈指针 */
register unsigned long current_stack_pointer asm(&quot;esp&quot;) __attribute_used__;

/* 如何用 C 语言获取线程信息结构体 */
static inline struct thread_info *current_thread_info(void)
{
   return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE – 1));
}

#define current current_thread_info()-&gt;task
</pre></div>
</div>




</article>
<article class="admonition-quiz-current-x86 slide level-2">

<h2>Quiz: current 宏的先前实现（x86）</h2>

<p>结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">thread_info</span></code> 的大小是多少？</p>
<p>下列哪个是可能的有效大小：4095、4096、4097？</p>




</article>
<article class="admonition- slide level-2">

<h2>上下文切换过程概述</h2>

<img alt="../_images/ditaa-f6b228332baf165f498d8a1bb0bc0bdb91ae50c5.png" src="../_images/ditaa-f6b228332baf165f498d8a1bb0bc0bdb91ae50c5.png" />




</article>
<article class="admonition-context-switch slide level-2">

<h2>context_switch</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span>
<span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
         <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">prepare_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * paravirt 中，这与 switch_to 中的 exit 配对，</span>
<span class="cm">     * 将页表重载和后端切换合并为一个超级调用（hypercall）。</span>
<span class="cm">     */</span>
    <span class="n">arch_start_context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * kernel -&gt; kernel   lazy + transfer active</span>
<span class="cm">     *   user -&gt; kernel   lazy + mmgrab() active</span>
<span class="cm">     *</span>
<span class="cm">     * kernel -&gt;   user   switch + mmdrop() active</span>
<span class="cm">     *   user -&gt;   user   switch</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                                <span class="c1">// 到内核</span>
        <span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>                           <span class="c1">// 来自用户</span>
            <span class="n">mmgrab</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="c1">// 到用户</span>
        <span class="n">membarrier_switch_mm</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="cm">/*</span>
<span class="cm">         * sys_membarrier() 在设置 rq-&gt;curr / membarrier_switch_mm() 和返回用户空间之间需要一个 smp_mb()。</span>
<span class="cm">         *</span>
<span class="cm">         * 下面通过 switch_mm() 或者在 &#39;prev-&gt;active_mm == next-&gt;mm&#39; 的情况下通过 finish_task_switch() 的 mmdrop() 来提供这个功能。</span>
<span class="cm">         */</span>
        <span class="n">switch_mm_irqs_off</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                        <span class="c1">// 来自内核</span>
            <span class="cm">/* 在 finish_task_switch() 中进行 mmdrop()。 */</span>
            <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>

    <span class="n">prepare_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>

    <span class="cm">/* 在这里我们只切换寄存器状态和堆栈。 */</span>
    <span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="n">barrier</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>




</article>
<article class="admonition-switch-to slide level-2">

<h2>switch_to</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define switch_to(prev, next, last)               \</span>
<span class="cp">do {                                              \</span>
<span class="cp">    ((last) = __switch_to_asm((prev), (next)));   \</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * %eax: prev task</span>
<span class="cm"> * %edx: next task</span>
<span class="cm"> */</span>
<span class="p">.</span><span class="n">pushsection</span> <span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="s">&quot;ax&quot;</span>
<span class="n">SYM_CODE_START</span><span class="p">(</span><span class="n">__switch_to_asm</span><span class="p">)</span>
    <span class="cm">/*</span>
<span class="cm">     * 保存被调用者保存的寄存器</span>
<span class="cm">     * 其必须与 struct inactive_task_frame 中的顺序匹配</span>
<span class="cm">     */</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebp</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebx</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">edi</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">esi</span>
    <span class="cm">/*</span>
<span class="cm">     * 保存标志位以防止 AC 泄漏。如果 objtool 支持 32 位，则可以消除此项需求，以验证 STAC/CLAC 的正确性。</span>
<span class="cm">     */</span>
    <span class="n">pushfl</span>

<span class="hll">    <span class="cm">/* 切换堆栈 */</span>
</span><span class="hll">    <span class="n">movl</span>    <span class="o">%</span><span class="n">esp</span><span class="p">,</span> <span class="n">TASK_threadsp</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class="hll">    <span class="n">movl</span>    <span class="n">TASK_threadsp</span><span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">esp</span>
</span>
  <span class="cp">#ifdef CONFIG_STACKPROTECTOR</span>
    <span class="n">movl</span>    <span class="n">TASK_stack_canary</span><span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">ebx</span>
    <span class="n">movl</span>    <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="n">PER_CPU_VAR</span><span class="p">(</span><span class="n">stack_canary</span><span class="p">)</span><span class="o">+</span><span class="n">stack_canary_offset</span>
  <span class="cp">#endif</span>

  <span class="cp">#ifdef CONFIG_RETPOLINE</span>
    <span class="cm">/*</span>
<span class="cm">     * 当从较浅的调用堆栈切换到较深的堆栈时，RSB 可能会下溢或使用填充有用户空间地址的条目。</span>
<span class="cm">     * 在存在这些问题的 CPU 上，用捕获推测执行的条目覆盖 RSB，以防止攻击。</span>
<span class="cm">     */</span>
    <span class="n">FILL_RETURN_BUFFER</span> <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="n">RSB_CLEAR_LOOPS</span><span class="p">,</span> <span class="n">X86_FEATURE_RSB_CTXSW</span>
    <span class="cp">#endif</span>

    <span class="cm">/* 恢复任务的标志位以恢复 AC 状态。 */</span>
    <span class="n">popfl</span>
    <span class="cm">/* 恢复被调用者保存的寄存器 */</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">esi</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">edi</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">ebx</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">ebp</span>

<span class="hll">    <span class="n">jmp</span>     <span class="n">__switch_to</span>
</span>  <span class="n">SYM_CODE_END</span><span class="p">(</span><span class="n">__switch_to_asm</span><span class="p">)</span>
  <span class="p">.</span><span class="n">popsection</span>
</pre></div>
</div>




</article>
<article class="admonition-task-struct slide level-2">

<h2>检查 task_struct</h2>

<p>&nbsp;</p>
<asciinema-player src="../_images/context_switch.cast"></asciinema-player>



</article>
<article class="admonition- slide level-2">

<h2>测验：上下文切换</h2>

<p>假设我们正在执行上下文切换，请选择所有正确的陈述。</p>
<ul class="simple">
<li>ESP 寄存器被保存在 task 结构中</li>
<li>EIP 寄存器被保存在 task 结构中</li>
<li>通用寄存器被保存在 task 结构中</li>
<li>ESP 寄存器被保存在堆栈中</li>
<li>EIP 寄存器被保存在堆栈中</li>
<li>通用寄存器被保存在堆栈中</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>任务状态</h2>

<img alt="../_images/ditaa-54b40ea6fbe752f6485ac3d42063a1ec47a2ef69.png" src="../_images/ditaa-54b40ea6fbe752f6485ac3d42063a1ec47a2ef69.png" />




</article>
<article class="admonition- slide level-2">

<h2>阻塞当前线程</h2>

<ul class="simple">
<li>将当前线程状态设置为 TASK_UINTERRUPTIBLE 或 TASK_INTERRUPTIBLE</li>
<li>将任务添加到等待队列中</li>
<li>调用调度程序，从 READY 队列中选择一个新任务</li>
<li>进行上下文切换到新任务</li>
</ul>




</article>
<article class="admonition-wait-event slide level-2">

<h2>wait_event</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * wait_event——在条件为真之前一直保持睡眠状态</span>
<span class="cm"> * @wq_head: 等待队列</span>
<span class="cm"> * @condition: 用于等待的事件的 C 表达式</span>
<span class="cm"> *</span>
<span class="cm"> * 进程会进入睡眠状态（TASK_UNINTERRUPTIBLE），直到 @condition 为真为止。</span>
<span class="cm"> * 每次唤醒等待队列 @wq_head 时，都会检查 @condition。</span>
<span class="cm"> *</span>
<span class="cm"> * 在更改任何可能改变等待条件结果的变量后，必须调用 wake_up()。</span>
<span class="cm"> */</span>
<span class="cp">#define wait_event(wq_head, condition)            \</span>
<span class="cp">do {                                              \</span>
<span class="cp">  might_sleep();                                  \</span>
<span class="cp">  if (condition)                                  \</span>
<span class="cp">          break;                                  \</span>
<span class="cp">  __wait_event(wq_head, condition);               \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __wait_event(wq_head, condition)                                  \</span>
<span class="cp">    (void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,   \</span>
<span class="cp">                        schedule())</span>

<span class="cm">/*</span>
<span class="cm"> * 下面的宏 ___wait_event() 在 wait_event_*() 宏中使用时，有一个显式的 __ret</span>
<span class="cm"> * 变量的影子。</span>
<span class="cm"> *</span>
<span class="cm"> * 这是为了两者都可以使用 ___wait_cond_timeout() 结构来包装条件。</span>
<span class="cm"> *</span>
<span class="cm"> * wait_event_*() 中 __ret 变量的类型不一致也是有意而为的；我们在可以返回超时值的情况下使用 long，否则使用 int。</span>
<span class="cm"> */</span>
<span class="cp">#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)    \</span>
<span class="cp">({                                                                       \</span>
<span class="cp">    __label__ __out;                                                     \</span>
<span class="cp">    struct wait_queue_entry __wq_entry;                                  \</span>
<span class="cp">    long __ret = ret;       </span><span class="cm">/* 显式影子变量 */</span><span class="cp">                        \</span>
<span class="cp">                                                                         \</span>
<span class="cp">    init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);     \</span>
<span class="cp">    for (;;) {                                                           \</span>
<span class="cp">        long __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);\</span>
<span class="cp">                                                                         \</span>
<span class="cp">        if (condition)                                                   \</span>
<span class="cp">            break;                                                       \</span>
<span class="cp">                                                                         \</span>
<span class="cp">        if (___wait_is_interruptible(state) &amp;&amp; __int) {                  \</span>
<span class="cp">            __ret = __int;                                               \</span>
<span class="cp">            goto __out;                                                  \</span>
<span class="cp">        }                                                                \</span>
<span class="cp">                                                                         \</span>
<span class="cp">        cmd;                                                             \</span>
<span class="cp">    }                                                                    \</span>
<span class="cp">    finish_wait(&amp;wq_head, &amp;__wq_entry);                                  \</span>
<span class="cp">   __out:  __ret;                                                        \</span>
<span class="cp"> })</span>

 <span class="kt">void</span> <span class="nf">init_wait_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
 <span class="p">{</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">autoremove_wake_function</span><span class="p">;</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="kt">long</span> <span class="nf">prepare_to_wait_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
     <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

     <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
      <span class="cm">/*</span>
<span class="cm">      * 如果被唤醒选择的是独占等待者，那么它不能失败，</span>
<span class="cm">      * 它应该“消耗”我们等待的条件。</span>
<span class="cm">      *</span>
<span class="cm">      * 调用者将重新检查条件，并在我们已被唤醒时返回成功，我们不能错过事件，因为唤醒会锁定/解锁相同的 wq_head-&gt;lock。</span>
<span class="cm">      *</span>
<span class="cm">      * 但是我们需要确保在设置条件后+之后的唤醒看不到我们，如果我们失败的话，它应该唤醒另一个独占等待者。</span>
<span class="cm">      */</span>
         <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span>
                 <span class="n">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">wq_entry</span><span class="p">);</span>
             <span class="k">else</span>
                 <span class="n">__add_wait_queue</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">wq_entry</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
 <span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* finish_wait - 在队列中等待后进行清理</span>
<span class="cm">* @wq_head: 等待的等待队列头</span>
<span class="cm">* @wq_entry: 等待描述符</span>
<span class="cm">*</span>
<span class="cm">* 将当前线程设置回运行状态，并从给定的等待队列中移除等待描述符（如果仍在队列中）。</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">finish_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

   <span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
   <span class="cm">/*</span>
<span class="cm">   * 我们可以在锁之外检查链表是否为空，前提是：</span>
<span class="cm">   *  - 我们使用了“careful”检查，验证了 next 和 prev 指针，以确保没有我们还没有看到的其他 CPU 上可能仍在进行的半完成更新（可能仍会更改堆栈区域）。</span>
<span class="cm">   * 并且</span>
<span class="cm">   *  - 所有其他用户都会获取锁（也就是说，只有一个其他 CPU 可以查看或修改链表）。</span>
<span class="cm">   */</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
      <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
      <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>




</article>
<article class="admonition- slide level-2">

<h2>唤醒任务</h2>

<ul class="simple">
<li>从等待队列中选择一个任务</li>
<li>将任务状态设置为 TASK_READY</li>
<li>将任务插入调度器的 READY 队列中</li>
<li>在 SMP 系统上，这是一个复杂的操作：每个处理器都有自己的队列，队列需要平衡，需要向 CPU 发送信号</li>
</ul>




</article>
<article class="admonition-wake-up slide level-2">

<h2>wake_up</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define wake_up(x)                        __wake_up(x, TASK_NORMAL, 1, NULL)</span>

<span class="cm">/**</span>
<span class="cm"> * __wake_up - 唤醒在等待队列上阻塞的线程。</span>
<span class="cm"> * @wq_head: 等待队列</span>
<span class="cm"> * @mode: 哪些线程</span>
<span class="cm"> * @nr_exclusive: 要唤醒的线程数（一次唤醒一个或一次唤醒多个）</span>
<span class="cm"> * @key: 直接传递给唤醒函数</span>
<span class="cm"> *</span>
<span class="cm"> * 如果此函数唤醒了一个任务，则在访问任务状态之前执行完全的内存屏障。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__wake_up_common_lock</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wake_up_common_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
                                  <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">wait_queue_entry_t</span> <span class="n">bookmark</span><span class="p">;</span>

  <span class="n">bookmark</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">bookmark</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">bookmark</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>

  <span class="k">do</span> <span class="p">{</span>
          <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
          <span class="n">nr_exclusive</span> <span class="o">=</span> <span class="n">__wake_up_common</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span>
                                          <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bookmark</span><span class="p">);</span>
          <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bookmark</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 核心唤醒函数。非独占唤醒（nr_exclusive == 0）会唤醒所有任务。如果是独占唤醒（nr_exclusive == 一个小正数），则唤醒所有非独占任务和一个独占任务。</span>
<span class="cm"> *</span>
<span class="cm"> * 在某些情况下，我们可能会尝试唤醒已经开始运行但不处于 TASK_RUNNING 状态的任务。在这种（罕见）情况下，try_to_wake_up() 会返回零，我们通过继续扫描队列来处理它。</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wake_up_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                            <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">bookmark</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bookmark</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">list_next_entry</span><span class="p">(</span><span class="n">bookmark</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

          <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
          <span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">wait_queue_entry_t</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">nr_exclusive</span><span class="p">;</span>

  <span class="n">list_for_each_entry_safe_from</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">)</span>
                  <span class="k">continue</span><span class="p">;</span>

          <span class="n">ret</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span>
                  <span class="k">break</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">bookmark</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">++</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">WAITQUEUE_WALK_BREAK_CNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                  <span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
                  <span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">;</span>
                  <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">nr_exclusive</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">autoremove_wake_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">default_wake_function</span><span class="p">(</span><span class="n">wq_entry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
          <span class="n">list_del_init_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">default_wake_function</span><span class="p">(</span><span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_SCHED_DEBUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">WF_SYNC</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_wake_up——唤醒线程</span>
<span class="cm"> * @p: 要唤醒的线程</span>
<span class="cm"> * @state: 可以被唤醒的任务状态的掩码</span>
<span class="cm"> * @wake_flags: 唤醒修改标志 (WF_*)</span>
<span class="cm"> *</span>
<span class="cm"> * 概念上执行以下操作：</span>
<span class="cm"> *</span>
<span class="cm"> *   如果 (@state &amp; @p-&gt;state)，则 @p-&gt;state = TASK_RUNNING。</span>
<span class="cm"> *</span>
<span class="cm"> * 如果任务没有放进队列/可运行，还将其放回运行队列。</span>
<span class="cm"> *</span>
<span class="cm"> * 此函数对 schedule() 是原子性的，后者会让该任务出列。</span>
<span class="cm"> *</span>
<span class="cm"> * 在访问 @p-&gt;state 之前，它会触发完整的内存屏障，请参阅 set_current_state() 的注释。</span>
<span class="cm"> *</span>
<span class="cm"> * 使用 p-&gt;pi_lock 来序列化与并发唤醒的操作。</span>
<span class="cm"> *</span>
<span class="cm"> * 依赖于 p-&gt;pi_lock 来稳定下来：</span>
<span class="cm"> *  - p-&gt;sched_class</span>
<span class="cm"> *  - p-&gt;cpus_ptr</span>
<span class="cm"> *  - p-&gt;sched_task_group</span>
<span class="cm"> * 以便进行迁移，请参阅 select_task_rq()/set_task_cpu() 的使用。</span>
<span class="cm"> *</span>
<span class="cm"> * 尽力只获取一个 task_rq(p)-&gt;lock 以提高性能。</span>
<span class="cm"> * 在以下情况下获取 rq-&gt;lock：</span>
<span class="cm"> *  - ttwu_runnable()    -- 旧的 rq，不可避免的，参见该处的注释；</span>
<span class="cm"> *  - ttwu_queue()       -- 新的 rq，用于任务入队；</span>
<span class="cm"> *  - psi_ttwu_dequeue() -- 非常遗憾 :-(，计数将会伤害我们。</span>
<span class="cm"> *</span>
<span class="cm"> * 因此，我们与几乎所有操作都存在竞争。有关详细信息，请参阅许多内存屏障及其注释。</span>
<span class="cm"> *</span>
<span class="cm"> * 返回值：如果 @p-&gt;state 改变（实际进行了唤醒），则为 %true，否则为 %false。</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">try_to_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
      <span class="p">...</span>
</pre></div>
</div>




</article>
<article class="admonition- slide level-2">

<h2>非抢占式内核</h2>

<ul class="simple">
<li>每个时钟滴答，内核会检查当前进程是否已经用完了它的时间片</li>
<li>如果发生这种情况，会在中断上下文中设置一个标志位</li>
<li>在返回用户空间之前，内核会检查这个标志位，并在需要时调用 <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> 函数</li>
<li>在这种情况下，任务在内核模式下运行（例如系统调用）时不会被抢占，因此不存在同步问题</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>抢占式内核</h2>

<ul class="simple">
<li>即使在内核模式下运行，任务也可以被抢占</li>
<li>在临界区中需要使用新的同步原语：<code class="xref c c-macro docutils literal"><span class="pre">preempt_disable</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">preempt_enable</span></code></li>
<li>自旋锁也会禁用抢占</li>
<li>当一个线程需要被抢占时，会设置一个标志位，并在重新激活抢占时采取相应措施（例如调用调度器）来选择一个新的任务。</li>
</ul>




</article>
<article class="admonition- slide level-2">

<h2>进程上下文</h2>

<p>当内核执行系统调用时，它处于进程上下文中。</p>
<p>在进程上下文中，存在一个明确定义的上下文，我们可以使用 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 来访问当前进程的数据。</p>
<p>在进程上下文中，我们可以睡眠（等待条件）。</p>
<p>在进程上下文中，我们可以访问用户空间（除非我们在内核线程上下文中运行）。</p>




</article>
<article class="admonition- slide level-2">

<h2>内核线程</h2>

<p>有时候内核核心或设备驱动程序需要执行阻塞操作，因此需要在进程上下文中运行。</p>
<p>内核线程就是为此而使用的一种特殊类别的任务，它们不使用“用户空间”资源（例如没有地址空间或打开的文件）。</p>




</article>
<article class="admonition- slide level-2">

<h2>检查内核线程</h2>

<p>&nbsp;</p>
<asciinema-player src="../_images/kernel_threads.cast"></asciinema-player>



</article>
<article class="admonition-gdb slide level-2">

<h2>测验：内核 gdb 脚本</h2>

<p>下面对 lx-ps 脚本的修改是为了实现什么目的？</p>
<div class="highlight-diff"><div class="highlight"><pre><span></span><span class="gh">diff --git a/scripts/gdb/linux/tasks.py b/scripts/gdb/linux/tasks.py</span>
<span class="gh">index 17ec19e9b5bf..7e43c163832f 100644</span>
<span class="gd">--- a/scripts/gdb/linux/tasks.py</span>
<span class="gi">+++ b/scripts/gdb/linux/tasks.py</span>
<span class="gu">@@ -75,10 +75,13 @@ class LxPs(gdb.Command):</span>
     def invoke(self, arg, from_tty):
         gdb.write(&quot;{:&gt;10} {:&gt;12} {:&gt;7}\n&quot;.format(&quot;TASK&quot;, &quot;PID&quot;, &quot;COMM&quot;))
         for task in task_lists():
<span class="gd">-            gdb.write(&quot;{} {:^5} {}\n&quot;.format(</span>
<span class="gi">+            check = task[&quot;mm&quot;].format_string() == &quot;0x0&quot;</span>
<span class="gi">+            gdb.write(&quot;{} {:^5} {}{}{}\n&quot;.format(</span>
                 task.format_string().split()[0],
                 task[&quot;pid&quot;].format_string(),
<span class="gd">-                task[&quot;comm&quot;].string()))</span>
<span class="gi">+                &quot;[&quot; if check else &quot;&quot;,</span>
<span class="gi">+                task[&quot;comm&quot;].string(),</span>
<span class="gi">+                &quot;]&quot; if check else &quot;&quot;))</span>


 LxPs()
</pre></div>
</div>




</article>

</section>

<section id="slide_notes">

</section>

  </body>
</html>