<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta content="了解 Linux 中 I/O 子系统的行为，在块设备的结构和函数上进行实际操作，通过解决练习，掌握块设备的 API 使用基础技能" name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 07 - Block Device Drivers &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="SO2 Lab 08 - File system drivers (Part 1)" href="lab8-filesystems-part1.html" />
    <link rel="prev" title="SO2 Lab 06 - Memory Mapping" href="lab6-memory-mapping.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 07 - Block Device Drivers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">实验目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-o">注册块 I/O 设备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-3">注册磁盘</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-gendisk"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构体</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-block-device-operations"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> 结构体</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-4">请求队列——多队列块层</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-5">软件分段队列</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-6">硬件调度队列</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-7">标签集</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-8">创建和删除请求队列</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-9">用于处理请求队列的有用函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-10">块设备的请求</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-11">创建请求</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-12">处理请求</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#struct-bio"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-1">创建 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-2">提交 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-3">等待 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的完成</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-4">初始化 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-5">如何使用 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的内容</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-6">释放 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-7">在 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 级别设置请求队列</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">进一步阅读</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-14">练习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-15">0. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-16">1. 块设备</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-17">2. 磁盘注册</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ram">3. RAM 磁盘</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-18">4. 从磁盘读取数据</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-19">5. 将数据写入磁盘</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-bio-8">6. 在 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 级别处理请求队列中的请求</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 07 - Block Device Drivers</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab7-block-device-drivers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-07-block-device-drivers">
<h1>SO2 Lab 07 - Block Device Drivers<a class="headerlink" href="#so2-lab-07-block-device-drivers" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-1">
<h2>实验目标<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>了解 Linux 中 I/O 子系统的行为</li>
<li>在块设备的结构和函数上进行实际操作</li>
<li>通过解决练习，掌握块设备的 API 使用基础技能</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-2">
<h2>概述<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<p>块设备以数据通过固定大小的块来组织为特点，可以进行随机访问。这类设备的例子包括硬盘驱动器、CD-ROM 驱动器、RAM 磁盘等。块设备的速度通常比字符设备的速度快得多，并且它们的性能也很重要。这就是为什么 Linux 内核对这两种类型的设备处理方式不同（它使用一个专门的 API）。</p>
<p>因此，与字符设备相比，使用块设备更加复杂。字符设备只有当前位置，而块设备必须能够移动到设备上的任何位置，以提供对数据的随机访问。为了简化对块设备的操作，Linux 内核提供了一整个子系统，称为块 I/O（或块层）子系统。</p>
<p>从内核的角度来看，最小的逻辑寻址单元是块。虽然物理设备可以按扇区级别寻址，但内核使用块执行所有磁盘操作。由于最小的物理寻址单元是扇区，块的大小必须是扇区大小的倍数。此外，块的大小必须是 2 的幂，并且不能超过页面大小。块的大小可能因使用的文件系统而异，最常见的值为 512 B、1 KB 和 4 KB。</p>
</div>
<div class="section" id="i-o">
<h2>注册块 I/O 设备<a class="headerlink" href="#i-o" title="永久链接至标题">¶</a></h2>
<p>要注册块设备，请使用函数 <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code>。要注销一个块设备，可以使用函数 <code class="xref c c-func docutils literal"><span class="pre">unregister_blkdev()</span></code>。</p>
<p>从 Linux 内核的 4.9 版本开始，调用 <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> 不再是必须操作。该函数执行的唯一操作是动态分配一个主设备号（如果调用函数时主设备号参数为 0），并在 <code class="file docutils literal"><span class="pre">/proc/devices</span></code> 中创建一个条目。在未来的内核版本中，它可能被移除；然而，大多数驱动程序仍然调用它。</p>
<p>通常，在模块初始化函数中调用注册函数，在模块退出函数中调用注销函数。典型的场景如下所示：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BLOCK_MAJOR           240</span>
<span class="cp">#define MY_BLKDEV_NAME          &quot;mybdev&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

    <span class="n">status</span> <span class="o">=</span> <span class="n">register_blkdev</span><span class="p">(</span><span class="n">MY_BLOCK_MAJOR</span><span class="p">,</span> <span class="n">MY_BLKDEV_NAME</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
             <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;unable to register mybdev block device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
             <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="c1">//...</span>
     <span class="n">unregister_blkdev</span><span class="p">(</span><span class="n">MY_BLOCK_MAJOR</span><span class="p">,</span> <span class="n">MY_BLKDEV_NAME</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-3">
<h2>注册磁盘<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h2>
<p>尽管 <code class="xref c c-func docutils literal"><span class="pre">register_blkdev()</span></code> 函数获取了主设备号，但它并没有向系统提供设备（磁盘）。为了创建和使用块设备（磁盘），我们使用在 <code class="file docutils literal"><span class="pre">linux/genhd.h</span></code> 中定义的专门接口。</p>
<p>在 <code class="file docutils literal"><span class="pre">linux/genhd.h</span></code> 中定义的有用函数是用于注册/分配磁盘、将其添加到系统中以及注销/卸载磁盘的函数。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> 函数用于分配磁盘，<code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> 函数用于释放磁盘。使用 <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> 函数将磁盘添加到系统中。</p>
<p>通常在模块初始化函数中使用 <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> 函数，而在模块退出函数中使用 <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> 函数。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BLOCK_MINORS       1</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MY_BLOCK_MINORS</span><span class="p">);</span>
    <span class="c1">//...</span>
    <span class="n">add_disk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span>
        <span class="n">del_gendisk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>与字符设备一样，建议使用 <code class="xref c c-type docutils literal"><span class="pre">my_block_dev</span></code> 结构来存储描述块设备的重要元素。</p>
<p>请注意，在调用 <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> 函数之后（实际上，甚至包括调用期间），磁盘是活动的，可以随时调用其方法。因此，在驱动程序完全初始化并准备好响应对注册磁盘的请求之前，不应调用此函数。</p>
<p>可以注意到，用于处理块设备（磁盘）的基本结构是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构。</p>
<p>在调用 <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> 函数后，如果仍然有用户（对设备调用了打开操作，但关联的释放操作尚未被调用），则 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构可能继续存在（并且设备操作仍然可以调用）。一种解决方法是记录设备的用户数，并仅在设备没有剩余用户后调用 <code class="xref c c-func docutils literal"><span class="pre">del_gendisk()</span></code> 函数。</p>
</div>
<div class="section" id="struct-gendisk">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构体<a class="headerlink" href="#struct-gendisk" title="永久链接至标题">¶</a></h2>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构体存储关于磁盘的信息。如上所述，这样的结构体是通过 <code class="xref c c-func docutils literal"><span class="pre">alloc_disk()</span></code> 调用获得的，在将其作为参数传入 <code class="xref c c-func docutils literal"><span class="pre">add_disk()</span></code> 函数之前，必须填充其字段。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构体具有以下重要字段：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">major</span></code>, <code class="xref c c-member docutils literal"><span class="pre">first_minor</span></code> 以及 <code class="xref c c-member docutils literal"><span class="pre">minor</span></code>：描述磁盘使用的标识符；磁盘必须至少有一个次设备号；如果磁盘允许分区操作，则必须为每个可能的分区分配一个次设备号</li>
<li><code class="xref c c-member docutils literal"><span class="pre">disk_name</span></code>：表示磁盘名称，如在 <code class="file docutils literal"><span class="pre">/proc/partitions</span></code> 和 sysfs (<code class="file docutils literal"><span class="pre">/sys/block</span></code>) 中显示</li>
<li><code class="xref c c-member docutils literal"><span class="pre">fops</span></code>：表示与磁盘关联的操作</li>
<li><code class="xref c c-member docutils literal"><span class="pre">queue</span></code>：表示请求队列</li>
<li><code class="xref c c-member docutils literal"><span class="pre">capacity</span></code>：表示磁盘容量（以 512 字节扇区为单位）；可以使用 <code class="xref c c-func docutils literal"><span class="pre">set_capacity()</span></code> 函数进行初始化</li>
<li><code class="xref c c-member docutils literal"><span class="pre">private_data</span></code>：指向私有数据的指针</li>
</ul>
</div></blockquote>
<p>下面是填充 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构体的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/blkdev.h&gt;</span><span class="cp"></span>

<span class="cp">#define NR_SECTORS              1024</span>

<span class="cp">#define KERNEL_SECTOR_SIZE      512</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>                <span class="cm">/* 互斥锁 */</span>
    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>    <span class="cm">/* 设备请求队列 */</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>             <span class="cm">/* gendisk 结构体 */</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="cm">/* 初始化 gendisk 结构体 */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span> <span class="o">=</span> <span class="n">alloc_disk</span><span class="p">(</span><span class="n">MY_BLOCK_MINORS</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;alloc_disk failure</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span> <span class="n">MY_BLOCK_MAJOR</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">first_minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_block_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="n">snprintf</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&quot;myblock&quot;</span><span class="p">);</span>
    <span class="n">set_capacity</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">,</span> <span class="n">NR_SECTORS</span><span class="p">);</span>

    <span class="n">add_disk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">del_gendisk</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如前所述，内核将磁盘视为一连串的 512 字节扇区。实际上，设备可能具有不同大小的扇区。为了与这些设备一起工作，内核需要了解实际扇区的大小，并且在所有操作中需要进行必要的转换。</p>
<p>要向内核通知设备的扇区大小，必须在分配请求队列后设置请求队列的参数，使用 <code class="xref c c-func docutils literal"><span class="pre">blk_queue_logical_block_size()</span></code> 函数完成设置。内核生成的所有请求都将是该扇区大小的倍数，并相应地对齐。但是，设备和驱动程序之间的通信仍将以 512 字节大小的扇区进行，因此每次都需要进行转换（上述代码中调用 <code class="xref c c-func docutils literal"><span class="pre">set_capacity()</span></code> 函数时就是一个例子）。</p>
</div>
<div class="section" id="struct-block-device-operations">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> 结构体<a class="headerlink" href="#struct-block-device-operations" title="永久链接至标题">¶</a></h2>
<p>就像对于字符设备，需要完成 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> 中的操作一样，对于块设备，需要完成 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> 中的操作。操作的关联是通过 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code> 结构体中的 <code class="xref c c-member docutils literal"><span class="pre">fops</span></code> 字段完成的。</p>
<p>下面是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> 结构体的一些字段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">block_device_operations</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">locked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">fmode_t</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">direct_access</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="n">sector_t</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">**</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">media_changed</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">revalidate_disk</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">getgeo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">hd_geometry</span> <span class="o">*</span><span class="p">);</span>
    <span class="n">blk_qc_t</span> <span class="p">(</span><span class="o">*</span><span class="n">submit_bio</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">open()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">release()</span></code> 操作可以直接由用户空间的程序调用，这些程序可能执行以下任务：分区、文件系统创建、文件系统验证。在 <code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> 操作中，可以从内核空间直接调用 <code class="xref c c-func docutils literal"><span class="pre">open()</span></code> 函数，文件描述符由内核存储。块设备的驱动程序无法区分是从用户空间还是内核空间调用了 <code class="xref c c-func docutils literal"><span class="pre">open()</span></code> 函数。</p>
<p>下面是如何使用这两个函数的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span> <span class="n">gd</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">gendisk</span> <span class="o">*</span><span class="n">gd</span><span class="p">,</span> <span class="n">fmode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">my_block_ops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">my_block_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_block_release</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//....</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">fops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_block_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，没有读取或写入操作。这些操作是由与磁盘的请求队列相关联的 <code class="xref c c-func docutils literal"><span class="pre">request()</span></code> 函数执行的。</p>
</div>
<div class="section" id="section-4">
<h2>请求队列——多队列块层<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h2>
<p>块设备的驱动程序使用队列来存储将要处理的块输入/输出请求。请求队列由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code> 结构体表示。请求队列由一系列请求及其关联的控制信息组成，这些请求通过双向链表链接在一起。请求通过更高层次的内核代码（例如文件系统）添加到队列中。</p>
<p>块设备驱动程序将每个队列与处理函数关联起来，对于某队列中的每个请求（通过 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构体表示），都将调用该队列对应处理函数。</p>
<p>在早期的 Linux 内核版本中，每个设备驱动程序关联了一个或多个请求队列 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request_queue</span></code>)，任何客户端都可以向其添加请求，并能够对其进行重新排序。这种方法的问题在于每个队列都需要锁，在分布式系统中效率低下。</p>
<dl class="docutils">
<dt><a class="reference external" href="https://www.kernel.org/doc/html/latest/block/blk-mq.html">多队列块队列机制</a> 通过将设备驱动程序队列分为两部分来解决了这个问题：</dt>
<dd><ol class="first last arabic simple">
<li>软件分段队列（software staging queue）</li>
<li>硬件调度队列（hardware dispatch queue）</li>
</ol>
</dd>
</dl>
<div class="section" id="section-5">
<h3>软件分段队列<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h3>
<p>分段队列在将请求发送给块设备驱动程序之前，保存来自客户端的请求。为了避免每个队列都有一把锁，为每个 CPU 或节点分配一个分段队列。一个软件队列只与一个硬件队列关联。</p>
<p>在这个队列中，根据 I/O 调度程序，请求可以合并或重新排序，以最大化性能。这意味着只有来自相同 CPU 或节点的请求可以进行优化。</p>
<p>分段队列通常不被块设备驱动程序使用，而只在 I/O 子系统内部使用，以在将请求发送给设备驱动程序之前对其进行优化。</p>
</div>
<div class="section" id="section-6">
<h3>硬件调度队列<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h3>
<p>硬件队列 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_hw_ctx</span></code>) 用于将请求从分段队列发送到块设备驱动程序。一旦进入此队列，请求就无法合并或重新排序。</p>
<p>根据底层硬件的不同，块设备驱动程序可以创建多个硬件队列，以提高并行性和最大化性能。</p>
</div>
<div class="section" id="section-7">
<h3>标签集<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h3>
<p>块设备驱动程序可以在前一个请求完成之前接受另一个请求。因此，上层需要一种方式来知道请求何时完成。为此，在提交时为每个请求添加一个“标签”，并在请求完成后使用完成通知将其发送回来。</p>
<p>这些标签是标签集 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_tag_set</span></code>) 的一部分，每个设备的标签集都是唯一的。在分配和初始化请求队列之前，会分配和初始化标签集结构，并且还存储一些队列的属性。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">blk_mq_tag_set</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">blk_mq_ops</span>   <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">nr_hw_queues</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">queue_depth</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span>               <span class="n">cmd_size</span><span class="p">;</span>
  <span class="kt">int</span>                        <span class="n">numa_node</span><span class="p">;</span>
  <span class="kt">void</span>                      <span class="o">*</span><span class="n">driver_data</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">blk_mq_tags</span>       <span class="o">**</span><span class="n">tags</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span>           <span class="n">tag_list</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_tag_set</span></code> 结构中的一些字段如下：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ops</span></code>——队列操作，特别是请求处理函数</li>
<li><code class="docutils literal"><span class="pre">nr_hw_queues</span></code>——为设备分配的硬件队列数量</li>
<li><code class="docutils literal"><span class="pre">queue_depth</span></code>——硬件队列的大小</li>
<li><code class="docutils literal"><span class="pre">cmd_size</span></code>——在设备末尾额外分配的字节数，供块设备驱动程序使用（如果需要）</li>
<li><code class="docutils literal"><span class="pre">numa_node</span></code>——在 NUMA 系统中，存储设备连接的节点的索引</li>
<li><code class="docutils literal"><span class="pre">driver_data</span></code>——驱动程序私有的数据（如果需要）</li>
<li><code class="docutils literal"><span class="pre">tags</span></code>——指向包含 <code class="docutils literal"><span class="pre">nr_hw_queues</span></code> 个标签集的数组的指针</li>
<li><code class="docutils literal"><span class="pre">tag_list</span></code>——使用该标签集的请求队列的列表</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-8">
<h3>创建和删除请求队列<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p>我们使用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_init_queue()</span></code> 函数创建请求队列，使用 <code class="xref c c-func docutils literal"><span class="pre">blk_cleanup_queue()</span></code> 函数删除请求队列。第一个函数同时创建硬件队列和软件队列，并初始化它们的结构。</p>
<p>队列属性，包括硬件队列的数量、容量和请求处理函数，使用上述所述的 <code class="xref c c-type docutils literal"><span class="pre">blk_mq_tag_set</span></code> 结构进行配置。</p>
<p>以下是使用这些函数的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/genhd.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/blkdev.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">blk_mq_tag_set</span> <span class="n">tag_set</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">queue</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="n">dev</span><span class="p">;</span>

<span class="k">static</span> <span class="n">blk_status_t</span> <span class="nf">my_block_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_mq_hw_ctx</span> <span class="o">*</span><span class="n">hctx</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="k">struct</span> <span class="n">blk_mq_queue_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="c1">//...</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">blk_mq_ops</span> <span class="n">my_queue_ops</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">.</span><span class="n">queue_rq</span> <span class="o">=</span> <span class="n">my_block_request</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 初始化标签集 */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_queue_ops</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">nr_hw_queues</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">queue_depth</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">numa_node</span> <span class="o">=</span> <span class="n">NUMA_NO_NODE</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">cmd_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">BLK_MQ_F_SHOULD_MERGE</span><span class="p">;</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">blk_mq_alloc_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 分配队列 */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="n">blk_mq_init_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">goto</span> <span class="n">out_blk_init</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">blk_queue_logical_block_size</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">KERNEL_SECTOR_SIZE</span><span class="p">);</span>

     <span class="cm">/* 为队列结构分配私有数据。 */</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">queuedata</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
    <span class="c1">//...</span>

<span class="nl">out_blk_init</span><span class="p">:</span>
    <span class="n">blk_mq_free_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
<span class="nl">out_err</span><span class="p">:</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_block_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">create_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">delete_block_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//...</span>
    <span class="n">blk_cleanup_queue</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
    <span class="n">blk_mq_free_tag_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tag_set</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">delete_block_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在初始化标签集结构后，使用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_alloc_tag_set()</span></code> 函数分配标签列表。将处理请求的函数的指针（<code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>）填充到 <code class="docutils literal"><span class="pre">my_queue_ops</span></code> 结构中，然后将该结构的指针添加到标签集中。</p>
<p>基于添加到标签集中的信息，使用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_init_queue()</span></code> 函数创建队列。</p>
<p>作为请求队列初始化的一部分，你可以配置 <code class="xref c c-member docutils literal"><span class="pre">queuedata</span></code> 字段，该字段相当于其他结构中的 <code class="xref c c-member docutils literal"><span class="pre">private_data</span></code> 字段。</p>
</div>
<div class="section" id="section-9">
<h3>用于处理请求队列的有用函数<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">blk_mq_ops</span></code> 中的 <code class="docutils literal"><span class="pre">queue_rq</span></code> 函数用于处理对块设备的请求。该函数相当于在字符设备中遇到的读取和写入函数。该函数接收对设备的请求作为参数，并可以使用各种函数来处理这些请求。</p>
<p>下面描述了在处理程序中用于处理请求的函数：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">blk_mq_start_request()</span></code> ——在开始处理请求之前必须调用；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_mq_requeue_request()</span></code> ——重新发送队列中的请求；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> ——结束请求处理并通知上层。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="section-10">
<h2>块设备的请求<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h2>
<p>块设备的请求由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构描述。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构的字段包括：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">cmd_flags</span></code>：一系列标志，包括方向（读取或写入）；要确定方向，使用宏定义 <code class="xref c c-macro docutils literal"><span class="pre">rq_data_dir</span></code>，如果是读取请求它返回 0，如果是写入请求则返回 1；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">__sector</span></code>：传输请求的第一个扇区；如果设备扇区大小不同，应进行适当的转换。要访问此字段，请使用宏 <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_pos</span></code>；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">__data_len</span></code>：要传输的总字节数；要访问此字段，请使用宏 <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_bytes</span></code>；</li>
<li>通常，将传输当前 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 中的数据；可以使用宏 <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_cur_bytes</span></code> 来获取数据大小；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">bio</span></code>：动态列表，其中包含一组与请求相关联的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构，它们是与请求关联的缓冲区集合；如果存在多个缓冲区，则使用宏定义 <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> 访问该字段，如果只有一个关联的缓冲区，则使用 <code class="xref c c-macro docutils literal"><span class="pre">bio_data</span></code> 宏定义访问该字段；</li>
</ul>
</div></blockquote>
<p>我们将在 <span class="xref std std-ref">bio_structure</span> 部分中对 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构及其相关操作进行更详细的讨论。</p>
<div class="section" id="section-11">
<h3>创建请求<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h3>
<p>读取/写入请求是由位于内核 I/O 子系统上方的代码层创建的。通常，为块设备创建请求的子系统是文件管理子系统。I/O 子系统充当文件管理子系统和块设备驱动程序之间的接口。I/O 子系统的主要责任是将请求添加到特定块设备的队列中，并根据性能考虑对请求进行排序和合并。</p>
</div>
<div class="section" id="section-12">
<h3>处理请求<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h3>
<p>块设备驱动程序的核心部分是请求处理函数 (<code class="docutils literal"><span class="pre">queue_rq</span></code>)。在前面的示例中，扮演这个角色的函数是 <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code>。如在 <a class="reference internal" href="#section-8">创建和删除请求队列</a> 部分所述，该函数在创建标签集结构时与驱动程序相关联。</p>
<p>当内核认为驱动程序应该处理 I/O 请求时，将调用该函数。该函数必须开始处理队列中的请求，但不必完成它们，因为请求可能由驱动程序的其他部分完成。</p>
<p>请求函数在原子上下文中运行，并且必须遵循原子代码的规则（不能调用可能导致睡眠的函数等）。</p>
<p>调用处理请求的函数与任何用户空间进程的操作是异步的，并且不应对运行相应函数的进程作出任何假设。此外，不应假设请求提供的缓冲区是来自内核空间还是用户空间，任何访问用户空间的操作都是错误的。</p>
<p>下面是一个简单的请求处理函数示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">blk_status_t</span> <span class="nf">my_block_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_mq_hw_ctx</span> <span class="o">*</span><span class="n">hctx</span><span class="p">,</span>
                                     <span class="k">const</span> <span class="k">struct</span> <span class="n">blk_mq_queue_data</span> <span class="o">*</span><span class="n">bd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">request</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="n">bd</span><span class="o">-&gt;</span><span class="n">rq</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">queuedata</span><span class="p">;</span>

    <span class="n">blk_mq_start_request</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">blk_rq_is_passthrough</span><span class="p">(</span><span class="n">rq</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&quot;Skip non-fs request</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">blk_mq_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">BLK_STS_IOERR</span><span class="p">);</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* 做任务 */</span>
    <span class="p">...</span>

    <span class="n">blk_mq_end_request</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">BLK_STS_OK</span><span class="p">);</span>

<span class="nl">out</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">BLK_STS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>函数 <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> 执行以下操作：</p>
<blockquote>
<div><ul class="simple">
<li>从 <code class="docutils literal"><span class="pre">bd</span></code> 实参获取指向请求结构的指针，并使用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_start_request()</span></code> 函数开始处理请求。</li>
<li>块设备可能会接收不传输数据块的调用（例如，对磁盘的低级操作，涉及特殊的设备访问方式的指令）。大多数驱动程序不知道如何处理这些请求，并返回错误。</li>
<li>调用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> 函数返回错误，第二个参数为 <code class="docutils literal"><span class="pre">BLK_STS_IOERR</span></code>。</li>
<li>根据关联设备的需求处理请求。</li>
<li>请求结束。在这种情况下，调用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> 函数以完成请求。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="struct-bio">
<h2><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构<a class="headerlink" href="#struct-bio" title="永久链接至标题">¶</a></h2>
<p>每个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构是一个 I/O 块请求，但可能来自于更高级别的多个独立请求的组合。要传输的扇区可以分散在主存中，但它们总是对应于设备上的一组连续扇区。请求被表示为一系列段，每个段对应于内存中的一个缓冲区。内核可以合并引用相邻扇区的请求，但不会将读取请求与写入请求合并到一个单独的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构中。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构的底层实现为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构组成的链表，同时包含一些信息，这些信息使驱动程序在处理请求时保留其当前位置。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构是块 I/O 请求的某个部分的低级表示。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio</span> <span class="p">{</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">gendisk</span>          <span class="o">*</span><span class="n">bi_disk</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">bi_opf</span><span class="p">;</span>         <span class="cm">/* 低位是请求标志位，高位是 REQ_OP。使用访问器。 */</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">bio_vec</span>          <span class="o">*</span><span class="n">bi_io_vec</span><span class="p">;</span>     <span class="cm">/* 实际向量列表 */</span>
    <span class="c1">//...</span>
    <span class="k">struct</span> <span class="n">bvec_iter</span>        <span class="n">bi_iter</span><span class="p">;</span>
    <span class="o">/</span><span class="p">...</span>
    <span class="kt">void</span>                    <span class="o">*</span><span class="n">bi_private</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>反过来，<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构包含 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> 结构的 <code class="xref c c-member docutils literal"><span class="pre">bi_io_vec</span></code> 向量。它由要传输的物理内存中的单个页面，页面内的偏移和缓冲区的大小组成。要遍历 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构，需要遍历 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> 向量，并从每个物理页面传输数据。为了简化向量遍历，请使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bvec_iter</span></code> 结构。该结构保持有关在遍历过程中使用了多少个缓冲区和扇区的信息。请求类型被编码在 <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> 字段中；要确定请求类型，请使用 <code class="xref c c-func docutils literal"><span class="pre">bio_data_dir()</span></code> 函数。</p>
<div class="section" id="struct-bio-1">
<h3>创建 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构<a class="headerlink" href="#struct-bio-1" title="永久链接至标题">¶</a></h3>
<p>可以使用两个函数来创建 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">bio_alloc()</span></code>：为新结构分配空间；结构必须进行初始化；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">bio_clone()</span></code>：复制现有的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构；新获得的结构将使用克隆结构字段的值进行初始化；缓冲区与已克隆的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构共享，因此必须谨慎访问缓冲区，以避免两个克隆体访问同一内存区域；</li>
</ul>
</div></blockquote>
<p>这两个函数都返回新的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构。</p>
</div>
<div class="section" id="struct-bio-2">
<h3>提交 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构<a class="headerlink" href="#struct-bio-2" title="永久链接至标题">¶</a></h3>
<p>通常，<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构是由内核的更高层级（通常是文件系统）创建的。因此，创建的结构随后会传递给 I/O 子系统，该子系统将多个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构聚合成一个请求。</p>
<p>要将 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构提交给关联的 I/O 设备驱动程序，可以使用 <code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code> 函数。该函数接收已初始化的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构作为实参，该结构将被添加到 I/O 设备的请求队列中的一个请求中。从该队列中，可以使用专门的函数由 I/O 设备驱动程序处理该请求。</p>
</div>
<div class="section" id="struct-bio-3">
<span id="bio-completion"></span><h3>等待 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的完成<a class="headerlink" href="#struct-bio-3" title="永久链接至标题">¶</a></h3>
<p>将 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构提交给驱动程序会将其添加到请求队列中的一个请求中，然后进一步进行处理。因此，当 <code class="xref c c-func docutils literal"><span class="pre">submit_bio()</span></code> 函数返回时，并不能保证结构的处理已经完成。如果希望等待请求的处理完成，可以使用 <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> 函数。</p>
<p>要在对 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的处理结束时得到通知（当未使用 <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> 函数时），应使用结构的 <code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> 字段。该字段指定在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构处理结束时将调用的函数。可以使用结构的 <code class="xref c c-member docutils literal"><span class="pre">bi_private</span></code> 字段将信息传递给该函数。</p>
</div>
<div class="section" id="struct-bio-4">
<h3>初始化 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构<a class="headerlink" href="#struct-bio-4" title="永久链接至标题">¶</a></h3>
<p>一旦分配了 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构，在传输之前，必须对其进行初始化。</p>
<p>初始化结构涉及填充其重要字段。如上所述，<code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> 字段用于指定在结构处理完成时调用的函数。<code class="xref c c-member docutils literal"><span class="pre">bi_private</span></code> 字段用于存储可以在 <code class="xref c c-member docutils literal"><span class="pre">bi_end_io</span></code> 指向的函数中访问的有用数据。</p>
<p><code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> 字段指定操作的类型。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOIO</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">//...</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_disk</span> <span class="o">=</span> <span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="p">;</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_iter</span><span class="p">.</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_opf</span> <span class="o">=</span> <span class="n">REQ_OP_READ</span><span class="p">;</span>
<span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>在上面的代码片段中，我们指定了块设备以及发送给块设备的以下内容：<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构、起始扇区、操作 (<code class="xref c c-data docutils literal"><span class="pre">REQ_OP_READ</span></code> 或 <code class="xref c c-data docutils literal"><span class="pre">REQ_OP_WRITE</span></code>) 和内容。<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的内容是由一个物理页面、页面中的偏移量和缓冲区大小描述的缓冲区。可以使用 <code class="xref c c-func docutils literal"><span class="pre">alloc_page()</span></code> 调用来分配页面。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="xref c c-func docutils literal"><span class="pre">bio_add_page()</span></code> 调用中的 <code class="xref c c-data docutils literal"><span class="pre">size</span></code> 字段必须是设备扇区大小的倍数。</p>
</div>
</div>
<div class="section" id="struct-bio-5">
<span id="bio-content"></span><h3>如何使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的内容<a class="headerlink" href="#struct-bio-5" title="永久链接至标题">¶</a></h3>
<p>要使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的内容，必须将结构的支持页面映射到内核地址空间，从那里可以访问它们。要进行映射/取消映射，可以使用 <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> 宏。</p>
<p>以下是一个典型的使用示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_block_transfer</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">start</span><span class="p">,</span>
                              <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_xfer_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_block_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">bio_vec</span> <span class="n">bvec</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">bvec_iter</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

    <span class="cm">/* 独立完成每个段 */</span>
    <span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">bi_sector</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">;</span>
        <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">;</span>

        <span class="cm">/* 处理映射后的缓冲 */</span>
        <span class="n">my_block_transfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

        <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如上面的示例所示，遍历 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 需要遍历其所有的段（segment）。每个段 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code>) 由物理地址页面、页面中的偏移量和大小定义。</p>
<p>为了简化对 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的处理，可以使用 <code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code> 宏定义。它将遍历所有的段，并更新存储在迭代器（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bvec_iter</span></code>）中的全局信息，例如当前扇区以及其他内部信息（段向量索引，剩余待处理的字节数等）。</p>
<p>你可以在映射的缓冲区中存储信息或提取信息。</p>
<p>如果使用请求队列并且需要在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 级别处理请求，则应使用 <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> 宏而不是 <code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code> 宏。该宏遍历 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构中的每个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的每个段，并更新 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">req_iterator</span></code> 结构。<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">req_iterator</span></code> 包含当前的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构和遍历其段的迭代器。</p>
<p>以下是一个典型的使用示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bio_vec</span> <span class="n">bvec</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">req_iterator</span> <span class="n">iter</span><span class="p">;</span>

<span class="n">rq_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">iter</span><span class="p">.</span><span class="n">bi_sector</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bvec</span><span class="p">.</span><span class="n">bv_page</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_offset</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">.</span><span class="n">bv_len</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">dir</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">bio</span><span class="p">);</span>

    <span class="n">my_block_transfer</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">sector</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

    <span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="struct-bio-6">
<h3>释放 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构<a class="headerlink" href="#struct-bio-6" title="永久链接至标题">¶</a></h3>
<p>一旦内核子系统使用了 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构，就需要释放对它的引用。这可以通过调用 <code class="xref c c-func docutils literal"><span class="pre">bio_put()</span></code> 函数来实现。</p>
</div>
<div class="section" id="struct-bio-7">
<h3>在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 级别设置请求队列<a class="headerlink" href="#struct-bio-7" title="永久链接至标题">¶</a></h3>
<p>我们之前已经介绍了如何指定一个函数来处理发送给驱动程序的请求。该函数接收请求作为实参，并在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 级别进行处理。</p>
<p>如果要获得更高的灵活性，我们需要指定在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构级别进行处理的函数，而不再使用请求队列，那么我们将需要在与驱动程序关联的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code> 结构中填充 <code class="docutils literal"><span class="pre">submit_bio</span></code> 字段。</p>
<p>下面是一个典型的初始化在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构级别执行处理的函数的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// 执行处理的函数的声明</span>
<span class="c1">// :c:type:`struct bio` 结构级别</span>
<span class="k">static</span> <span class="n">blk_qc_t</span> <span class="nf">my_submit_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">block_device_operations</span> <span class="n">my_block_ops</span> <span class="o">=</span> <span class="p">{</span>
   <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
   <span class="p">.</span><span class="n">submit_bio</span> <span class="o">=</span> <span class="n">my_submit_bio</span>
   <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-13">
<h2>进一步阅读<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://static.lwn.net/images/pdf/LDD3/ch16.pdf">Linux 设备驱动程序第 3 版，第 16 章 块设备驱动程序</a></li>
<li>Linux 内核开发第 2 版——第 13 章 块 I/O 层</li>
<li><a class="reference external" href="https://lwn.net/Articles/58719/">一个简单的块设备驱动程序</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/25711/">gendisk 接口</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/26404/">bio 结构</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/27055/">请求队列</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/Documentation/block/request.txt">Documentation/block/request.txt——请求结构文档</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/Documentation/block/biodoc.txt">Documentation/block/biodoc.txt——通用块层注释</a></li>
<li><a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/drivers/block/brd.c">drivers/block/brd/c——基于 RAM 的块磁盘驱动程序</a></li>
<li><a class="reference external" href="https://www.linuxjournal.com/article/6931">I/O 调度器</a></li>
</ul>
</div>
<div class="section" id="section-14">
<h2>练习<a class="headerlink" href="#section-14" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 块设备驱动程序。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/块设备驱动程序/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-14">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-15">
<h3>0. 简介<a class="headerlink" href="#section-15" title="永久链接至标题">¶</a></h3>
<p>使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 在 Linux 内核中查找以下符号的定义：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">bio_for_each_segment</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">gendisk</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">block_device_operations</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-16">
<h3>1. 块设备<a class="headerlink" href="#section-16" title="永久链接至标题">¶</a></h3>
<p>创建一个内核模块，允许你注册或取消注册块设备。从实验骨架的 <code class="file docutils literal"><span class="pre">1-2-3-6-ram-disk/kernel</span></code> 目录中的文件开始。</p>
<p>按照实验骨架中标记为 <strong>TODO 1</strong> 的注释进行操作。使用现有的宏定义 (<code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code>, <code class="xref c c-macro docutils literal"><span class="pre">MY_BLKDEV_NAME</span></code>)。检查注册函数返回的值，在出现错误的情况下返回错误代码。</p>
<p>编译模块，将其复制到虚拟机并插入内核。验证你的设备是否成功创建在 <code class="file docutils literal"><span class="pre">/proc/devices</span></code> 内。你将看到一个主设备号为 240 的设备。</p>
<p>卸载内核模块，并检查设备是否已注销。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">查看 <a class="reference internal" href="#i-o">注册块 I/O 设备</a> 部分。</p>
</div>
<p>将 <code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code> 的值更改为 7。编译模块，将其复制到虚拟机并插入内核。注意到插入失败，因为已经有另一个驱动程序/设备在内核中注册了主设备号 7。</p>
<p>将 <code class="xref c c-macro docutils literal"><span class="pre">MY_BLOCK_MAJOR</span></code> 宏的值恢复为 240。</p>
</div>
<div class="section" id="section-17">
<h3>2. 磁盘注册<a class="headerlink" href="#section-17" title="永久链接至标题">¶</a></h3>
<p>修改前面的模块以添加与驱动程序关联的磁盘。分析宏定义、<code class="xref c c-type docutils literal"><span class="pre">my_block_dev</span></code> 结构以及 <code class="file docutils literal"><span class="pre">ram-disk.c</span></code> 文件中的现有函数。</p>
<p>按照标记为 <strong>TODO 2</strong> 的注释进行操作。使用 <code class="xref c c-func docutils literal"><span class="pre">create_block_device()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">delete_block_device()</span></code> 函数。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">查看 <a class="reference internal" href="#section-3">注册磁盘</a> 和 <a class="reference internal" href="#section-12">处理请求</a> 部分。</p>
</div>
<p>填充 <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> 函数以处理请求，但实际上不处理你的请求：显示“request received”消息以及以下信息：来自当前 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的起始扇区、总大小、数据大小和方向。要验证请求类型，请使用 :c:func:<a href="#system-message-1"><span class="problematic" id="problematic-1">`</span></a>blk_rq_is_passthrough`（该函数在请求由文件系统生成的情况下返回 0）。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">要找到所需的信息，查看 <a class="reference internal" href="#section-10">块设备的请求</a> 部分。</p>
</div>
<p>使用 <code class="xref c c-func docutils literal"><span class="pre">blk_mq_end_request()</span></code> 函数来完成请求的处理。</p>
<p>将模块插入内核，并检查模块打印的消息。当添加设备时，会向设备发送一个请求。检查 <code class="file docutils literal"><span class="pre">/dev/myblock</span></code> 是否存在，如果不存在，使用以下命令创建设备：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>mknod /dev/myblock b <span class="m">240</span> <span class="m">0</span>
</pre></div>
</div>
<p>要生成写入请求，请使用以下命令：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;abc&quot;</span>&gt; /dev/myblock
</pre></div>
</div>
<p>注意，写入请求之前会有一个读取请求。该请求用于从磁盘中读取块并使用用户提供的数据“更新”其内容，而不会覆盖其他部分。在读取和更新之后，写入操作发生。</p>
</div>
<div class="section" id="ram">
<h3>3. RAM 磁盘<a class="headerlink" href="#ram" title="永久链接至标题">¶</a></h3>
<p>修改前面的模块以创建一个 RAM 磁盘：对设备的请求将导致在一个内存区域中进行读写操作。</p>
<p>内存区域 <code class="xref c c-data docutils literal"><span class="pre">dev-&gt;data</span></code> 已经在模块的源代码中使用 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 进行了分配，并使用 <code class="xref c c-func docutils literal"><span class="pre">vfree()</span></code> 进行了释放。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">查看 <a class="reference internal" href="#section-12">处理请求</a> 部分。</p>
</div>
<p>按照标记为 <strong>TODO 3</strong> 的注释完成 <code class="xref c c-func docutils literal"><span class="pre">my_block_transfer()</span></code> 函数，将请求信息写入内存区域/从内存区域中读取。该函数将在队列处理函数 <code class="xref c c-func docutils literal"><span class="pre">my_block_request()</span></code> 中为每个请求调用。要写入/读取内存区域，请使用 <code class="xref c c-func docutils literal"><span class="pre">memcpy()</span></code>。要确定写入/读取的信息，请使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">request</span></code> 结构的字段。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">要了解请求数据的大小，请使用 <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_cur_bytes</span></code> 宏。不要使用 <code class="xref c c-macro docutils literal"><span class="pre">blk_rq_bytes</span></code> 宏。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">要找到与请求相关联的缓冲区，请使用 <code class="xref c c-data docutils literal"><span class="pre">bio_data`(:c:data:`rq-&gt;bio</span></code>)。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">有关有用的宏的描述，请参阅 <a class="reference internal" href="#section-10">块设备的请求</a> 部分。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">你可以在 <a class="reference external" href="http://lwn.net/Kernel/LDD3/">Linux 设备驱动程序</a> 的 <a class="reference external" href="https://github.com/martinezjavier/ldd3/blob/master/sbull/sbull.c">块设备驱动程序示例</a> 中找到有用的信息。</p>
</div>
<p>为了进行测试，使用测试文件 <code class="file docutils literal"><span class="pre">user/ram-disk-test.c</span></code>。测试程序在 <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code> 编译时会自动编译，之后使用 <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> 复制到虚拟机，可以在 QEMU 虚拟机上使用以下命令运行：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./ram-disk-test
</pre></div>
</div>
<p>无需将模块插入内核，它将由 <code class="docutils literal"><span class="pre">ram-disk-test</span></code> 命令插入。</p>
<p>由于传输数据缺乏同步（刷新），一些测试可能会失败。</p>
</div>
<div class="section" id="section-18">
<h3>4. 从磁盘读取数据<a class="headerlink" href="#section-18" title="永久链接至标题">¶</a></h3>
<p>本练习的目的是从内核直接读取 <code class="xref c c-macro docutils literal"><span class="pre">PHYSICAL_DISK_NAME</span></code> 磁盘（<code class="file docutils literal"><span class="pre">/dev/vdb</span></code>）的数据。</p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>在解决此练习之前，我们需要确保将磁盘添加到虚拟机中。</p>
<p>检查 <code class="file docutils literal"><span class="pre">qemu/Makefile</span></code> 中的变量 <code class="docutils literal"><span class="pre">QEMU_OPTS</span></code>。应该已经使用 <code class="docutils literal"><span class="pre">-drive</span> <span class="pre">...</span></code> 添加了两个额外的磁盘。</p>
<p class="last">如果没有，请使用以下命令生成我们将用作磁盘镜像的文件：<strong class="command">dd if=/dev/zero of=qemu/mydisk.img bs=1024 count=1</strong> 并将以下选项添加到 <code class="file docutils literal"><span class="pre">qemu/Makefile`（在</span> <span class="pre">:c:data:`QEMU_OPTS</span></code> 变量之中，root 盘之后）：
<strong class="command">-drive file=qemu/mydisk.img,if=virtio,format=raw</strong></p>
</div>
<p>按照目录 <code class="file docutils literal"><span class="pre">4-5-relay/</span></code> 中标记为 <strong>TODO 4</strong> 的注释，实现 <code class="xref c c-func docutils literal"><span class="pre">open_disk()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">close_disk()</span></code> 函数。使用 <code class="xref c c-func docutils literal"><span class="pre">blkdev_get_by_path()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">blkdev_put()</span></code> 函数。设备必须以独占的读写模式打开 (<code class="xref c c-macro docutils literal"><span class="pre">FMODE_READ</span></code> | <code class="xref c c-macro docutils literal"><span class="pre">FMODE_WRITE</span></code> | <code class="xref c c-macro docutils literal"><span class="pre">FMODE_EXCL</span></code>)，并且当前模块必须作为 holder（<code class="xref c c-macro docutils literal"><span class="pre">THIS_MODULE</span></code>）。</p>
<p>实现 <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> 函数。你将需要创建新的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构并填充它，然后提交它并等待它。读取磁盘的第一个扇区。要等待，请调用 <code class="xref c c-func docutils literal"><span class="pre">submit_bio_wait()</span></code> 函数。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>磁盘的第一个扇区是索引为 0 的扇区。这个值必须用于初始化 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的 <code class="xref c c-member docutils literal"><span class="pre">bi_iter.bi_sector</span></code> 字段。</p>
<p class="last">对于读操作，使用 <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_READ</span></code> 宏来初始化 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的 <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> 字段。</p>
</div>
<p>操作完成后，显示 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构读取的前 3 个字节数据。使用 <code class="docutils literal"><span class="pre">&quot;%</span> <span class="pre">02x&quot;</span></code> 格式作为 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 的参数来显示数据以及 <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> 宏。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">对于 <code class="xref c c-func docutils literal"><span class="pre">kmap_atomic()</span></code> 函数的实参，只需使用代码中分配的页面，即 <code class="xref c c-data docutils literal"><span class="pre">page</span></code> 变量。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">请查看 <a class="reference internal" href="#bio-content"><span class="std std-ref">如何使用 struct bio 结构的内容</span></a> 和 <a class="reference internal" href="#bio-completion"><span class="std std-ref">等待 struct bio 结构的完成</span></a> 部分。</p>
</div>
<p>为了进行测试，使用 <code class="file docutils literal"><span class="pre">test-relay-disk</span></code> 脚本，在运行 <strong class="command">make copy</strong> 时会将其复制到虚拟机中。如果未复制，请确保该脚本可执行：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>chmod +x test-relay-disk
</pre></div>
</div>
<p>无需将模块加载到内核中，它将由 <strong class="command">test-relay-disk</strong> 加载。</p>
<p>使用以下命令运行脚本：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./test-relay-disk
</pre></div>
</div>
<p>脚本会将“abc”写入到 <code class="xref c c-macro docutils literal"><span class="pre">PHYSICAL_DISK_NAME</span></code> 指定的磁盘的开头。运行后，模块将显示 61 62 63（字母“a”、“b”和“c”的十六进制值）。</p>
</div>
<div class="section" id="section-19">
<h3>5. 将数据写入磁盘<a class="headerlink" href="#section-19" title="永久链接至标题">¶</a></h3>
<p>按照标有 <strong>TODO 5</strong> 的注释，在磁盘上写入消息（<code class="xref c c-macro docutils literal"><span class="pre">BIO_WRITE_MESSAGE</span></code>）。</p>
<p>函数 <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> 接收操作类型（读取或写入）作为实参。在函数 <code class="xref c c-func docutils literal"><span class="pre">relay_init()</span></code> 中调用读取函数，在函数 <code class="xref c c-func docutils literal"><span class="pre">relay_exit()</span></code> 中调用写入函数。建议使用 <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_READ</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">REQ_OP_WRITE</span></code> 宏。</p>
<p>在 <code class="xref c c-func docutils literal"><span class="pre">send_test_bio()</span></code> 函数中，如果操作是写入，使用消息 <code class="xref c c-macro docutils literal"><span class="pre">BIO_WRITE_MESSAGE</span></code> 填充与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构相关联的缓冲区。使用 <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> 宏来处理与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构相关联的缓冲区。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">需要通过相应地设置 <code class="xref c c-member docutils literal"><span class="pre">bi_opf</span></code> 字段来更新与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构相关联的操作类型。</p>
</div>
<p>为了测试，请使用以下命令运行 <code class="file docutils literal"><span class="pre">test-relay-disk</span></code> 脚本：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./test-relay-disk
</pre></div>
</div>
<p>该脚本将在标准输出中显示 <code class="docutils literal"><span class="pre">&quot;read</span> <span class="pre">from</span> <span class="pre">/dev/sdb:</span> <span class="pre">64</span> <span class="pre">65</span> <span class="pre">66&quot;</span></code> 消息。</p>
</div>
<div class="section" id="struct-bio-8">
<h3>6. 在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 级别处理请求队列中的请求<a class="headerlink" href="#struct-bio-8" title="永久链接至标题">¶</a></h3>
<p>在练习 3 的实现中，我们只处理了请求的当前 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code>。我们希望处理来自请求队列中所有 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的所有 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio_vec</span></code> 结构（也称为段）。</p>
<p>在 ramdisk 的实现（<code class="file docutils literal"><span class="pre">1-2-3-6-ram-disk/</span></code> 目录）中，添加一些支持，使得其可以在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 级别处理请求队列中的请求。按照标有 <strong>TODO 6</strong> 的注释进行操作。</p>
<p>将 <code class="xref c c-macro docutils literal"><span class="pre">USE_BIO_TRANSFER</span></code> 宏设置为 1。</p>
<p>实现 <code class="xref c c-func docutils literal"><span class="pre">my_xfer_request()</span></code> 函数。使用 <code class="xref c c-macro docutils literal"><span class="pre">rq_for_each_segment</span></code> 宏遍历请求中每个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的 <code class="xref c c-type docutils literal"><span class="pre">bio_vec</span></code> 结构。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">请查阅 <a class="reference internal" href="#bio-content"><span class="std std-ref">如何使用 struct bio 结构的内容</span></a> 部分中的指示和代码片段。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的段迭代器获取当前扇区（<code class="xref c c-member docutils literal"><span class="pre">iter.iter.bi_sector</span></code>）。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用请求迭代器获取对当前 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 的引用（<code class="xref c c-member docutils literal"><span class="pre">iter.bio</span></code>）。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-macro docutils literal"><span class="pre">bio_data_dir</span></code> 宏查找读取或写入的方向。</p>
</div>
<p>使用 <code class="xref c c-macro docutils literal"><span class="pre">kmap_atomic</span></code> 或 <code class="xref c c-macro docutils literal"><span class="pre">kunmap_atomic</span></code> 宏映射每个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bio</span></code> 结构的页面并访问其关联的缓冲区。为了进行实际的传输，调用前面练习中实现的 <code class="xref c c-func docutils literal"><span class="pre">my_block_transfer()</span></code> 函数。</p>
<p>为了进行测试，请使用 <code class="file docutils literal"><span class="pre">ram-disk-test.c</span></code> 测试文件：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>./ram-disk-test
</pre></div>
</div>
<p>无需将模块插入到内核中，它将由 <strong class="command">ram-disk-test</strong> 可执行文件插入。</p>
<p>某些测试可能会由于传输数据的缺乏同步（刷新）而崩溃。</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab6-memory-mapping.html" class="btn btn-neutral float-left" title="SO2 Lab 06 - Memory Mapping" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab8-filesystems-part1.html" class="btn btn-neutral float-right" title="SO2 Lab 08 - File system drivers (Part 1)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>