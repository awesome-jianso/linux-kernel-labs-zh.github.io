<!DOCTYPE html>


<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>SO2 Lecture 03 - Processes &mdash; The Linux Kernel  documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/styles.css" type="text/css" />
    <link rel="stylesheet" href="../_static/single.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    
    
    <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
    <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/asciinema-player.js"></script>
    <script type="text/javascript" src="../_static/common.js"></script>
    
    <script type="text/javascript" src="../_static/slides.js"></script>
    <script type="text/javascript" src="../_static/sync.js"></script>
    <script type="text/javascript" src="../_static/controller.js"></script>
    <script type="text/javascript" src="../_static/init.js"></script>
    
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="top" title="The Linux Kernel  documentation" href="../index.html" />
    <link rel="up" title="Operating Systems 2" href="index.html" />
    <link rel="next" title="SO2 Lecture 04 - Interrupts" href="lec4-interrupts.html" />
    <link rel="prev" title="SO2 Lecture 02 - System calls" href="lec2-syscalls.html" /> 
  </head>
  <body>

<section
   id="slide_container"
   class='slides layout-regular'>


  
<article class="admonition-so2-lecture-03-processes slide level-1">

<h1>SO2 Lecture 03 - Processes</h1>





</article>
<article class="admonition-processes-and-threads slide level-2">

<h2>Processes and threads</h2>

<ul class="simple">
<li>Process and threads</li>
<li>Context switching</li>
<li>Blocking and waking up</li>
<li>Process context</li>
</ul>




</article>
<article class="admonition-what-is-a-process slide level-2">

<h2>What is a process?</h2>

<table class="hlist"><tr><td><ul class="simple">
<li>An address space</li>
<li>One or more threads</li>
<li>Opened files</li>
<li>Sockets</li>
<li>Semaphores</li>
</ul>
</td><td><ul class="simple">
<li>Shared memory regions</li>
<li>Timers</li>
<li>Signal handlers</li>
<li>Many other resources and status information</li>
</ul>
</td></tr></table>
<p>All this information is grouped in the Process Control Group
(PCB). In Linux this is <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>.</p>




</article>
<article class="admonition-overview-of-process-resources slide level-2">

<h2>Overview of process resources</h2>

<div class="highlight-none"><div class="highlight"><pre><span></span>                +-------------------------------------------------------------------+
                | dr-x------    2 tavi tavi 0  2021 03 14 12:34 .                   |
                | dr-xr-xr-x    6 tavi tavi 0  2021 03 14 12:34 ..                  |
                | lrwx------    1 tavi tavi 64 2021 03 14 12:34 0 -&gt; /dev/pts/4     |
           +---&gt;| lrwx------    1 tavi tavi 64 2021 03 14 12:34 1 -&gt; /dev/pts/4     |
           |    | lrwx------    1 tavi tavi 64 2021 03 14 12:34 2 -&gt; /dev/pts/4     |
           |    | lr-x------    1 tavi tavi 64 2021 03 14 12:34 3 -&gt; /proc/18312/fd |
           |    +-------------------------------------------------------------------+
           |                 +----------------------------------------------------------------+
           |                 | 08048000-0804c000 r-xp 00000000 08:02 16875609 /bin/cat        |
$ ls -1 /proc/self/          | 0804c000-0804d000 rw-p 00003000 08:02 16875609 /bin/cat        |
cmdline    |                 | 0804d000-0806e000 rw-p 0804d000 00:00 0 [heap]                 |
cwd        |                 | ...                                                            |
environ    |    +-----------&gt;| b7f46000-b7f49000 rw-p b7f46000 00:00 0                        |
exe        |    |            | b7f59000-b7f5b000 rw-p b7f59000 00:00 0                        |
fd --------+    |            | b7f5b000-b7f77000 r-xp 00000000 08:02 11601524 /lib/ld-2.7.so  |
fdinfo          |            | b7f77000-b7f79000 rw-p 0001b000 08:02 11601524 /lib/ld-2.7.so  |
maps -----------+            | bfa05000-bfa1a000 rw-p bffeb000 00:00 0 [stack]                |
mem                          | ffffe000-fffff000 r-xp 00000000 00:00 0 [vdso]                 |
root                         +----------------------------------------------------------------+
stat                 +----------------------------+
statm                |  Name: cat                 |
status ------+       |  State: R (running)        |
task         |       |  Tgid: 18205               |
wchan        +------&gt;|  Pid: 18205                |
                     |  PPid: 18133               |
                     |  Uid: 1000 1000 1000 1000  |
                     |  Gid: 1000 1000 1000 1000  |
                     +----------------------------+
</pre></div>
</div>




</article>
<article class="admonition-struct-task-struct slide level-2">

<h2>struct task_struct</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span>$ pahole -C task_struct vmlinux

struct task_struct {
    struct thread_info thread_info;                  /*     0     8 */
    volatile long int          state;                /*     8     4 */
    void *                     stack;                /*    12     4 */

    ...

    /* --- cacheline 45 boundary (2880 bytes) --- */
    struct thread_struct thread __attribute__((__aligned__(64))); /*  2880  4288 */

    /* size: 7168, cachelines: 112, members: 155 */
    /* sum members: 7148, holes: 2, sum holes: 12 */
    /* sum bitfield members: 7 bits, bit holes: 2, sum bit holes: 57 bits */
    /* paddings: 1, sum paddings: 2 */
    /* forced alignments: 6, forced holes: 2, sum forced holes: 12 */
} __attribute__((__aligned__(64)));
</pre></div>
</div>




</article>
<article class="admonition-inspecting-task-struct slide level-2">

<h2>Inspecting task_struct</h2>

<p>&nbsp;</p>
<asciinema-player src="../_images/inspect_task_struct.cast"></asciinema-player>



</article>
<article class="admonition-quiz-inspect-opened-files slide level-2">

<h2>Quiz: Inspect opened files</h2>

<p>Use the debugger to inspect the process named syslogd.</p>
<ul class="simple">
<li>What command should we use to list the opened file descriptors?</li>
<li>How many file descriptors are opened?</li>
<li>What command should we use the determine the file name for opened file descriptor 3?</li>
<li>What is the filename for file descriptor 3?</li>
</ul>




</article>
<article class="admonition-threads slide level-2">

<h2>Threads</h2>

<ul class="simple">
<li>Each thread has its own stack and together with the register
values it determines the thread execution state</li>
<li>A thread runs in the context of a process and all threads in the
same process share the resources</li>
<li>The kernel schedules threads not processes and user-level threads
(e.g. fibers, coroutines, etc.) are not visible at the kernel level</li>
</ul>




</article>
<article class="admonition-classic-implementation-windows slide level-2">

<h2>Classic implementation (Windows)</h2>

<p>&nbsp;</p>
<img alt="../_images/ditaa-4b5c1874d3924d9716f26d4893a3e4f313bf1c43.png" src="../_images/ditaa-4b5c1874d3924d9716f26d4893a3e4f313bf1c43.png" />




</article>
<article class="admonition-linux-implementation slide level-2">

<h2>Linux implementation</h2>

<p>&nbsp;</p>
<img alt="../_images/ditaa-fd771038e88b95def30ae9bd4df0b7bd6b7b3503.png" src="../_images/ditaa-fd771038e88b95def30ae9bd4df0b7bd6b7b3503.png" />




</article>
<article class="admonition-the-clone-system-call slide level-2">

<h2>The clone system call</h2>

<ul class="simple">
<li>CLONE_FILES - shares the file descriptor table with the parent</li>
<li>CLONE_VM - shares the address space with the parent</li>
<li>CLONE_FS - shares the filesystem information (root directory,
current directory) with the parent</li>
<li>CLONE_NEWNS - does not share the mount namespace with the parent</li>
<li>CLONE_NEWIPC - does not share the IPC namespace (System V IPC
objects, POSIX message queues) with the parent</li>
<li>CLONE_NEWNET - does not share the networking namespaces (network
interfaces, routing table) with the parent</li>
</ul>




</article>
<article class="admonition-namespaces-and-containers slide level-2">

<h2>Namespaces and &quot;containers&quot;</h2>

<ul class="simple">
<li>Containers = a form of lightweight virtual machines</li>
<li>Container based technologies: LXC, docker</li>
<li>Containers are built of top of kernel namespaces</li>
<li>Kernel namespaces allows isolation of otherwise globally visible
resources</li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nsproxy</span></code> has multiple namespaces each of which
can be selectively shared between groups of processes</li>
<li>At boot initial namespaces are created (e.g. <code class="xref c c-data docutils literal"><span class="pre">init_net</span></code>)
that are by default shared between new processes (e.g. list of
available network interfaces)</li>
<li>New namespace can be created a runtime and new processes can
point to these new namespaces</li>
</ul>




</article>
<article class="admonition-accessing-the-current-process slide level-2">

<h2>Accessing the current process</h2>

<p>Accessing the current process is a frequent operation:</p>
<ul class="simple">
<li>opening a file needs access to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>'s
file field</li>
<li>mapping a new file needs access to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>'s
mm field</li>
<li>Over 90% of the system calls needs to access the current process
structure so it needs to be fast</li>
<li>The <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> macro is available to access to current
process's <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code></li>
</ul>




</article>
<article class="admonition-accessing-the-current-process-on-x86 slide level-2">

<h2>Accessing the current process on x86</h2>

<p>&nbsp;</p>
<img alt="../_images/ditaa-019489e686a2f60f1594e37458cfcb10320eae0f.png" src="../_images/ditaa-019489e686a2f60f1594e37458cfcb10320eae0f.png" />




</article>
<article class="admonition-previous-implementation-for-current-x86 slide level-2">

<h2>Previous implementation for current (x86)</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span>/* how to get the current stack pointer from C */
register unsigned long current_stack_pointer asm(&quot;esp&quot;) __attribute_used__;

/* how to get the thread information struct from C */
static inline struct thread_info *current_thread_info(void)
{
   return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE – 1));
}

#define current current_thread_info()-&gt;task
</pre></div>
</div>




</article>
<article class="admonition-quiz-previous-implementation-for-current-x86 slide level-2">

<h2>Quiz: previous implementation for current (x86)</h2>

<p>What is the size of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">thread_info</span></code>?</p>
<p>Which of the following are potential valid sizes for
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">thread_info</span></code>: 4095, 4096, 4097?</p>




</article>
<article class="admonition-overview-the-context-switching-processes slide level-2">

<h2>Overview the context switching processes</h2>

<img alt="../_images/ditaa-f6b228332baf165f498d8a1bb0bc0bdb91ae50c5.png" src="../_images/ditaa-f6b228332baf165f498d8a1bb0bc0bdb91ae50c5.png" />




</article>
<article class="admonition-context-switch slide level-2">

<h2>context_switch</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span>
<span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
         <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">prepare_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * For paravirt, this is coupled with an exit in switch_to to</span>
<span class="cm">     * combine the page table reload and the switch backend into</span>
<span class="cm">     * one hypercall.</span>
<span class="cm">     */</span>
    <span class="n">arch_start_context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * kernel -&gt; kernel   lazy + transfer active</span>
<span class="cm">     *   user -&gt; kernel   lazy + mmgrab() active</span>
<span class="cm">     *</span>
<span class="cm">     * kernel -&gt;   user   switch + mmdrop() active</span>
<span class="cm">     *   user -&gt;   user   switch</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                                <span class="c1">// to kernel</span>
        <span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>                           <span class="c1">// from user</span>
            <span class="n">mmgrab</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="c1">// to user</span>
        <span class="n">membarrier_switch_mm</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="cm">/*</span>
<span class="cm">         * sys_membarrier() requires an smp_mb() between setting</span>
<span class="cm">         * rq-&gt;curr / membarrier_switch_mm() and returning to userspace.</span>
<span class="cm">         *</span>
<span class="cm">         * The below provides this either through switch_mm(), or in</span>
<span class="cm">         * case &#39;prev-&gt;active_mm == next-&gt;mm&#39; through</span>
<span class="cm">         * finish_task_switch()&#39;s mmdrop().</span>
<span class="cm">         */</span>
        <span class="n">switch_mm_irqs_off</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                        <span class="c1">// from kernel</span>
            <span class="cm">/* will mmdrop() in finish_task_switch(). */</span>
            <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>

    <span class="n">prepare_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>

    <span class="cm">/* Here we just switch the register state and the stack. */</span>
    <span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="n">barrier</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>




</article>
<article class="admonition-switch-to slide level-2">

<h2>switch_to</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define switch_to(prev, next, last)               \</span>
<span class="cp">do {                                              \</span>
<span class="cp">    ((last) = __switch_to_asm((prev), (next)));   \</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * %eax: prev task</span>
<span class="cm"> * %edx: next task</span>
<span class="cm"> */</span>
<span class="p">.</span><span class="n">pushsection</span> <span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="s">&quot;ax&quot;</span>
<span class="n">SYM_CODE_START</span><span class="p">(</span><span class="n">__switch_to_asm</span><span class="p">)</span>
    <span class="cm">/*</span>
<span class="cm">     * Save callee-saved registers</span>
<span class="cm">     * This must match the order in struct inactive_task_frame</span>
<span class="cm">     */</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebp</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebx</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">edi</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">esi</span>
    <span class="cm">/*</span>
<span class="cm">     * Flags are saved to prevent AC leakage. This could go</span>
<span class="cm">     * away if objtool would have 32bit support to verify</span>
<span class="cm">     * the STAC/CLAC correctness.</span>
<span class="cm">     */</span>
    <span class="n">pushfl</span>

<span class="hll">    <span class="cm">/* switch stack */</span>
</span><span class="hll">    <span class="n">movl</span>    <span class="o">%</span><span class="n">esp</span><span class="p">,</span> <span class="n">TASK_threadsp</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class="hll">    <span class="n">movl</span>    <span class="n">TASK_threadsp</span><span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">esp</span>
</span>
  <span class="cp">#ifdef CONFIG_STACKPROTECTOR</span>
    <span class="n">movl</span>    <span class="n">TASK_stack_canary</span><span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">ebx</span>
    <span class="n">movl</span>    <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="n">PER_CPU_VAR</span><span class="p">(</span><span class="n">stack_canary</span><span class="p">)</span><span class="o">+</span><span class="n">stack_canary_offset</span>
  <span class="cp">#endif</span>

  <span class="cp">#ifdef CONFIG_RETPOLINE</span>
    <span class="cm">/*</span>
<span class="cm">     * When switching from a shallower to a deeper call stack</span>
<span class="cm">     * the RSB may either underflow or use entries populated</span>
<span class="cm">     * with userspace addresses. On CPUs where those concerns</span>
<span class="cm">     * exist, overwrite the RSB with entries which capture</span>
<span class="cm">     * speculative execution to prevent attack.</span>
<span class="cm">     */</span>
    <span class="n">FILL_RETURN_BUFFER</span> <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="n">RSB_CLEAR_LOOPS</span><span class="p">,</span> <span class="n">X86_FEATURE_RSB_CTXSW</span>
    <span class="cp">#endif</span>

    <span class="cm">/* Restore flags or the incoming task to restore AC state. */</span>
    <span class="n">popfl</span>
    <span class="cm">/* restore callee-saved registers */</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">esi</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">edi</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">ebx</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">ebp</span>

<span class="hll">    <span class="n">jmp</span>     <span class="n">__switch_to</span>
</span>  <span class="n">SYM_CODE_END</span><span class="p">(</span><span class="n">__switch_to_asm</span><span class="p">)</span>
  <span class="p">.</span><span class="n">popsection</span>
</pre></div>
</div>




</article>
<article class="admonition-inspecting-task-struct slide level-2">

<h2>Inspecting task_struct</h2>

<p>&nbsp;</p>
<asciinema-player src="../_images/context_switch.cast"></asciinema-player>



</article>
<article class="admonition-quiz-context-switch slide level-2">

<h2>Quiz: context switch</h2>

<p>We are executing a context switch. Select all of the statements that are true.</p>
<ul class="simple">
<li>the ESP register is saved in the task structure</li>
<li>the EIP register is saved in the task structure</li>
<li>general registers are saved in the task structure</li>
<li>the ESP register is saved on the stack</li>
<li>the EIP register is saved on the stack</li>
<li>general registers are saved on the stack</li>
</ul>




</article>
<article class="admonition-task-states slide level-2">

<h2>Task states</h2>

<img alt="../_images/ditaa-0b8cde2be9bbd195ac9dcaeac978a8bbe0d3b805.png" src="../_images/ditaa-0b8cde2be9bbd195ac9dcaeac978a8bbe0d3b805.png" />




</article>
<article class="admonition-blocking-the-current-thread slide level-2">

<h2>Blocking the current thread</h2>

<ul class="simple">
<li>Set the current thread state to TASK_UINTERRUPTIBLE or
TASK_INTERRUPTIBLE</li>
<li>Add the task to a waiting queue</li>
<li>Call the scheduler which will pick up a new task from the READY
queue</li>
<li>Do the context switch to the new task</li>
</ul>




</article>
<article class="admonition-wait-event slide level-2">

<h2>wait_event</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * wait_event - sleep until a condition gets true</span>
<span class="cm"> * @wq_head: the waitqueue to wait on</span>
<span class="cm"> * @condition: a C expression for the event to wait for</span>
<span class="cm"> *</span>
<span class="cm"> * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the</span>
<span class="cm"> * @condition evaluates to true. The @condition is checked each time</span>
<span class="cm"> * the waitqueue @wq_head is woken up.</span>
<span class="cm"> *</span>
<span class="cm"> * wake_up() has to be called after changing any variable that could</span>
<span class="cm"> * change the result of the wait condition.</span>
<span class="cm"> */</span>
<span class="cp">#define wait_event(wq_head, condition)            \</span>
<span class="cp">do {                                              \</span>
<span class="cp">  might_sleep();                                  \</span>
<span class="cp">  if (condition)                                  \</span>
<span class="cp">          break;                                  \</span>
<span class="cp">  __wait_event(wq_head, condition);               \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __wait_event(wq_head, condition)                                  \</span>
<span class="cp">    (void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,   \</span>
<span class="cp">                        schedule())</span>

<span class="cm">/*</span>
<span class="cm"> * The below macro ___wait_event() has an explicit shadow of the __ret</span>
<span class="cm"> * variable when used from the wait_event_*() macros.</span>
<span class="cm"> *</span>
<span class="cm"> * This is so that both can use the ___wait_cond_timeout() construct</span>
<span class="cm"> * to wrap the condition.</span>
<span class="cm"> *</span>
<span class="cm"> * The type inconsistency of the wait_event_*() __ret variable is also</span>
<span class="cm"> * on purpose; we use long where we can return timeout values and int</span>
<span class="cm"> * otherwise.</span>
<span class="cm"> */</span>
<span class="cp">#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)    \</span>
<span class="cp">({                                                                       \</span>
<span class="cp">    __label__ __out;                                                     \</span>
<span class="cp">    struct wait_queue_entry __wq_entry;                                  \</span>
<span class="cp">    long __ret = ret;       </span><span class="cm">/* explicit shadow */</span><span class="cp">                        \</span>
<span class="cp">                                                                         \</span>
<span class="cp">    init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);     \</span>
<span class="cp">    for (;;) {                                                           \</span>
<span class="cp">        long __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);\</span>
<span class="cp">                                                                         \</span>
<span class="cp">        if (condition)                                                   \</span>
<span class="cp">            break;                                                       \</span>
<span class="cp">                                                                         \</span>
<span class="cp">        if (___wait_is_interruptible(state) &amp;&amp; __int) {                  \</span>
<span class="cp">            __ret = __int;                                               \</span>
<span class="cp">            goto __out;                                                  \</span>
<span class="cp">        }                                                                \</span>
<span class="cp">                                                                         \</span>
<span class="cp">        cmd;                                                             \</span>
<span class="cp">    }                                                                    \</span>
<span class="cp">    finish_wait(&amp;wq_head, &amp;__wq_entry);                                  \</span>
<span class="cp">   __out:  __ret;                                                        \</span>
<span class="cp"> })</span>

 <span class="kt">void</span> <span class="nf">init_wait_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
 <span class="p">{</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">autoremove_wake_function</span><span class="p">;</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="kt">long</span> <span class="nf">prepare_to_wait_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
     <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

     <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
         <span class="cm">/*</span>
<span class="cm">          * Exclusive waiter must not fail if it was selected by wakeup,</span>
<span class="cm">          * it should &quot;consume&quot; the condition we were waiting for.</span>
<span class="cm">          *</span>
<span class="cm">          * The caller will recheck the condition and return success if</span>
<span class="cm">          * we were already woken up, we can not miss the event because</span>
<span class="cm">          * wakeup locks/unlocks the same wq_head-&gt;lock.</span>
<span class="cm">          *</span>
<span class="cm">          * But we need to ensure that set-condition + wakeup after that</span>
<span class="cm">          * can&#39;t see us, it should wake up another exclusive waiter if</span>
<span class="cm">          * we fail.</span>
<span class="cm">          */</span>
         <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span>
                 <span class="n">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">wq_entry</span><span class="p">);</span>
             <span class="k">else</span>
                 <span class="n">__add_wait_queue</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">wq_entry</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="cm">/**</span>
<span class="cm">  * finish_wait - clean up after waiting in a queue</span>
<span class="cm">  * @wq_head: waitqueue waited on</span>
<span class="cm">  * @wq_entry: wait descriptor</span>
<span class="cm">  *</span>
<span class="cm">  * Sets current thread back to running state and removes</span>
<span class="cm">  * the wait descriptor from the given waitqueue if still</span>
<span class="cm">  * queued.</span>
<span class="cm">  */</span>
 <span class="kt">void</span> <span class="nf">finish_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

     <span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
     <span class="cm">/*</span>
<span class="cm">      * We can check for list emptiness outside the lock</span>
<span class="cm">      * IFF:</span>
<span class="cm">      *  - we use the &quot;careful&quot; check that verifies both</span>
<span class="cm">      *    the next and prev pointers, so that there cannot</span>
<span class="cm">      *    be any half-pending updates in progress on other</span>
<span class="cm">      *    CPU&#39;s that we haven&#39;t seen yet (and that might</span>
<span class="cm">      *    still change the stack area.</span>
<span class="cm">      * and</span>
<span class="cm">      *  - all other users take the lock (ie we can only</span>
<span class="cm">      *    have _one_ other CPU that looks at or modifies</span>
<span class="cm">      *    the list).</span>
<span class="cm">      */</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
         <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
         <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
         <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>
</pre></div>
</div>




</article>
<article class="admonition-waking-up-a-task slide level-2">

<h2>Waking up a task</h2>

<ul class="simple">
<li>Select a task from the waiting queue</li>
<li>Set the task state to TASK_READY</li>
<li>Insert the task into the scheduler's READY queue</li>
<li>On SMP system this is a complex operation: each processor has its
own queue, queues need to be balanced, CPUs needs to be signaled</li>
</ul>




</article>
<article class="admonition-wake-up slide level-2">

<h2>wake_up</h2>

<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define wake_up(x)                        __wake_up(x, TASK_NORMAL, 1, NULL)</span>

<span class="cm">/**</span>
<span class="cm"> * __wake_up - wake up threads blocked on a waitqueue.</span>
<span class="cm"> * @wq_head: the waitqueue</span>
<span class="cm"> * @mode: which threads</span>
<span class="cm"> * @nr_exclusive: how many wake-one or wake-many threads to wake up</span>
<span class="cm"> * @key: is directly passed to the wakeup function</span>
<span class="cm"> *</span>
<span class="cm"> * If this function wakes up a task, it executes a full memory barrier before</span>
<span class="cm"> * accessing the task state.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__wake_up_common_lock</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wake_up_common_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">wait_queue_entry_t</span> <span class="n">bookmark</span><span class="p">;</span>

  <span class="n">bookmark</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">bookmark</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">bookmark</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>

  <span class="k">do</span> <span class="p">{</span>
          <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
          <span class="n">nr_exclusive</span> <span class="o">=</span> <span class="n">__wake_up_common</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span>
                                          <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bookmark</span><span class="p">);</span>
          <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bookmark</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The core wakeup function. Non-exclusive wakeups (nr_exclusive == 0) just</span>
<span class="cm"> * wake everything up. If it&#39;s an exclusive wakeup (nr_exclusive == small +ve</span>
<span class="cm"> * number) then we wake all the non-exclusive tasks and one exclusive task.</span>
<span class="cm"> *</span>
<span class="cm"> * There are circumstances in which we can try to wake a task which has already</span>
<span class="cm"> * started to run but is not in state TASK_RUNNING. try_to_wake_up() returns</span>
<span class="cm"> * zero in this (rare) case, and we handle it by continuing to scan the queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wake_up_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                  <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">bookmark</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">bookmark</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">list_next_entry</span><span class="p">(</span><span class="n">bookmark</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

          <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
          <span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">wait_queue_entry_t</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">nr_exclusive</span><span class="p">;</span>

    <span class="n">list_for_each_entry_safe_from</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">)</span>
                  <span class="k">continue</span><span class="p">;</span>

          <span class="n">ret</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span>
                  <span class="k">break</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">bookmark</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">++</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">WAITQUEUE_WALK_BREAK_CNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                          <span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
                  <span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">;</span>
                  <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">nr_exclusive</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">autoremove_wake_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">default_wake_function</span><span class="p">(</span><span class="n">wq_entry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="n">list_del_init_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">default_wake_function</span><span class="p">(</span><span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
                    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_SCHED_DEBUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">WF_SYNC</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_wake_up - wake up a thread</span>
<span class="cm"> * @p: the thread to be awakened</span>
<span class="cm"> * @state: the mask of task states that can be woken</span>
<span class="cm"> * @wake_flags: wake modifier flags (WF_*)</span>
<span class="cm"> *</span>
<span class="cm"> * Conceptually does:</span>
<span class="cm"> *</span>
<span class="cm"> *   If (@state &amp; @p-&gt;state) @p-&gt;state = TASK_RUNNING.</span>
<span class="cm"> *</span>
<span class="cm"> * If the task was not queued/runnable, also place it back on a runqueue.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is atomic against schedule() which would dequeue the task.</span>
<span class="cm"> *</span>
<span class="cm"> * It issues a full memory barrier before accessing @p-&gt;state, see the comment</span>
<span class="cm"> * with set_current_state().</span>
<span class="cm"> *</span>
<span class="cm"> * Uses p-&gt;pi_lock to serialize against concurrent wake-ups.</span>
<span class="cm"> *</span>
<span class="cm"> * Relies on p-&gt;pi_lock stabilizing:</span>
<span class="cm"> *  - p-&gt;sched_class</span>
<span class="cm"> *  - p-&gt;cpus_ptr</span>
<span class="cm"> *  - p-&gt;sched_task_group</span>
<span class="cm"> * in order to do migration, see its use of select_task_rq()/set_task_cpu().</span>
<span class="cm"> *</span>
<span class="cm"> * Tries really hard to only take one task_rq(p)-&gt;lock for performance.</span>
<span class="cm"> * Takes rq-&gt;lock in:</span>
<span class="cm"> *  - ttwu_runnable()    -- old rq, unavoidable, see comment there;</span>
<span class="cm"> *  - ttwu_queue()       -- new rq, for enqueue of the task;</span>
<span class="cm"> *  - psi_ttwu_dequeue() -- much sadness :-( accounting will kill us.</span>
<span class="cm"> *</span>
<span class="cm"> * As a consequence we race really badly with just about everything. See the</span>
<span class="cm"> * many memory barriers and their comments for details.</span>
<span class="cm"> *</span>
<span class="cm"> * Return: %true if @p-&gt;state changes (an actual wakeup was done),</span>
<span class="cm"> *           %false otherwise.</span>
<span class="cm"> */</span>
 <span class="k">static</span> <span class="kt">int</span>
 <span class="nf">try_to_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="p">...</span>
</pre></div>
</div>




</article>
<article class="admonition-non-preemptive-kernel slide level-2">

<h2>Non preemptive kernel</h2>

<ul class="simple">
<li>At every tick the kernel checks to see if the current process has
its time slice consumed</li>
<li>If that happens a flag is set in interrupt context</li>
<li>Before returning to userspace the kernel checks this flag and
calls <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> if needed</li>
<li>In this case tasks are not preempted while running in kernel mode
(e.g. system call) so there are no synchronization issues</li>
</ul>




</article>
<article class="admonition-preemptive-kernel slide level-2">

<h2>Preemptive kernel</h2>

<ul class="simple">
<li>Tasks can be preempted even when running in kernel mode</li>
<li>It requires new synchronization primitives to be used in critical
sections: <code class="xref c c-macro docutils literal"><span class="pre">preempt_disable</span></code> and
<code class="xref c c-macro docutils literal"><span class="pre">preempt_enable</span></code></li>
<li>Spinlocks also disable preemption</li>
<li>When a thread needs to be preempted a flag is set and action is
taken (e.g. scheduler is called) when preemption is reactivated</li>
</ul>




</article>
<article class="admonition-process-context slide level-2">

<h2>Process context</h2>

<p>The kernel is executing in process context when it is running a
system call.</p>
<p>In process context there is a well defined context and we can
access the current process data with <code class="xref c c-macro docutils literal"><span class="pre">current</span></code></p>
<p>In process context we can sleep (wait on a condition).</p>
<p>In process context we can access the user-space (unless we are
running in a kernel thread context).</p>




</article>
<article class="admonition-kernel-threads slide level-2">

<h2>Kernel threads</h2>

<p>Sometimes the kernel core or device drivers need to perform blocking
operations and thus they need to run in process context.</p>
<p>Kernel threads are used exactly for this and are a special class of
tasks that don't &quot;userspace&quot; resources (e.g. no address space or
opened files).</p>




</article>
<article class="admonition-inspecting-kernel-threads slide level-2">

<h2>Inspecting kernel threads</h2>

<p>&nbsp;</p>
<asciinema-player src="../_images/kernel_threads.cast"></asciinema-player>



</article>
<article class="admonition-quiz-kernel-gdb-scripts slide level-2">

<h2>Quiz: Kernel gdb scripts</h2>

<p>What is the following change of the lx-ps script trying to
accomplish?</p>
<div class="highlight-diff"><div class="highlight"><pre><span></span><span class="gh">diff --git a/scripts/gdb/linux/tasks.py b/scripts/gdb/linux/tasks.py</span>
<span class="gh">index 17ec19e9b5bf..7e43c163832f 100644</span>
<span class="gd">--- a/scripts/gdb/linux/tasks.py</span>
<span class="gi">+++ b/scripts/gdb/linux/tasks.py</span>
<span class="gu">@@ -75,10 +75,13 @@ class LxPs(gdb.Command):</span>
     def invoke(self, arg, from_tty):
         gdb.write(&quot;{:&gt;10} {:&gt;12} {:&gt;7}\n&quot;.format(&quot;TASK&quot;, &quot;PID&quot;, &quot;COMM&quot;))
         for task in task_lists():
<span class="gd">-            gdb.write(&quot;{} {:^5} {}\n&quot;.format(</span>
<span class="gi">+            check = task[&quot;mm&quot;].format_string() == &quot;0x0&quot;</span>
<span class="gi">+            gdb.write(&quot;{} {:^5} {}{}{}\n&quot;.format(</span>
                 task.format_string().split()[0],
                 task[&quot;pid&quot;].format_string(),
<span class="gd">-                task[&quot;comm&quot;].string()))</span>
<span class="gi">+                &quot;[&quot; if check else &quot;&quot;,</span>
<span class="gi">+                task[&quot;comm&quot;].string(),</span>
<span class="gi">+                &quot;]&quot; if check else &quot;&quot;))</span>


 LxPs()
</pre></div>
</div>




</article>

</section>

<section id="slide_notes">

</section>

  </body>
</html>