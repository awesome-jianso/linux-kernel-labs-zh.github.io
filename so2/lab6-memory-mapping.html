<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta content="理解地址空间映射机制，了解与内存管理相关的重要结构" name="description" />
<meta content="mmap, struct page, struct vm_area_struct, struct vm_struct, remap_pfn_range, SetPageReserved, ClearPageReserved" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 06 - Memory Mapping &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="SO2 Lab 07 - Block Device Drivers" href="lab7-block-device-drivers.html" />
    <link rel="prev" title="SO2 Lab 05 - Deferred work" href="lab5-deferred-work.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 06 - Memory Mapping</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">实验目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-3">用于内存映射的结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#struct-page"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-vm-area-struct"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-mm-struct"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-4">设备驱动程序的内存映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-5">进一步阅读</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-6">练习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-7">1. 将连续的物理内存映射到用户空间</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-8">2. 将非连续的物理内存映射到用户空间</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-9">3. 在映射内存中进行读写操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#procfs">4. 在 procfs 中显示内存映射</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">体系结构层</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">虚拟化</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 06 - Memory Mapping</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab6-memory-mapping.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-06-memory-mapping">
<h1>SO2 Lab 06 - Memory Mapping<a class="headerlink" href="#so2-lab-06-memory-mapping" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-1">
<h2>实验目标<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>理解地址空间映射机制</li>
<li>了解与内存管理相关的重要结构</li>
</ul>
<p>关键词：</p>
<ul class="simple">
<li>地址空间</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_struct</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">remap_pfn_range</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">SetPageReserved()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">ClearPageReserved()</span></code></li>
</ul>
</div>
<div class="section" id="section-2">
<h2>概述<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<p>在 Linux 内核中，我们可以将内核地址空间映射到用户地址空间。这样可以消除将用户空间信息复制到内核空间或相反操作的开销。这可以通过设备驱动程序和用户空间设备接口 (<code class="file docutils literal"><span class="pre">/dev</span></code>) 来实现。</p>
<p>我们可以通过在设备驱动程序的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> 中实现 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 操作，并在用户空间中通过 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 系统调用来使用此功能。</p>
<p>虚拟内存管理的基本单位是页面。页面的大小通常为 4K，但在某些平台上可以达到 64K。虚拟内存技术会使用两种类型的地址：虚拟地址和物理地址。所有 CPU 访问（包括来自内核空间的访问）访问的都是虚拟地址，然后由 MMU 将虚拟地址转换为物理地址，转换过程依靠页表来完成。</p>
<p>物理内存页面由页面帧号（PFN）标识。PFN 可以通过将物理地址除以页面的大小（或通过将物理地址向右移动 PAGE_SHIFT 位）来轻松计算得到。</p>
<a class="reference internal image-reference" href="../_images/paging1.png"><img alt="../_images/paging1.png" src="../_images/paging1.png" style="width: 49%;" /></a>
<p>出于效率考量，虚拟地址空间被划分为用户空间和内核空间。出于同样的考量，内核空间包含一个内存映射区域，称为 <strong>lowmem（低内存）</strong>。lowmem 从最低物理地址（通常为 0）开始，以连续方式映射到物理内存。lowmem 映射的虚拟地址由 <code class="xref c c-macro docutils literal"><span class="pre">PAGE_OFFSET</span></code> 定义。</p>
<p>在 32 位系统上，不是所有可用内存都可以映射到 lowmem 中，因此内核空间中有一个单独的区域称为 <strong>highmem（高内存）</strong>，可用于映射任意物理内存。</p>
<p>由 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 分配的内存位于 lowmem 中，是物理连续的。由 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 分配的内存不是连续的，也不位于 lowmem 中（它在 highmem 中有一个专用区域）。</p>
<a class="reference internal image-reference" href="../_images/kernel-virtmem-map1.png"><img alt="../_images/kernel-virtmem-map1.png" src="../_images/kernel-virtmem-map1.png" style="width: 49%;" /></a>
</div>
<div class="section" id="section-3">
<h2>用于内存映射的结构<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h2>
<p>在讨论设备上的内存映射机制之前，我们将介绍 Linux 内存管理子系统使用的一些基本结构。其中一些基本结构包括：<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code>, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> 以及 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code>。</p>
<div class="section" id="struct-page">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code><a class="headerlink" href="#struct-page" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code> 用于嵌入系统中所有物理页面的信息。内核为系统中的每个页面，都配有一个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code> 结构。</p>
<p>有许多函数与此结构交互：</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">virt_to_page()</span></code> 返回与虚拟地址关联的页面</li>
<li><code class="xref c c-func docutils literal"><span class="pre">pfn_to_page()</span></code> 返回与页面帧号关联的页面</li>
<li><code class="xref c c-func docutils literal"><span class="pre">page_to_pfn()</span></code> 返回与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code> 关联的页面帧号</li>
<li><code class="xref c c-func docutils literal"><span class="pre">page_address()</span></code> 返回 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">page</span></code> 的虚拟地址；此函数只能用于 lowmem 中的页面</li>
<li><code class="xref c c-func docutils literal"><span class="pre">kmap()</span></code> 为任意物理页面（可以来自 highmem）在内核中创建映射，并返回虚拟地址，该虚拟地址可用于直接引用该页面</li>
</ul>
</div>
<div class="section" id="struct-vm-area-struct">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code><a class="headerlink" href="#struct-vm-area-struct" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> 保存连续虚拟内存区域的信息。可以通过检查进程的 <em>maps</em> 属性（通过 procfs）来查看进程的内存区域：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# cat /proc/1/maps
<span class="c1">#地址             权限  偏移     设备  inode      路径</span>
<span class="m">08048000</span>-08050000 r-xp <span class="m">00000000</span> fe:00 <span class="m">761</span>        /sbin/init.sysvinit
<span class="m">08050000</span>-08051000 r--p <span class="m">00007000</span> fe:00 <span class="m">761</span>        /sbin/init.sysvinit
<span class="m">08051000</span>-08052000 rw-p <span class="m">00008000</span> fe:00 <span class="m">761</span>        /sbin/init.sysvinit
092e1000-09302000 rw-p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>heap<span class="o">]</span>
4480c000-4482e000 r-xp <span class="m">00000000</span> fe:00 <span class="m">576</span>        /lib/ld-2.25.so
4482e000-4482f000 r--p <span class="m">00021000</span> fe:00 <span class="m">576</span>        /lib/ld-2.25.so
4482f000-44830000 rw-p <span class="m">00022000</span> fe:00 <span class="m">576</span>        /lib/ld-2.25.so
<span class="m">44832000</span>-449a9000 r-xp <span class="m">00000000</span> fe:00 <span class="m">581</span>        /lib/libc-2.25.so
449a9000-449ab000 r--p <span class="m">00176000</span> fe:00 <span class="m">581</span>        /lib/libc-2.25.so
449ab000-449ac000 rw-p <span class="m">00178000</span> fe:00 <span class="m">581</span>        /lib/libc-2.25.so
449ac000-449af000 rw-p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>
b7761000-b7763000 rw-p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>
b7763000-b7766000 r--p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>vvar<span class="o">]</span>
b7766000-b7767000 r-xp <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>vdso<span class="o">]</span>
bfa15000-bfa36000 rw-p <span class="m">00000000</span> <span class="m">00</span>:00 <span class="m">0</span>          <span class="o">[</span>stack<span class="o">]</span>
</pre></div>
</div>
<p>内存区域由起始地址、结束地址、长度和权限来描述。</p>
<p>每次从用户空间发出 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 调用时，系统都会创建一个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code>。一个驱动程序要想支持 <code class="xref c c-func docutils literal"><span class="pre">map()</span></code> 操作，必须完成并初始化与之关联的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code>。该结构的重要字段包括：</p>
<ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">vm_start</span></code> 以及 <code class="xref c c-member docutils literal"><span class="pre">vm_end</span></code> ——内存区域的起始和结束地址（这些字段也出现在 <code class="file docutils literal"><span class="pre">/proc/&lt;pid&gt;/maps</span></code> 中）；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">vm_file</span></code> ——关联 file 结构的指针（如果有的话）；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">vm_pgoff</span></code> ——区域在文件中的偏移量；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">vm_flags</span></code> ——一组标志；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">vm_ops</span></code> ——该区域的工作函数集合；</li>
<li><code class="xref c c-member docutils literal"><span class="pre">vm_next</span></code> 以及 <code class="xref c c-member docutils literal"><span class="pre">vm_prev</span></code> ——同一进程的区域通过链表结构连接起来。</li>
</ul>
</div>
<div class="section" id="struct-mm-struct">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code><a class="headerlink" href="#struct-mm-struct" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code> 包含与进程关联的所有内存区域。<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的 <code class="xref c c-member docutils literal"><span class="pre">mm</span></code> 字段是一个指针，指向当前进程的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code>。</p>
</div>
</div>
<div class="section" id="section-4">
<h2>设备驱动程序的内存映射<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h2>
<p>内存映射是 Unix 系统中最有趣的功能之一。从驱动程序的角度来看，内存映射机制允许直接访问用户空间设备的内存。</p>
<p>要将 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 操作分配给驱动程序，必须实现设备驱动程序的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> 的 <code class="xref c c-member docutils literal"><span class="pre">mmap</span></code> 字段。如果这样做了，用户空间进程可以对与设备关联的文件描述符使用 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 系统调用。</p>
<p>mmap 系统调用有以下参数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="o">*</span><span class="nf">mmap</span><span class="p">(</span><span class="n">caddr_t</span> <span class="n">addr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span>
           <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<p>要在设备和用户空间之间映射内存，用户进程必须对设备执行 open 操作，并使用得到的文件描述符发出 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 系统调用。</p>
<p>设备驱动程序的 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 操作具有以下签名：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">);</span>
</pre></div>
</div>
<p><em>filp</em> 字段是一个指针，指向在用户空间打开设备时创建的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code>。 <em>vma</em> 字段用于指示设备应该将内存映射到哪一个虚拟地址空间。驱动程序应该分配内存 (使用 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 或者 <code class="xref c c-func docutils literal"><span class="pre">alloc_pages()</span></code>), 然后使用辅助函数（如:c:func:<cite>remap_pfn_range</cite>）根据 <em>vma</em> 参数将其映射到用户地址空间。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code> 将连续的物理地址空间映射到由 <code class="xref c c-type docutils literal"><span class="pre">vm_area_struct</span></code> 表示的虚拟空间：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">remap_pfn_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code> 需要以下参数：</p>
<ul class="simple">
<li><em>vma</em> ——进行映射的虚拟内存空间；</li>
<li><em>addr</em> ——重新映射开始的虚拟地址空间；将根据需要形成 addr 和 addr + size 之间的虚拟地址空间的页表</li>
<li><em>pfn</em> ——虚拟地址应映射到的页帧号</li>
<li><em>size</em> ——要映射的内存的大小（以字节为单位）</li>
<li><em>prot</em> ——此映射的保护标志</li>
</ul>
<p>以下是使用该函数的示例，该示例将从页帧号 <em>pfn*（先前分配的内存）开始的物理内存连续映射到 *vma-&gt;vm_start</em> 虚拟地址：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="p">;</span>

<span class="n">ret</span> <span class="o">=</span> <span class="n">remap_pfn_range</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">,</span> <span class="n">pfn</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_page_prot</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;could not map the address area</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>要获得物理内存的页帧号，我们必须考虑内存分配是如何进行的。对于 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 或者 <code class="xref c c-func docutils literal"><span class="pre">alloc_pages()</span></code>, 我们必须使用不同的方法。对于 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code>，我们可以使用类似以下的方法：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">kmalloc_area</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">kmalloc_area</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="n">PAGE_SHIFT</span><span class="p">;</span>
</pre></div>
</div>
<p>而对于 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">vmalloc_area</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">vmalloc_to_pfn</span><span class="p">(</span><span class="n">vmalloc_area</span><span class="p">);</span>
</pre></div>
</div>
<p>最后对于 <code class="xref c c-func docutils literal"><span class="pre">alloc_pages()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pfn</span> <span class="o">=</span> <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">请注意，使用 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 分配的内存在物理上不连续，因此如果我们想要映射使用 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 分配的范围，我们必须逐个映射每个页面，并计算每个页面的物理地址。</p>
</div>
<p>由于这些页面被映射到的是用户空间，它们可能会被交换出去。为了避免这种情况，我们必须在页面上设置 PG_reserved 位。我们可以使用 <code class="xref c c-func docutils literal"><span class="pre">SetPageReserved()</span></code> 来启用它，也可以使用 <code class="xref c c-func docutils literal"><span class="pre">ClearPageReserved()</span></code> 来重置它（在释放内存之前必须执行此操作）：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">alloc_mmap_pages</span><span class="p">(</span><span class="kt">int</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">*</span> <span class="n">npages</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mem</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
        <span class="n">SetPageReserved</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">mem</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_mmap_pages</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
        <span class="n">ClearPageReserved</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">mem</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>

    <span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h2>进一步阅读<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://lwn.net/images/pdf/LDD3/ch15.pdf">Linux 设备驱动程序第 3 版——第 15 章 内存映射和 DMA</a></li>
<li><a class="reference external" href="http://www.xml.com/ldd/chapter/book/ch13.html">Linux 设备驱动程序 mmap 骨架</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/28746/">驱动程序移植：支持 mmap ()</a></li>
<li><a class="reference external" href="http://www.linuxjournal.com/article/1287">设备驱动程序结束</a></li>
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Mmap">mmap</a></li>
</ul>
</div>
<div class="section" id="section-6">
<h2>练习<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 内存映射。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/内存映射/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-6">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-7">
<h3>1. 将连续的物理内存映射到用户空间<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h3>
<p>实现一个设备驱动程序，将连续的物理内存（例如通过 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 获得的内存）映射到用户空间。</p>
<p>查看 <a class="reference internal" href="#section-4">设备驱动程序的内存映射</a> 部分，生成名为 <strong>kmmap</strong> 的任务的框架，并填写标有 <strong>TODO 1</strong> 的区域。</p>
<p>在模块初始化函数中，首先使用 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 分配一个 NPAGES+2 个页面的内存区域，并找到该区域中对齐到页边界的第一个地址。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>一个页面的大小为 <em>PAGE_SIZE</em>。</p>
<p>将分配的区域存储在 <em>kmalloc_ptr</em> 中，将对齐的地址存储在 <em>kmalloc_area</em> 中：</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">PAGE_ALIGN()</span></code> 函数来确定 <em>kmalloc_area</em>。</p>
</div>
<p>使用 <code class="xref c c-func docutils literal"><span class="pre">SetPageReserved()</span></code> 将每个页面的 PG_reserved 位设置为启用状态。在释放内存之前，使用 <code class="xref c c-func docutils literal"><span class="pre">ClearPageReserved()</span></code> 清除该位。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">virt_to_page()</span></code> 将虚拟页转换为物理页, <code class="xref c c-func docutils literal"><span class="pre">SetPageReserved()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">ClearPageReserved()</span></code> 所需的是物理页面。</p>
</div>
<p>为了验证目的（使用下面的测试），在每个页面的前 4 个字节中填入以下值：0xaa、0xbb、0xcc 以及 0xdd。</p>
<p>实现 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 驱动程序函数。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>要想映射，使用 <code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code>。<code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code> 的第三个参数是页帧号（PFN）。</p>
<p>要从虚拟内核地址转换为物理地址，请使用 <code class="xref c c-func docutils literal"><span class="pre">virt_to_phys()</span></code>。</p>
<p class="last">要将物理地址转换为其 PFN，请将地址右移 PAGE_SHIFT 位。</p>
</div>
<p>用于测试的方法是，加载内核模块并运行：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# skels/memory_mapping/test/mmap-test <span class="m">1</span>
</pre></div>
</div>
<p>如果一切顺利，测试将显示“matched”消息。</p>
</div>
<div class="section" id="section-8">
<h3>2. 将非连续的物理内存映射到用户空间<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p>实现一个设备驱动程序，将非连续的物理内存（例如通过 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 获得的内存）映射到用户空间。</p>
<p>查看 <a class="reference internal" href="#section-4">设备驱动程序的内存映射</a> 部分，生成名为 <strong>vmmap</strong> 的任务的框架，并填写标有 <strong>TODO 1</strong> 的区域。</p>
<p>使用 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 分配一个 NPAGES 大小的内存区域。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">一个页面的大小为 <em>PAGE_SIZE</em>。将分配的区域存储在 <em>vmalloc_area</em> 中。由 <code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 分配的内存是按页对齐的。</p>
</div>
<p>使用 <code class="xref c c-func docutils literal"><span class="pre">SetPageReserved()</span></code> 将每个页面的 PG_reserved 位设置为启用状态。在释放内存之前，使用 <code class="xref c c-func docutils literal"><span class="pre">ClearPageReserved()</span></code> 清除该位。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">vmalloc_to_page()</span></code> 将虚拟页转换为物理页，以供 <code class="xref c c-func docutils literal"><span class="pre">SetPageReserved()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">ClearPageReserved()</span></code> 函数使用。</p>
</div>
<p>为了验证目的（使用下面的测试），在每个页面的前 4 个字节中填入以下值：0xaa、0xbb、0xcc 以及 0xdd。</p>
<p>实现 mmap 驱动程序函数。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">要将虚拟 vmalloc 地址转换为物理地址，使用 <code class="xref c c-func docutils literal"><span class="pre">vmalloc_to_pfn()</span></code> 直接返回 PFN。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>vmalloc 页面不是物理连续的，因此需要为每个页面单独使用 <code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code>。</p>
<p>遍历所有虚拟页面，并对于每个页面:
* 确定物理地址
* 使用 <code class="xref c c-func docutils literal"><span class="pre">remap_pfn_range()</span></code> 进行映射</p>
<p class="last">确保每次都确定物理地址，并且只映射一个页面。</p>
</div>
<p>测试的方法是，加载内核模块并运行：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# skels/memory_mapping/test/mmap-test <span class="m">1</span>
</pre></div>
</div>
<p>如果一切顺利，测试将显示“matched”消息。</p>
</div>
<div class="section" id="section-9">
<h3>3. 在映射内存中进行读写操作<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h3>
<p>修改之前的模块之一，以允许在设备上进行读写操作。这是一个教学练习，可以看到相同的空间既可以使用 <code class="xref c c-func docutils literal"><span class="pre">mmap()</span></code> 调用，也可以使用 <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">write()</span></code> 调用。</p>
<p>填写标有 <strong>TODO 2</strong> 的区域。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">读/写操作的偏移参数可以忽略，因为测试程序中的所有读/写操作偏移都是 0。</p>
</div>
<p>用于测试的方法是，加载内核模块并运行：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# skels/memory_mapping/test/mmap-test <span class="m">2</span>
</pre></div>
</div>
</div>
<div class="section" id="procfs">
<h3>4. 在 procfs 中显示内存映射<a class="headerlink" href="#procfs" title="永久链接至标题">¶</a></h3>
<p>使用之前的模块之一，在其中创建一个 procfs 文件，显示调用进程映射的总内存。</p>
<p>填写标有 <strong>TODO 3</strong> 的区域。</p>
<p>在 procfs 中创建一个新条目 (<code class="xref c c-macro docutils literal"><span class="pre">PROC_ENTRY_NAME</span></code>, 在 <code class="file docutils literal"><span class="pre">mmap-test.h</span></code> 中定义)，该条目将显示调用 <code class="xref c c-func docutils literal"><span class="pre">read()</span></code> 的进程映射的总内存。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">proc_create()</span></code>。mode 参数使用 0，parent 参数使用 NULL。使用 <code class="xref c c-func docutils literal"><span class="pre">my_proc_file_ops()</span></code> 进行操作。</p>
</div>
<p>在模块退出函数中，使用 <code class="xref c c-func docutils literal"><span class="pre">remove_proc_entry()</span></code> 删除 <code class="xref c c-macro docutils literal"><span class="pre">PROC_ENTRY_NAME</span></code> 条目。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>可以在此 <a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x861.html">示例</a> 中找到 (复杂的) <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">seq_file</span></code> 接口的使用和说明。</p>
<p class="last">对于这个练习，只需使用 <a class="reference external" href="http://lwn.net/Articles/22355/">这里</a> 描述的接口的简单用法即可。请查看那里描述的“extra-simple” API。</p>
</div>
<p>在 <code class="xref c c-func docutils literal"><span class="pre">my_seq_show()</span></code> 函数中，你需要：</p>
<ul>
<li><p class="first">使用 <code class="xref c c-func docutils literal"><span class="pre">get_task_mm()</span></code> 函数获取当前进程的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code> 结构。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">当前进程可以通过类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct*</span></code> 的 <em>current</em> 变量获得。</p>
</div>
</li>
<li><p class="first">遍历与进程关联的整个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> 列表。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用变量 <code class="xref c c-data docutils literal"><span class="pre">vma_iterator</span></code>，从 <code class="xref c c-data docutils literal"><span class="pre">mm-&gt;mmap</span></code> 开始。使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> 的 <code class="xref c c-member docutils literal"><span class="pre">vm_next</span></code> 字段在内存区域列表中导航。直到达到 <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code> 时停止。</p>
</div>
</li>
<li><p class="first">对于每个区域，使用 <em>vm_start</em> 和 <em>vm_end</em> 计算总大小。</p>
</li>
<li><p class="first">使用 <code class="xref c c-func docutils literal"><span class="pre">pr_info(&quot;%lx</span> <span class="pre">%lxn,</span> <span class="pre">...)()</span></code> 为每个区域打印 <em>vm_start</em> 和 <em>vm_end</em>。</p>
</li>
<li><p class="first">要释放 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code>，请使用 <code class="xref c c-func docutils literal"><span class="pre">mmput()</span></code> 递减结构的引用计数器。</p>
</li>
<li><p class="first">使用 <code class="xref c c-func docutils literal"><span class="pre">seq_printf()</span></code> 写入文件。仅显示总计数，不显示其他消息。甚至不要显示换行符（n）。</p>
</li>
</ul>
<p>在 <code class="xref c c-func docutils literal"><span class="pre">my_seq_open()</span></code> 中，使用 <code class="xref c c-func docutils literal"><span class="pre">single_open()</span></code> 注册显示函数 (<code class="xref c c-func docutils literal"><span class="pre">my_seq_show()</span></code>)。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last"><code class="xref c c-func docutils literal"><span class="pre">single_open()</span></code> 可以使用 NULL 作为其第三个参数。</p>
</div>
<p>测试的方法是，加载内核模块并运行：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# skels/memory_mapping/test/mmap-test <span class="m">3</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">测试会等待一段时间（其中包含一个 sleep 指令）。只要测试在等待，就可以在另一个控制台中使用 :pmap 命令查看测试的映射，并将其与测试结果进行比较。</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab5-deferred-work.html" class="btn btn-neutral float-left" title="SO2 Lab 05 - Deferred work" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab7-block-device-drivers.html" class="btn btn-neutral float-right" title="SO2 Lab 07 - Block Device Drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>