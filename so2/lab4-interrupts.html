<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 04 - I/O access and Interrupts &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 05 - Deferred work" href="lab5-deferred-work.html" />
    <link rel="prev" title="SO2 Lab 03 - Character device drivers" href="lab3-device-drivers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 04 - I/O access and Interrupts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">实验目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">背景信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-3">访问硬件</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#i-o">请求访问 I/O 端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-1">访问 I/O 端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-2">5. 从用户空间访问 I/O 端口</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-4">中断处理</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-5">请求中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-6">中断处理程序的实现</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-7">锁定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-8">中断统计</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-9">进一步阅读</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-10">串口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-11">并行端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-12">键盘控制器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux">Linux设备驱动程序</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">练习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-14">0. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-15">键盘驱动程序</a></li>
<li class="toctree-l4"><a class="reference internal" href="#i-o-3">1. 请求 I/O 端口</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-16">2. 中断处理例程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ascii">3. 将 ASCII 键存储到缓冲区</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-20">4. 读取缓冲区</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-21">5. 重置缓冲区</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-22">额外练习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kfifo">1. kfifo</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 04 - I/O access and Interrupts</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab4-interrupts.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-04-i-o-access-and-interrupts">
<h1>SO2 Lab 04 - I/O access and Interrupts<a class="headerlink" href="#so2-lab-04-i-o-access-and-interrupts" title="Permalink to this headline">¶</a></h1>
<div class="section" id="section-1">
<h2>实验目标<a class="headerlink" href="#section-1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>与外围设备进行通信</li>
<li>实现中断处理程序</li>
<li>将中断与进程上下文同步</li>
</ul>
<p>关键词：IRQ，I/O 端口，I/O 地址，基地址，UART，request_region，release_region，inb，outb</p>
</div>
<div class="section" id="section-2">
<h2>背景信息<a class="headerlink" href="#section-2" title="Permalink to this headline">¶</a></h2>
<p>外围设备通过写入和读取其寄存器来进行控制。通常，设备具有多个寄存器，这些寄存器可以在内存地址空间或 I/O 地址空间的连续地址中访问。连接到 I/O 总线的每个设备都有一组 I/O 地址，称为 I/O 端口。I/O 端口可以映射到物理内存地址，以便处理器可以通过直接与内存交互的指令与设备进行通信。为了简化，我们将直接使用 I/O 端口（而不映射到物理内存地址）与物理设备进行通信。</p>
<p>每个设备的 I/O 端口是由一组专用寄存器构成的，以提供统一的编程接口。因此，大多数设备都具有以下类型的寄存器：</p>
<ul class="simple">
<li><strong>控制寄存器</strong>：接收设备命令</li>
<li><strong>状态寄存器</strong>：包含有关设备内部状态的信息</li>
<li><strong>输入寄存器</strong>：从中读取设备的数据</li>
<li><strong>输出寄存器</strong>：将数据写入其中以传输到设备</li>
</ul>
<p>物理端口根据位数进行区分：它们可以是 8 位、16 位或 32 位端口。</p>
<p>例如，并行端口具有从基地址 0x378 开始的 8 个 8 位 I/O 端口。数据日志位于基地址（0x378），状态寄存器位于基地址 + 1（0x379），控制寄存器位于基地址 + 2（0x37a）。数据日志既是输入日志也是输出日志。</p>
<p>虽然有些设备可以完全仅通过 I/O 端口或特殊内存区域进行控制，但在某些情况下，这是不够的。需要解决的主要问题是某些事件发生的时刻无法预期，对此如果处理器（CPU）反复查询设备的状态（轮询）的话，是很低效的。解决这个问题的方法是使用中断请求（IRQ），它是一种硬件通知，用于通知处理器发生了特定的外部事件。</p>
<p>为了使 IRQ 有用，设备驱动程序必须实现处理程序，即处理中断的特定代码序列。由于在许多情况下可用的中断数有限，设备驱动程序必须按顺序处理中断：在使用中断之前必须请求中断，在不再需要时必须释放中断。此外，在某些情况下，设备驱动程序必须共享中断或与中断同步。所有这些将进一步讨论。</p>
<p>当我们需要访问中断例程（A）和进程上下文或下半部分上下文（bottom-half context）（B）中运行的代码之间的共享资源时，我们必须使用特殊的同步技术。在（A）中，我们需要使用自旋锁原语，在（B）中必须禁用中断并使用自旋锁原语。仅禁用中断是不够的，因为中断例程可以在运行（B）的处理器之外的处理器上运行。</p>
<p>仅使用自旋锁可能会导致死锁。在这种情况下的典型死锁示例是：</p>
<ol class="arabic simple">
<li>在 X 处理器上运行一个进程，并获取锁</li>
<li>在释放锁之前，在 X 处理器上发生中断</li>
<li>中断处理程序将尝试获取锁，并进入死循环</li>
</ol>
</div>
<div class="section" id="section-3">
<h2>访问硬件<a class="headerlink" href="#section-3" title="Permalink to this headline">¶</a></h2>
<p>在 Linux 中，I/O 端口的访问在所有体系结构上都有实现，并且有几个可以使用的 API。</p>
<div class="section" id="i-o">
<h3>请求访问 I/O 端口<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
<p>在访问 I/O 端口之前，我们首先必须请求访问权限，这是为了确保只同时有一个用户使用。为了做到这一点，我们必须使用 <code class="xref c c-func docutils literal"><span class="pre">request_region()</span></code> 函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/ioport.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="nf">request_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>要释放一个已经持有的区域，可以使用 <code class="xref c c-func docutils literal"><span class="pre">release_region()</span></code> 函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">release_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>例如，串口 COM1 的基地址是 0x3F8，它有 8 个端口，以下是请求访问这些端口的代码片段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/ioport.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BASEPORT 0x3F8</span>
<span class="cp">#define MY_NR_PORTS 8</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="n">MY_NR_PORTS</span><span class="p">,</span> <span class="s">&quot;com1&quot;</span><span class="p">))</span> <span class="p">{</span>
     <span class="cm">/* 处理错误 */</span>
     <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>要释放端口，可以使用以下代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">release_region</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="n">MY_NR_PORTS</span><span class="p">);</span>
</pre></div>
</div>
<p>大多数情况下，端口请求是在驱动程序初始化或探测时进行的，端口释放是在设备或模块移除时进行的。</p>
<p>所有的端口请求可以在用户空间通过 <code class="file docutils literal"><span class="pre">/proc/ioports</span></code> 文件查看：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ cat /proc/ioports
<span class="m">0000</span>-001f : dma1
<span class="m">0020</span>-0021 : pic1
<span class="m">0040</span>-005f : timer
<span class="m">0060</span>-006f : keyboard
<span class="m">0070</span>-0077 : rtc
<span class="m">0080</span>-008f : dma page reg
00a0-00a1 : pic2
00c0-00df : dma2
00f0-00ff : fpu
<span class="m">0170</span>-0177 : ide1
01f0-01f7 : ide0
<span class="m">0376</span>-0376 : ide1
<span class="m">0378</span>-037a : parport0
037b-037f : parport0
03c0-03df : vga+
03f6-03f6 : ide0
03f8-03ff : serial
...
</pre></div>
</div>
</div>
<div class="section" id="i-o-1">
<h3>访问 I/O 端口<a class="headerlink" href="#i-o-1" title="Permalink to this headline">¶</a></h3>
<p>在驱动程序获取所需的 I/O 端口范围之后，可以对这些端口进行读取或写入操作。由于物理端口根据位数（8 位、16 位或 32 位）进行区分，因此根据其大小有不同的端口访问函数。在 asm/io.h 中定义了以下端口访问函数：</p>
<ul class="simple">
<li><em>unsigned inb(int port)</em>，从端口读取一个字节（8 位）</li>
<li><em>void outb(unsigned char byte, int port)</em>，向端口写入一个字节（8 位）</li>
<li><em>unsigned inw(int port)</em>，从端口读取两个字节（16 位）</li>
<li><em>void outw(unsigned short word, int port)</em>，向端口写入两个字节（16 位）</li>
<li><em>unsigned inl (int port)</em>，从端口读取四个字节（32 位）</li>
<li><em>void outl(unsigned long word, int port)</em>，向端口写入四个字节（32 位）</li>
</ul>
<p>端口参数指定进行读取或写入的端口地址，其类型取决于平台（可以是 unsigned long 或 unsigned short）。</p>
<p>如果处理器过快地传输数据到设备或从设备读取数据的话，某些设备可能会出现问题。为了避免这个问题，我们可能需要在 I/O 操作之后插入延迟。可以使用引入延迟的函数来实现这一点。它们的名称与上述函数类似，不同之处在于以 _p 结尾：inb_p、outb_p 等。</p>
<p>例如，以下序列在 COM1 串口上写入一个字节，然后读取它：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/io.h&gt;</span><span class="cp"></span>
<span class="cp">#define MY_BASEPORT 0x3F8</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
<span class="n">outb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">MY_BASEPORT</span><span class="p">);</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="i-o-2">
<h3>5. 从用户空间访问 I/O 端口<a class="headerlink" href="#i-o-2" title="Permalink to this headline">¶</a></h3>
<p>虽然上述描述的函数是为设备驱动程序定义的，但也可以通过包含 &lt;sys/io.h&gt; 头文件在用户空间中使用。为了使用它们，首先必须调用 ioperm 或 iopl 以获得执行端口操作的权限。ioperm 函数获取单个端口的权限，而 iopl 获取整个 I/O 地址空间的权限。要使用这些功能，用户必须具有 root 权限。</p>
<p>以下是在用户空间中使用的代码，用于获取串口的前 3 个端口的权限，然后释放它们：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/io.h&gt;</span><span class="cp"></span>
<span class="cp">#define MY_BASEPORT 0x3F8</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ioperm</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
     <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ioperm</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
     <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ioperm 函数的第三个参数用于请求或释放端口权限：1 表示获取权限，0 表示释放权限。</p>
</div>
</div>
<div class="section" id="section-4">
<h2>中断处理<a class="headerlink" href="#section-4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="section-5">
<h3>请求中断<a class="headerlink" href="#section-5" title="Permalink to this headline">¶</a></h3>
<p>与其他资源一样，驱动程序在使用中断线之前必须获得对其的访问权限，并在执行结束时释放它。</p>
<p>在 Linux 中，使用 <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code> 函数来请求和释放中断：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/interrupt.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="nf">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_handler_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">free_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
</pre></div>
</div>
<p>请注意，要获取中断，开发者需调用 <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> 。调用此函数时，必须指定中断号 (<em>irq_no</em>)，在生成中断时调用的处理程序 (<em>handler</em>)，指示内核所需行为的标志 (<em>flags</em>)，使用此中断的设备的名称 (<em>dev_name</em>)，以及可以由用户配置成任何值的指针，并且没有全局意义 (<em>dev_id</em>)。大多数情况下, <em>dev_id</em> 是指向设备驱动程序的私有数据的指针。当使用 <code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code> 函数释放中断时，开发人员必须发送相同的指针值 (<em>dev_id</em>) 以及相同的中断号 (<em>irq_no</em>)。设备名称 (<em>dev_name</em>) 用于在 <em>/proc/interrupts</em> 中显示统计信息。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> 返回的值为 0 表示成功，或者为负数错误代码，表示失败的原因。一个典型的值是 <em>-EBUSY</em>，表示中断已经被另一个设备驱动程序请求。</p>
<p><em>handler</em> 函数在中断上下文中执行，这意味着我们不能调用阻塞的 API，如 <code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code> 或 <code class="xref c c-func docutils literal"><span class="pre">msleep()</span></code>。我们还必须避免在中断处理程序中执行大量工作，最好使用延迟工作。在中断处理程序中执行的操作包括读取设备寄存器以获取设备的状态并确认中断，这些操作大多数情况下可以使用非阻塞调用来执行。</p>
<p>有时候，即使设备使用中断，我们也无法以非阻塞模式读取设备的寄存器（例如连接到 I2C 或 SPI 总线的传感器，其驱动程序不能保证总线读/写操作是非阻塞的）。在这种情况下，我们必须在中断中规划一个正在进行的工作（工作队列、内核线程）来访问设备的寄存器。由于这种情况相对常见，内核提供了 <code class="xref c c-func docutils literal"><span class="pre">request_threaded_irq()</span></code> 函数来编写以两个阶段运行的中断处理程序：一个是进程阶段，另一个是中断上下文阶段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/interrupt.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">request_threaded_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
                         <span class="n">irq_handler_t</span> <span class="n">thread_fn</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<p><em>handler</em> 函数在中断上下文中运行，并实现关键操作，而 thread_fn 函数在进程上下文中运行，并实现其余操作。</p>
<p>当进行中断请求时，可以传递的标志如下：</p>
<ul class="simple">
<li><em>IRQF_SHARED</em> 通知内核该中断可以与其他设备共享。如果未设置此标志，并且请求的中断已经与其他处理程序关联，则中断请求将失败。内核以特殊方式处理共享中断：所有关联的中断处理程序将被执行，直到识别出生成中断的设备。但是，设备驱动程序如何知道中断处理例程是否是由其管理的设备生成的中断激活的呢？几乎所有支持中断的设备都有一个状态寄存器，可以在处理例程中查询该寄存器，以查看中断是否由设备生成（例如，在 8250 串口的情况下，该状态寄存器是 IIR（中断信息寄存器））。当请求共享中断时，dev_id 参数必须是唯一的，且不能为 NULL。通常将其设置为模块的私有数据。</li>
<li><em>IRQF_ONESHOT</em> 在进程上下文例程运行完成后，中断将重新激活；如果没有设置此标志，则中断将在中断上下文中的处理程序运行完成后重新激活。</li>
</ul>
<p>可以在驱动程序的初始化（<code class="xref c c-func docutils literal"><span class="pre">init_module()</span></code>）时、设备探测时或设备使用时（例如设备打开时）执行中断请求。</p>
<p>以下示例执行了 COM1 串口的中断请求：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/interrupt.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BASEPORT 0x3F8</span>
<span class="cp">#define MY_IRQ 4</span>

<span class="k">static</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="p">[...]</span>
     <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

     <span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">MY_IRQ</span><span class="p">,</span> <span class="n">my_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
                       <span class="s">&quot;com1&quot;</span><span class="p">,</span> <span class="n">my_data</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="cm">/* 处理错误 */</span>
         <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如你所见，串口 COM1 的中断号是 4，在共享模式（IRQF_SHARED）下使用。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">在请求共享中断（IRQF_SHARED）时，<em>dev_id</em> 参数不能为空。</p>
</div>
<p>要释放与串口关联的中断，需要执行以下操作：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">free_irq</span> <span class="p">(</span><span class="n">MY_IRQ</span><span class="p">,</span> <span class="n">my_data</span><span class="p">);</span>
</pre></div>
</div>
<p>在初始化函数（<code class="xref c c-func docutils literal"><span class="pre">init_module()</span></code>）或打开设备的函数中，必须激活设备的中断。具体操作取决于设备，但通常涉及设置控制寄存器的某个位。</p>
<p>以 8250 串口为例，要启用中断，必须执行以下操作：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/io.h&gt;</span><span class="cp"></span>
<span class="cp">#define MY_BASEPORT 0x3F8</span>

<span class="n">outb</span><span class="p">(</span><span class="mh">0x08</span><span class="p">,</span> <span class="n">MY_BASEPORT</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">MY_BASEPORT</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>在上面的示例中，执行了两个操作：</p>
<ol class="arabic simple">
<li>通过设置 MCR 寄存器（调制解调控制寄存器）中的位 3（Aux Output 2），激活所有中断。</li>
<li>通过在 IER 寄存器（中断使能寄存器）中设置适当的位，激活 RDAI（传输保持寄存器空中断）。</li>
</ol>
</div>
<div class="section" id="section-6">
<h3>中断处理程序的实现<a class="headerlink" href="#section-6" title="Permalink to this headline">¶</a></h3>
<p>让我们来看一下中断处理程序函数的签名：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
</pre></div>
</div>
<p>该函数接收中断号 (<em>irq_no</em>) 和在请求中断时传递给 <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> 函数的指针作为参数。中断处理例程必须返回具有 <code class="xref c c-type docutils literal"><span class="pre">typedef</span> <span class="pre">irqreturn_t</span></code> 类型的值。对于当前的内核版本，中断处理函数可以返回三种不同的值: <em>IRQ_NONE</em>, <em>IRQ_HANDLED</em> 或 <em>IRQ_WAKE_THREAD</em>。如果中断处理函数发现中断并不是由它所负责的设备触发的，它应该返回 <em>IRQ_NONE</em> 表示没有处理中断。如果中断处理函数能够在中断上下文中完成对中断的处理，它应该返回 <em>IRQ_HANDLED</em> 表示已经处理了中断。如果中断处理函数需要在进程上下文中继续处理中断，它应该返回 <em>IRQ_WAKE_THREAD</em> 表示需要调度执行进程上下文处理函数。</p>
<p>中断处理程序的基本框架如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">irqreturn_t</span> <span class="nf">my_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>

   <span class="cm">/* 如果中断不是针对该设备的（共享中断） */</span>
   <span class="cm">/* 返回 IRQ_NONE; */</span>

   <span class="cm">/* 清除中断挂起位 */</span>
   <span class="cm">/* 从设备读取或向设备写入数据 */</span>

    <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通常，在中断处理程序中首先执行的操作，是确定中断是否由驱动程序所控制的设备触发的。这通常通过从设备的寄存器中读取信息来判断设备是否触发中断。其次，需要重置物理设备上的中断挂起位（interrupt pending bit），因为大多数设备在该位重置之前不会再触发中断（例如，对于 8250 串口，必须清除 IIR 寄存器中的第 0 位）。</p>
</div>
<div class="section" id="section-7">
<h3>锁定<a class="headerlink" href="#section-7" title="Permalink to this headline">¶</a></h3>
<p>因为中断处理程序在中断上下文中运行，所以可以执行的操作很有限：无法访问用户空间内存，不能调用阻塞函数。此外，使用自旋锁进行同步是很棘手的事，如果某个进程获取了自旋锁，之后被运行处理程序中断，则可能导致死锁。</p>
<p>然而，设备驱动程序在某些情况下必须使用中断进行同步，例如当数据在中断处理程序和进程上下文或底半部处理程序之间共享时。在这些情况下，需要同时禁用中断和使用自旋锁。</p>
<p>有两种禁用中断的方法：在处理器级别禁用所有中断，或在设备或中断控制器级别禁用特定中断。处理器禁用更快，因此更受推荐。为此，有一些锁定函数可以在同时获取和释放自旋锁的同时禁用和启用中断: <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irq()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">spin_lock_irqsave</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">spin_unlock_irqrestore</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">spin_lock_irq</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">spin_unlock_irq</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> 函数在获取自旋锁之前禁用本地处理器上的中断；中断的先前状态保存在 <em>flags</em> 中。</p>
<p>如果你绝对确定当前处理器上的中断尚未被其他人禁用，并且确定在释放自旋锁时可以激活中断，可以使用 <a href="#system-message-1"><span class="problematic" id="problematic-1">:c:`spin_lock_irq`</span></a>。</p>
<p>对于读/写自旋锁，也有类似的函数可用：</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">read_lock_irqsave()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">read_unlock_irqrestore()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">read_lock_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">read_unlock_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_lock_irqsave()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_unlock_irqrestore()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_lock_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_unlock_irq()</span></code></li>
</ul>
<p>如果我们想在中断控制器级别禁用中断（不推荐，因为禁用特定中断会更慢，而且无法禁用共享中断），可以使用 <code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">disable_irq_nosync()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">enable_irq()</span></code>。使用这些函数将禁用所有处理器上的中断。调用可以嵌套：如果调用了两次 disable_irq，则需要调用相同次数的 enable_irq 才能启用中断。disable_irq 和 disable_irq_nosync 之间的区别在于前者将等待执行中的处理程序完成。因此, <code class="xref c c-func docutils literal"><span class="pre">disable_irq_nosync()</span></code> 通常更快，但可能与中断处理程序竞争，因此如果不确定请使用 <code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code>。</p>
<p>以下代码禁用然后启用 COM1 串口的中断：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define MY_IRQ 4</span>

<span class="n">disable_irq</span> <span class="p">(</span><span class="n">MY_IRQ</span><span class="p">);</span>
<span class="n">enable_irq</span> <span class="p">(</span><span class="n">MY_IRQ</span><span class="p">);</span>
</pre></div>
</div>
<p>也可以在设备级别上禁用中断。这种方法同样比在处理器级别上禁用中断更慢，但它适用于共享中断。实现这个的方式因设备而异，通常需要从控制寄存器中清除一个位。</p>
<p>也可以独立于锁定操作，在当前处理器上禁用所有中断。出于同步目的而由设备驱动程序禁用所有中断是不合适的，因为如果中断在另一个 CPU 上处理，仍然可能出现竞态条件。用于在本地处理器上禁用/启用中断的函数是 <code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">local_irq_enable()</span></code>。</p>
<p>为了使用在进程上下文和中断处理例程之间共享的资源，可以按照以下方式使用上述函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

<span class="cm">/* IRQ 处理例程：中断上下文 */</span>
<span class="n">irqreturn_t</span> <span class="nf">kbd_interrupt_handle</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="cm">/* 临界区——访问共享资源 */</span>
    <span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* 进程上下文：在锁定时禁用中断 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_access</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* 临界区——访问共享资源 */</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">spin_lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面的 <em>my_access</em> 函数在进程上下文中运行。为了同步对共享数据的访问，我们禁用中断并使用自旋锁 <em>lock</em>，即 <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> 函数。</p>
<p>在中断处理例程中，我们使用 <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> 函数来访问共享资源。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> 的 <em>flags</em> 参数是一个值而不是指针，但请记住 <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> 函数会更改标志的值，因为这实际上是一个宏。</p>
</div>
</div>
<div class="section" id="section-8">
<h3>中断统计<a class="headerlink" href="#section-8" title="Permalink to this headline">¶</a></h3>
<p>关于系统中断的信息和统计数据可以在 <em>/proc/interrupts</em> 或 <em>/proc/stat</em> 中找到。只有具有关联中断处理程序的系统中断才会显示在 <em>/proc/interrupts</em> 中：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># cat /proc/interrupts</span>
                CPU0
<span class="m">0</span>:           <span class="m">7514294</span>       IO-APIC-edge   timer
<span class="m">1</span>:              <span class="m">4528</span>       IO-APIC-edge   i8042
<span class="m">6</span>:                 <span class="m">2</span>       IO-APIC-edge   floppy
<span class="m">8</span>:                 <span class="m">1</span>       IO-APIC-edge   rtc
<span class="m">9</span>:                 <span class="m">0</span>       IO-APIC-level  acpi
<span class="m">12</span>:             <span class="m">2301</span>       IO-APIC-edge   i8042
<span class="m">15</span>:               <span class="m">41</span>       IO-APIC-edge   ide1
<span class="m">16</span>:             <span class="m">3230</span>       IO-APIC-level  ioc0
<span class="m">17</span>:             <span class="m">1016</span>       IO-APIC-level  vmxnet ether
NMI:               <span class="m">0</span>
LOC:         <span class="m">7229438</span>
ERR:               <span class="m">0</span>
MIS:               <span class="m">0</span>
</pre></div>
</div>
<p>第一列指定了与中断相关联的 IRQ。接下来的列显示了系统中每个处理器生成的中断次数；最后两列提供了有关中断控制器和注册该中断处理程序的设备名称的信息。</p>
<p><em>/proc/stat</em> 文件提供了有关系统活动的信息，包括自上次（重新）启动系统以来生成的中断次数：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># cat /proc/stat | grep in</span>
intr <span class="m">7765626</span> <span class="m">7754228</span> <span class="m">4620</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">2</span> <span class="m">0</span> <span class="m">1</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">2377</span> <span class="m">0</span> <span class="m">0</span> <span class="m">41</span> <span class="m">3259</span> <span class="m">1098</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
</pre></div>
</div>
<p><em>/proc/stat</em> 文件中的每一行都以关键字开头，指定了该行信息的含义。对于中断信息，这个关键字是 intr。行上的第一个数字表示中断的总数，其他数字表示从 0 开始的每个 IRQ 的中断次数。计数器包括系统中所有处理器的中断次数。</p>
</div>
</div>
<div class="section" id="section-9">
<h2>进一步阅读<a class="headerlink" href="#section-9" title="Permalink to this headline">¶</a></h2>
<div class="section" id="section-10">
<h3>串口<a class="headerlink" href="#section-10" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Serial_port">串口</a></li>
<li><a class="reference external" href="http://www.beyondlogic.org/serial/serial.htm">串口/RS232 端口接口</a></li>
</ul>
</div>
<div class="section" id="section-11">
<h3>并行端口<a class="headerlink" href="#section-11" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://www.beyondlogic.org/spp/parallel.htm">标准并行端口接口</a></li>
<li><a class="reference external" href="http://www.lvr.com/parport.htm">并行端口中心</a></li>
</ul>
</div>
<div class="section" id="section-12">
<h3>键盘控制器<a class="headerlink" href="#section-12" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Intel_8042">Intel 8042</a></li>
<li>drivers/input/serio/i8042.c</li>
<li>drivers/input/keyboard/atkbd.c</li>
</ul>
</div>
<div class="section" id="linux">
<h3>Linux设备驱动程序<a class="headerlink" href="#linux" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://lwn.net/images/pdf/LDD3/ch09.pdf">Linux 设备驱动程序，第 3 版，第 9 章——与硬件通信</a></li>
<li><a class="reference external" href="http://lwn.net/images/pdf/LDD3/ch10.pdf">Linux 设备驱动程序，第 3 版，第 10 章——中断处理</a></li>
<li><a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x1256.html">中断处理程序</a></li>
</ul>
</div>
</div>
<div class="section" id="section-13">
<h2>练习<a class="headerlink" href="#section-13" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 中断。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/中断/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-13">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-14">
<h3>0. 简介<a class="headerlink" href="#section-14" title="Permalink to this headline">¶</a></h3>
<p>使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a>，在 Linux 内核中查找以下符号的定义：</p>
<ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">resource</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">request_region()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">__request_region()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">request_threaded_irq()</span></code></li>
<li>:c:func:<a href="#system-message-2"><span class="problematic" id="problematic-2">`</span></a>inb`（适用于 x86 架构）</li>
</ul>
<p>分析以下 Linux 代码：</p>
<ul class="simple">
<li>键盘初始化函数 <code class="xref c c-func docutils literal"><span class="pre">i8042_setup_kbd()</span></code></li>
<li>AT 或 PS/2 键盘中断函数 <code class="xref c c-func docutils literal"><span class="pre">atkbd_interrupt()</span></code></li>
</ul>
</div>
<div class="section" id="section-15">
<h3>键盘驱动程序<a class="headerlink" href="#section-15" title="Permalink to this headline">¶</a></h3>
<p>下一个练习的目标是创建一个使用键盘 IRQ 的驱动程序，检查传入的按键代码并将其存储在缓冲区中。通过字符设备驱动程序，用户空间可以访问该缓冲区。</p>
</div>
<div class="section" id="i-o-3">
<h3>1. 请求 I/O 端口<a class="headerlink" href="#i-o-3" title="Permalink to this headline">¶</a></h3>
<p>首先，我们的目标是在 I/O 空间中为硬件设备分配内存。我们看到，我们无法为键盘分配空间，因为指定的区域已经被分配。然后，我们将为未使用的端口分配 I/O 空间。</p>
<p><em>kbd.c</em> 文件中包含了键盘驱动程序的框架。浏览源代码并检查 <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code> 函数。注意我们需要的 I/O 端口是 I8042_STATUS_REG 和 I8042_DATA_REG。</p>
<p>按照骨架中标有 <strong>TODO 1</strong> 的部分进行操作。在 <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code> 函数中请求 I/O 端口，并确保检查错误并在出现错误时进行适当的清理。在请求时，使用 <code class="docutils literal"><span class="pre">MODULE_NAME</span></code> 宏设置调用者的 ID 字符串（<code class="docutils literal"><span class="pre">name</span></code>）设置为该宏的值。此外，在 <code class="xref c c-func docutils literal"><span class="pre">kbd_exit()</span></code> 函数中添加代码以释放 I/O 端口。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在继续之前，你可以回顾一下 <a class="reference internal" href="#i-o">请求访问 I/O 端口</a> 部分。</p>
</div>
<p>现在构建模块并将其复制到虚拟机镜像中：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
tools/labs $ make copy
</pre></div>
</div>
<p>现在启动虚拟机并插入模块：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# insmod skels/interrupts/kbd.ko
kbd: loading out-of-tree module taints kernel.
insmod: can&#39;t insert &#39;skels/interrupts/kbd.ko&#39;: Device or resource busy
</pre></div>
</div>
<p>注意，在尝试请求 I/O 端口时会出现错误。这是因为我们已经有了一个请求此 I/O 端口的驱动程序。为了验证，请查看 <code class="file docutils literal"><span class="pre">/proc/ioports</span></code> 文件以查找 <code class="docutils literal"><span class="pre">STATUS_REG</span></code> 和 <code class="docutils literal"><span class="pre">DATA_REG</span></code> 的值：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# cat /proc/ioports <span class="p">|</span> egrep <span class="s2">&quot;(0060|0064)&quot;</span>
<span class="m">0060</span>-0060 : keyboard
<span class="m">0064</span>-0064 : keyboard
</pre></div>
</div>
<p>让我们找出是哪个驱动程序注册了这些端口，并尝试移除与之关联的模块。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ find -name <span class="se">\*</span>.c <span class="p">|</span> xargs grep <span class="se">\&quot;</span>keyboard<span class="se">\&quot;</span>

find -name <span class="se">\*</span>.c <span class="p">|</span> xargs grep <span class="se">\&quot;</span>keyboard<span class="se">\&quot;</span> <span class="p">|</span> egrep <span class="s1">&#39;(0x60|0x64)&#39;</span>
...
./arch/x86/kernel/setup.c:<span class="o">{</span> .name <span class="o">=</span> <span class="s2">&quot;keyboard&quot;</span>, .start <span class="o">=</span> 0x60, .end <span class="o">=</span> 0x60,
./arch/x86/kernel/setup.c:<span class="o">{</span> .name <span class="o">=</span> <span class="s2">&quot;keyboard&quot;</span>, .start <span class="o">=</span> 0x64, .end <span class="o">=</span> 0x64
</pre></div>
</div>
<p>看起来这些 I/O 端口是由内核在启动期间注册的，我们将无法移除与之关联的模块。相反，让我们欺骗内核并注册端口 0x61 和 0x65。</p>
<p>在 <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code> 函数中使用函数 <code class="xref c c-func docutils literal"><span class="pre">request_region()</span></code> 来分配这些端口，并在 <code class="xref c c-func docutils literal"><span class="pre">kbd_exit()</span></code> 函数中使用函数 <code class="xref c c-func docutils literal"><span class="pre">release_region()</span></code> 来释放分配的内存。</p>
<p>这次我们可以加载模块，并且 <em>/proc/ioports</em> 显示这些端口的所有者是我们的模块：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# insmod skels/interrupts/kbd.ko
kbd: loading out-of-tree module taints kernel.
Driver kbd loaded
root@qemux86:~# cat /proc/ioports <span class="p">|</span> grep kbd
<span class="m">0061</span>-0061 : kbd
<span class="m">0065</span>-0065 : kbd
</pre></div>
</div>
<p>让我们移除模块并检查 I/O 端口是否已释放：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# rmmod kbd
Driver kbd unloaded
root@qemux86:~# cat /proc/ioports <span class="p">|</span> grep kbd
root@qemux86:~#
</pre></div>
</div>
</div>
<div class="section" id="section-16">
<h3>2. 中断处理例程<a class="headerlink" href="#section-16" title="Permalink to this headline">¶</a></h3>
<p>对于这个任务，我们将实现并注册一个键盘中断的中断处理例程。在继续之前，你可以先回顾一下 <a class="reference internal" href="#section-5">请求中断</a> 一节。</p>
<p>请按照骨架中标有 <strong>TODO 2</strong> 的部分进行操作。</p>
<p>首先，定义一个名为 <code class="xref c c-func docutils literal"><span class="pre">kbd_interrupt_handler()</span></code> 的空中断处理例程。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">由于我们已经有一个使用该中断的驱动程序，我们应该将中断报告为未处理（即返回 <code class="xref c c-type docutils literal"><span class="pre">IRQ_NONE</span></code>），以便原始驱动程序仍有机会进行处理。</p>
</div>
<p>然后，使用 <code class="xref c c-type docutils literal"><span class="pre">request_irq</span></code> 注册中断处理例程。中断号由 <cite>I8042_KBD_IRQ</cite> 宏定义。中断处理例程必须使用 <code class="xref c c-type docutils literal"><span class="pre">IRQF_SHARED</span></code> 进行请求，以与键盘驱动程序（i8042）共享中断线。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>对于共享中断, <em>dev_id</em> 不能为 NULL。请使用 <code class="docutils literal"><span class="pre">&amp;devs[0]</span></code>，即 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code> 的指针。此结构包含了设备管理所需的所有信息。为了在 <em>/proc/interrupts</em> 中看到该中断，请不要使用 NULL 作为 <em>dev_name</em> 。你可以使用 MODULE_NAME 宏。</p>
<p class="last">如果中断请求失败，请确保通过跳转到正确的标签（label）来进行适当的清理，即释放 I/O 端口并注销字符设备驱动程序。</p>
</div>
<p>编译、复制并加载模块到内核中。通过查看 <em>/proc/interrupts</em>，检查中断线是否已注册。从源代码中确定 IRQ 号码（参见 <cite>I8042_KBD_IRQ</cite>）并验证该中断线上有两个注册的驱动程序（这表示我们有一个共享中断线）：i8042 初始驱动程序和我们的驱动程序。</p>
<p>在例程内部打印一条消息，以确保它被调用。将模块编译并重新加载到内核中。使用 <strong class="command">dmesg</strong> 检查在虚拟机上按键时是否调用了中断处理例程。还要注意，当使用串口时不会触发键盘中断。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">要访问虚拟机上的键盘，请使用“QEMU_DISPLAY=gtk make boot”启动。</p>
</div>
</div>
<div class="section" id="ascii">
<h3>3. 将 ASCII 键存储到缓冲区<a class="headerlink" href="#ascii" title="Permalink to this headline">¶</a></h3>
<p>接下来，我们希望收集按键的输入到缓冲区里，并将其内容发送到用户空间。为此，我们将在中断处理中添加以下内容：</p>
<ul class="simple">
<li>捕获按下的键（只捕获按下的键，忽略释放的键）</li>
<li>识别 ASCII 字符</li>
<li>将与按键对应的 ASCII 字符复制并存储在设备的缓冲区中</li>
</ul>
<p>请按照骨架中标记为 <strong>TODO 3</strong> 的部分进行操作。</p>
<div class="section" id="section-17">
<h4>读取数据寄存器<a class="headerlink" href="#section-17" title="Permalink to this headline">¶</a></h4>
<p>首先，填写 <code class="xref c c-func docutils literal"><span class="pre">i8042_read_data()</span></code> 函数，以读取键盘控制器的 <code class="docutils literal"><span class="pre">I8042_DATA_REG</span></code> 寄存器。该函数只需要返回寄存器的值。寄存器的值也称为扫描码（scancode），它在每次按键时生成。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">inb()</span></code> 读取 <code class="docutils literal"><span class="pre">I8042_DATA_REG</span></code> 寄存器，并将值存储在局部变量 <code class="xref c c-type docutils literal"><span class="pre">val</span></code> 中。请参阅 <a class="reference internal" href="#i-o-1">访问 I/O 端口</a> 部分。</p>
</div>
<p>在 <code class="xref c c-func docutils literal"><span class="pre">kbd_interrupt_handler()</span></code> 中调用 <code class="xref c c-func docutils literal"><span class="pre">i8042_read_data()</span></code> 并打印读取的值。</p>
<p>按以下格式打印有关按键的信息：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IRQ:% d, scancode = 0x%x (%u,%c)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
   <span class="n">irq_no</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>
</pre></div>
</div>
<p>其中，scancode，即扫描码，是使用 <code class="xref c c-func docutils literal"><span class="pre">i8042_read_data()</span></code> 函数读取的寄存器的值。</p>
<p>请注意，扫描码（读取的寄存器的值）不是按下键的 ASCII 字符。我们需要理解扫描码。</p>
</div>
<div class="section" id="section-18">
<h4>解释扫描码<a class="headerlink" href="#section-18" title="Permalink to this headline">¶</a></h4>
<p>请注意，寄存器值是扫描码，而不是按下的字符的 ASCII 值。还要注意，中断在按键按下和释放时都会发送。我们只需要在按键按下时获取扫描码，然后解码 ASCII 字符。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>要检查扫描码，可以使用 showkey 命令（showkey -s）。</p>
<p>命令将在按下键后显示 10 秒钟的键扫描码，然后停止。如果按下并释放一个键，你将获得两个扫描码：一个对应按下的键，一个对应释放的键。例如：</p>
<ul class="last">
<li><p class="first">如果按下回车键，你将获得 0x1c（0x1c）和 0x9c（释放键）。</p>
</li>
<li><p class="first">如果按下键 a，你将获得 0x1e（按下的键）和 0x9e（释放键）。</p>
</li>
<li><p class="first">如果按下键 b，你将获得 0x30（按下的键）和 0xb0（释放键）。</p>
</li>
<li><p class="first">如果按下键 c，你将获得 0x2e（按下的键）和 0xae（释放键）。</p>
</li>
<li><p class="first">如果按下 Shift 键，你将获得 0x2a（按下的键）和 0xaa（释放键）。</p>
</li>
<li><p class="first">如果按下 Ctrl 键，你将获得 0x1d（按下的键）和 0x9d（释放键）。</p>
<p>正如在 <a class="reference external" href="http://www.linuxjournal.com/article/1080">这篇文章</a> 中所指出的，释放键的扫描码比按下键的扫描码高 128（0x80）。这是我们区分按下键的扫描码和释放键的扫描码的方法。</p>
<p>扫描码被转换为与键匹配的键码（keycode）。按下的扫描码和释放的扫描码具有相同的键码。对于上面显示的键，我们有以下表格：</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>键</td>
<td>按下的扫描码</td>
<td>释放的扫描码</td>
<td>键码</td>
</tr>
<tr class="row-even"><td>回车</td>
<td>0x1c</td>
<td>0x9c</td>
<td>0x1c（28）</td>
</tr>
<tr class="row-odd"><td>a</td>
<td>0x1e</td>
<td>0x9e</td>
<td>0x1e（30）</td>
</tr>
<tr class="row-even"><td>b</td>
<td>0x30</td>
<td>0xb0</td>
<td>0x30（48）</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>0x2e</td>
<td>0xae</td>
<td>0x2e（46）</td>
</tr>
<tr class="row-even"><td>Shift</td>
<td>0x2a</td>
<td>0xaa</td>
<td>0x2a（42）</td>
</tr>
<tr class="row-odd"><td>Ctrl</td>
<td>0x1d</td>
<td>0x9d</td>
<td>0x1d（29）</td>
</tr>
</tbody>
</table>
<p>按键按下/释放操作在 is_key_press() 函数中执行，获取扫描码的 ASCII 字符在 get_ascii() 函数中进行。</p>
</li>
</ul>
</div>
<p>在中断处理程序中，先检查扫描码以确定按键是按下还是释放，然后确定相应的 ASCII 字符。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">要检查按下/释放，请使用 <code class="xref c c-func docutils literal"><span class="pre">is_key_press()</span></code> 函数。使用 <code class="xref c c-func docutils literal"><span class="pre">get_ascii()</span></code> 函数获取相应的 ASCII 码。这两个函数都以扫描码作为参数。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>要显示接收到的信息，请使用以下格式。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IRQ %d: scancode=0x%x (%u) pressed=%d ch=%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">irq_no</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">其中，scancode 是数据寄存器的值，ch 是 get_ascii() 函数返回的值。</p>
</div>
</div>
<div class="section" id="section-19">
<h4>将字符存储到缓冲区<a class="headerlink" href="#section-19" title="Permalink to this headline">¶</a></h4>
<p>我们希望将按下的字符（而不是其他键）收集到一个循环缓冲区（circular buffer）中，以便可以从用户空间中使用。</p>
<p>更新中断处理程序，将按下的 ASCII 字符添加到设备缓冲区的末尾。如果缓冲区已满，则将丢弃该字符。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>设备缓冲区是设备的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code> 中的字段 <code class="xref c c-type docutils literal"><span class="pre">buf</span></code>。要从中断处理程序中获取设备数据，请使用以下结构：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kbd</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kbd</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">缓冲区的大小位于 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code> 的字段 <code class="xref c c-type docutils literal"><span class="pre">count</span></code> 中。<code class="xref c c-type docutils literal"><span class="pre">put_idx</span></code> 和 <code class="xref c c-type docutils literal"><span class="pre">get_idx</span></code> 字段指定下一个写入和读取的索引。查看 <code class="xref c c-func docutils literal"><span class="pre">put_char()</span></code> 函数的实现，了解数据是如何添加到循环缓冲区中的。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>使用自旋锁对缓冲区和辅助索引进行同步访问。在设备结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code> 中定义自旋锁，并在 <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code> 中进行初始化。</p>
<p>使用 <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> 函数来保护中断处理程序中的缓冲区。</p>
<p class="last">请参阅 <a class="reference internal" href="#section-7">锁定</a> 小节。</p>
</div>
</div>
</div>
<div class="section" id="section-20">
<h3>4. 读取缓冲区<a class="headerlink" href="#section-20" title="Permalink to this headline">¶</a></h3>
<p>为了访问键盘记录器的数据，我们需要将其发送到用户空间。我们将使用 <em>/dev/kbd</em> 字符设备来实现这一点。当从该设备读取数据时，我们将从内核空间的缓冲区中获取按键数据。</p>
<p>在这一步中，请按照 <code class="xref c c-func docutils literal"><span class="pre">kbd_read()</span></code> 函数中标有 <strong>TODO 4</strong> 的部分进行操作。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">get_char()</span></code> 的实现类似于 <code class="xref c c-func docutils literal"><span class="pre">put_char()</span></code> 。在实现循环缓冲区时要小心。</p>
<p>在 <code class="xref c c-func docutils literal"><span class="pre">kbd_read()</span></code> 函数中，将数据从缓冲区复制到用户空间缓冲区。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">get_char()</span></code> 从缓冲区中读取一个字符，并使用 <code class="xref c c-func docutils literal"><span class="pre">put_user()</span></code> 将其存储到用户缓冲区中。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>在读取函数中，使用 <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> 进行加锁。</p>
<p class="last">请参阅 <a class="reference internal" href="#section-7">锁定</a> 部分。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>我们不能在持有锁的情况下使用 <code class="xref c c-func docutils literal"><span class="pre">put_user()</span></code> 或 <code class="xref c c-func docutils literal"><span class="pre">copy_to_user()</span></code>，因为在原子上下文中不允许访问用户空间。</p>
<p class="last">有关更多信息，请阅读前面实验中的 <span class="xref std std-ref">访问进程地址空间</span>。</p>
</div>
<p>要进行测试，你需要在读取之前使用 mknod 创建 <em>/dev/kbd</em> 字符设备驱动程序。设备的主设备号和次设备号定义为 <code class="docutils literal"><span class="pre">KBD_MAJOR</span></code> 和 <code class="docutils literal"><span class="pre">KBD_MINOR</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mknod</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span> <span class="n">c</span> <span class="mi">42</span> <span class="mi">0</span>
</pre></div>
</div>
<p>构建、复制和启动虚拟机，并加载该模块。使用以下命令进行测试：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span>
</pre></div>
</div>
</div>
<div class="section" id="section-21">
<h3>5. 重置缓冲区<a class="headerlink" href="#section-21" title="Permalink to this headline">¶</a></h3>
<p>如果对设备进行写操作，则重置缓冲区。在这一步中，请按照骨架中标有 <strong>TODO 5</strong> 的部分进行操作。</p>
<p>实现 <code class="xref c c-func docutils literal"><span class="pre">reset_buffer()</span></code> 并将写操作添加到 <em>kbd_fops</em> 中。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>在写函数中，当重置缓冲区时，请使用 <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> 进行加锁。</p>
<p class="last">请参阅 <a class="reference internal" href="#section-7">锁定</a> 部分。</p>
</div>
<p>为了进行测试，你需要在读取之前使用 mknod 创建 <em>/dev/kbd</em> 字符设备驱动程序。设备的主设备号和次设备号定义为 <code class="docutils literal"><span class="pre">KBD_MAJOR</span></code> 和 <code class="docutils literal"><span class="pre">KBD_MINOR</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mknod</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span> <span class="n">c</span> <span class="mi">42</span> <span class="mi">0</span>
</pre></div>
</div>
<p>构建、复制和启动虚拟机，并加载该模块。使用以下命令进行测试：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span>
</pre></div>
</div>
<p>按下一些键，然后运行命令 <strong class="command">echo &quot;clear&quot; &gt; /dev/kbd</strong>。再次检查缓冲区的内容。它应该重置了。</p>
</div>
</div>
<div class="section" id="section-22">
<h2>额外练习<a class="headerlink" href="#section-22" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kfifo">
<h3>1. kfifo<a class="headerlink" href="#kfifo" title="Permalink to this headline">¶</a></h3>
<p>使用 <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/include/linux/kfifo.h">kfifo API</a> 实现一个键盘记录器。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">参考内核代码中的 <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/samples/kfifo">API 调用示例</a>。例如，文件 <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/samples/kfifo/bytestream-example.c">bytestream-examples.c</a>。</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab3-device-drivers.html" class="btn btn-neutral float-left" title="SO2 Lab 03 - Character device drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab5-deferred-work.html" class="btn btn-neutral float-right" title="SO2 Lab 05 - Deferred work" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>