<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 04 - I/O access and Interrupts &mdash; The Linux Kernel  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 05 - Deferred work" href="lab5-deferred-work.html" />
    <link rel="prev" title="SO2 Lab 03 - Character device drivers" href="lab3-device-drivers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            The Linux Kernel
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 04 - I/O access and Interrupts</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#background-information">Background information</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accessing-the-hardware">Accessing the hardware</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#request-access-to-i-o-ports">Request access to I/O ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-i-o-ports">Accessing I/O ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#accessing-i-o-ports-from-userspace">5. Accessing I/O ports from userspace</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interrupt-handling">Interrupt handling</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#requesting-an-interrupt">Requesting an interrupt</a></li>
<li class="toctree-l4"><a class="reference internal" href="#implementing-an-interrupt-handler">Implementing an interrupt handler</a></li>
<li class="toctree-l4"><a class="reference internal" href="#locking">Locking</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-statistics">Interrupt statistics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">Further reading</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#serial-port">Serial Port</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parallel-port">Parallel port</a></li>
<li class="toctree-l4"><a class="reference internal" href="#keyboard-controller">Keyboard controller</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-device-drivers">Linux device drivers</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#intro">0. Intro</a></li>
<li class="toctree-l4"><a class="reference internal" href="#keyboard-driver">Keyboard driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#request-the-i-o-ports">1. Request the I/O ports</a></li>
<li class="toctree-l4"><a class="reference internal" href="#interrupt-handling-routine">2. Interrupt handling routine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#store-ascii-keys-to-buffer">3. Store ASCII keys to buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reading-the-buffer">4. Reading the buffer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reset-the-buffer">5. Reset the buffer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#extra-exercises">Extra Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kfifo">1. kfifo</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">Customizing the Virtual Machine Setup</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">Contributing to linux-kernel-labs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">The Linux Kernel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 04 - I/O access and Interrupts</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab4-interrupts.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-04-i-o-access-and-interrupts">
<h1>SO2 Lab 04 - I/O access and Interrupts<a class="headerlink" href="#so2-lab-04-i-o-access-and-interrupts" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>communication with peripheral devices</li>
<li>implement interrupt handlers</li>
<li>synchronizing interrupts with process context</li>
</ul>
<p>Keywords: IRQ, I/O port, I/O address, base address, UART, request_region, release_region, inb, outb</p>
</div>
<div class="section" id="background-information">
<h2>Background information<a class="headerlink" href="#background-information" title="Permalink to this headline">¶</a></h2>
<p>A peripheral device is controlled by writing and reading its
registers. Often, a device has multiple registers that can be accessed
at consecutive addresses either in the memory address space or in the
I/O address space. Each device connected to the I/O bus has a set of
I/O addresses, called I/O ports. I/O ports can be mapped to physical
memory addresses so that the processor can communicate with the device
through instructions that work directly with the memory. For
simplicity, we will directly use I/O ports (without mapping to physical
memory addresses) to communicate with physical devices.</p>
<p>The I/O ports of each device are structured into a set of specialized
registers to provide a uniform programming interface. Thus, most
devices will have the following types of registers:</p>
<ul class="simple">
<li><strong>Control</strong> registers that receive device commands</li>
<li><strong>Status</strong> registers, which contain information about the device's
internal status</li>
<li><strong>Input</strong> registers from which data is taken from the device</li>
<li><strong>Output</strong> registers in which the data is written to transmit it to the
device</li>
</ul>
<p>Physical ports are differentiated by the number of bits: they can be
8, 16 or 32-bit ports.</p>
<p>For example, the parallel port has 8 8-bit I/O ports starting at base
address 0x378. The data log is found at base address (0x378), status
register at base + 1 (0x379), and control at base address + 2
(0x37a). The data log is both an entry and exit log.</p>
<p>Although there are devices that can be fully controlled using I/O
ports or special memory areas, there are situations where this is
insufficient. The main problem that needs to be addressed is that
certain events occur at undefined moments in time and it is
inefficient for the processor (CPU) to interrogate the status of the
device repeatedly (polling). The way to solve this problem is using an
Interrupt ReQuest (IRQ) which is a hardware notification by which the
processor is announced that a particular external event happened.</p>
<p>For IRQs to be useful device drivers must implement handlers, i.e. a
particular sequence of code that handles the interrupt. Because in
many situations the number of interrupts available is limited, a
device driver must behave in an orderly fashion with interruptions:
interrupts must be requested before being used and released when they
are no longer needed. In addition, in some situations, device drivers
must share an interrupt or synchronize with interrupts. All of these will be
discussed further.</p>
<p>When we need to access shared resources between an interrupt
routine (A) and code running in process context or in bottom-half
context (B), we must use a special synchronization technique. In (A)
we need to use a spinlock primitive, and in (B) we must disable
interrupts AND use a spinlock primitive. Disabling interrupts is not
enough because the interrupt routine can run on a processor other than
the one running (B).</p>
<p>Using only a spinlock can lead to a deadlock. The classic example of
deadlock in this case is:</p>
<ol class="arabic simple">
<li>We run a process on the X processor, and we acquire the lock</li>
<li>Before releasing the lock, an interrupt is generated on the X processor</li>
<li>The interrupt handling routine will try to acquire the lock and it
will go into an infinite loop</li>
</ol>
</div>
<div class="section" id="accessing-the-hardware">
<h2>Accessing the hardware<a class="headerlink" href="#accessing-the-hardware" title="Permalink to this headline">¶</a></h2>
<p>In Linux, the I/O ports access is implemented on all architectures and
there are several APIs that can be used.</p>
<div class="section" id="request-access-to-i-o-ports">
<h3>Request access to I/O ports<a class="headerlink" href="#request-access-to-i-o-ports" title="Permalink to this headline">¶</a></h3>
<p>Before accessing I/O ports we first must request access to them, to
make sure there is only one user. In order to do so, one must use the
<code class="xref c c-func docutils literal"><span class="pre">request_region()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/ioport.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">resource</span> <span class="o">*</span><span class="nf">request_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span>
                                <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>To release a reserved region one must use the <code class="xref c c-func docutils literal"><span class="pre">release_region()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">release_region</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>For example, the serial port COM1 has the base address 0x3F8 and it
has 8 ports and this is a code snippet of how to request access to
these ports:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/ioport.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BASEPORT 0x3F8</span>
<span class="cp">#define MY_NR_PORTS 8</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">request_region</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="n">MY_NR_PORTS</span><span class="p">,</span> <span class="s">&quot;com1&quot;</span><span class="p">))</span> <span class="p">{</span>
     <span class="cm">/* handle error */</span>
     <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To release the ports one would use something like:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">release_region</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="n">MY_NR_PORTS</span><span class="p">);</span>
</pre></div>
</div>
<p>Most of the time, port requests are done at the driver initialization
or probe time and the port releasing is done at the removal of the
device or module.</p>
<p>All of the port requests can be seen from userspace via the
<code class="file docutils literal"><span class="pre">/proc/ioports</span></code> file:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ cat /proc/ioports
<span class="m">0000</span>-001f : dma1
<span class="m">0020</span>-0021 : pic1
<span class="m">0040</span>-005f : timer
<span class="m">0060</span>-006f : keyboard
<span class="m">0070</span>-0077 : rtc
<span class="m">0080</span>-008f : dma page reg
00a0-00a1 : pic2
00c0-00df : dma2
00f0-00ff : fpu
<span class="m">0170</span>-0177 : ide1
01f0-01f7 : ide0
<span class="m">0376</span>-0376 : ide1
<span class="m">0378</span>-037a : parport0
037b-037f : parport0
03c0-03df : vga+
03f6-03f6 : ide0
03f8-03ff : serial
...
</pre></div>
</div>
</div>
<div class="section" id="accessing-i-o-ports">
<h3>Accessing I/O ports<a class="headerlink" href="#accessing-i-o-ports" title="Permalink to this headline">¶</a></h3>
<p>After a driver has obtained the desired I/O port range, one can
perform read or write operations on these ports. Since physical ports
are differentiated by the number of bits (8, 16, or 32 bits), there
are different port access functions depending on their size. The
following port access functions are defined in asm/io.h:</p>
<ul class="simple">
<li><em>unsigned inb(int port)</em>, reads one byte (8 bits) from port</li>
<li><em>void outb(unsigned char byte, int port)</em>, writes one byte (8 bits) to port</li>
<li><em>unsigned inw(int port)</em>, reads two bytes (16-bit) ports</li>
<li><em>void outw(unsigned short word, int port)</em>, writes two bytes (16-bits) to port</li>
<li><em>unsigned inl (int port)</em>, reads four bytes (32-bits) from port</li>
<li><em>void outl(unsigned long word, int port)</em>, writes four bytes (32-bits) to port</li>
</ul>
<p>The port argument specifies the address of the port where the reads or
writes are done, and its type is platform dependent (may be unsigned
long or unsigned short).</p>
<p>Some devices may have problems when the processor is trying to
transfer data too fast to and from the device. To avoid this issue we
may need to insert a delay after an I/O operation and there are functions
you can use that introduce this delay. Their names are similar to
those described above, with the exception that it ends in _p: inb_p,
outb_p, etc.</p>
<p>For example, the following sequence writes a byte on COM1 serial port
and then reads it:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/io.h&gt;</span><span class="cp"></span>
<span class="cp">#define MY_BASEPORT 0x3F8</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
<span class="n">outb</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">MY_BASEPORT</span><span class="p">);</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="accessing-i-o-ports-from-userspace">
<h3>5. Accessing I/O ports from userspace<a class="headerlink" href="#accessing-i-o-ports-from-userspace" title="Permalink to this headline">¶</a></h3>
<p>Although the functions described above are defined for device drivers,
they can also be used in user space by including the &lt;sys/io.h&gt;
header. In order to be used, ioperm or iopl must first be called to
get permission to perform port operations. The ioperm function obtains
permission for individual ports, while iopl for the entire I/O address
space. To use these features, the user must be root.</p>
<p>The following sequence used in user space gets permission for the
first 3 ports of the serial port, and then releases them:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;sys/io.h&gt;</span><span class="cp"></span>
<span class="cp">#define MY_BASEPORT 0x3F8</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ioperm</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
     <span class="cm">/* handle error */</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ioperm</span><span class="p">(</span><span class="n">MY_BASEPORT</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
     <span class="cm">/* handle error */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The third parameter of the ioperm function is used to request or
release port permission: 1 to get permission and 0 to release.</p>
</div>
</div>
<div class="section" id="interrupt-handling">
<h2>Interrupt handling<a class="headerlink" href="#interrupt-handling" title="Permalink to this headline">¶</a></h2>
<div class="section" id="requesting-an-interrupt">
<h3>Requesting an interrupt<a class="headerlink" href="#requesting-an-interrupt" title="Permalink to this headline">¶</a></h3>
<p>As with other resources, a driver must gain access to an interrupt
line before it can use it and release it at the end of the execution.</p>
<p>In Linux, the request to obtain and release an interrupt is done using
the <code class="xref c c-func docutils literal"><span class="pre">requests_irq()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code> functions:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/interrupt.h&gt;</span><span class="cp"></span>

<span class="k">typedef</span> <span class="nf">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">irq_handler_t</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">free_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that to get an interrupt, the developer calls
<code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code>. When calling this function you must specify the
interrupt number (<em>irq_no</em>), a handler that will be called when the
interrupt is generated (<em>handler</em>), flags that will instruct the
kernel about the desired behaviour (<em>flags</em>), the name of the device
using this interrupt (<em>dev_name</em>), and a pointer that can be
configured by the user at any value, and that has no global
significance (<em>dev_id</em>). Most of the time, <em>dev_id</em> will be
pointer to the device driver's private data. When the interrupt is
released, using the <code class="xref c c-func docutils literal"><span class="pre">free_irq()</span></code> function, the developer must
send the same pointer value (<em>dev_id</em>) along with the same interrupt
number (<em>irq_no</em>). The device name (<em>dev_name</em>) is used to display
statistics in <em>/proc/interrupts</em>.</p>
<p>The value that <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> returns is 0 if the entry was
successful or a negative error code indicating the reason for the
failure. A typical value is <em>-EBUSY</em> which means that the interrupt
was already requested by another device driver.</p>
<p>The <em>handler</em> function is executed in interrupt context which means
that we can't call blocking APIs such as <code class="xref c c-func docutils literal"><span class="pre">mutex_lock()</span></code> or
<code class="xref c c-func docutils literal"><span class="pre">msleep()</span></code>. We must also avoid doing a lot of work in the
interrupt handler and instead use deferred work if needed. The actions
performed in the interrupt handler include reading the device
registers to get the status of the device and acknowledge the
interrupt, operations that most of the time can be performed with
non-blocking calls.</p>
<p>There are situations where although a device uses interrupts we can't
read the device's registers in a non-blocking mode (for example a
sensor connected to an I2C or SPI bus whose driver does not guarantee
that bus read / write operations are non-blocking ). In this
situation, in the interruption, we must plan a work-in-process action
(work queue, kernel thread) to access the device's registers. Because
such a situation is relatively common, the kernel provides the
<code class="xref c c-func docutils literal"><span class="pre">request_threaded_irq()</span></code> function to write interrupt handling
routines running in two phases: a process-phase and an interrupt
context phase:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/interrupt.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">request_threaded_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span> <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
                         <span class="n">irq_handler_t</span> <span class="n">thread_fn</span><span class="p">,</span>
                         <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<p><em>handler</em> is the function running in interrupt context, and will
implement critical operations while the thread_fn function runs in
process context and implements the rest of the operations.</p>
<p>The flags that can be transmitted when an interruption is made are:</p>
<ul class="simple">
<li><em>IRQF_SHARED</em> announces the kernel that the interrupt can be
shared with other devices. If this flag is not set, then if there is
already a handler associated with the requested interrupt, the
request for interrupt will fail. A shared interrupt is handled in a
special way by the kernel: all the associated interrupt handlers
will be executed until the device that generated the interrupt will
be identified. But how can a device driver know if the interrupt
handling routine was activated by an interrupt generated by the
device it manages? Virtually all devices that offer interrupt
support have a status register that can be interrogated in the
handling routine to see if the interrupt was or was not generated by
the device (for example, in the case of the 8250 serial port, this
status register is IIR - Interrupt Information Register). When
requesting a shared interrupt, the dev_id argument must be unique
and it must not be NULL.  Usually it is set to module's private
data.</li>
<li><em>IRQF_ONESHOT</em> interrupt will be reactivated after running the process
context routine; Without this flag, the interrupt will be
reactivated after running the handler routine in the context of
the interrupt</li>
</ul>
<p>Requesting the interrupt can be done either at the initialization of
the driver (<code class="xref c c-func docutils literal"><span class="pre">init_module()</span></code>), when the device is probed, or when
the device is used (e.g. during <em>open</em>).</p>
<p>The following example performs the interrupt request for the COM1
serial port:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/interrupt.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_BASEPORT 0x3F8</span>
<span class="cp">#define MY_IRQ 4</span>

<span class="k">static</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="p">[...]</span>
     <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

     <span class="n">err</span> <span class="o">=</span> <span class="n">request_irq</span><span class="p">(</span><span class="n">MY_IRQ</span><span class="p">,</span> <span class="n">my_handler</span><span class="p">,</span> <span class="n">IRQF_SHARED</span><span class="p">,</span>
                       <span class="s">&quot;com1&quot;</span><span class="p">,</span> <span class="n">my_data</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
         <span class="cm">/* handle error*/</span>
         <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, the IRQ for serial port COM1 is 4, which is used in
shared mode (IRQF_SHARED).</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">When requesting a shared interrupt (IRQF_SHARED) the
<em>dev_id</em> argument can not be NULL.</p>
</div>
<p>To release the interrupt associated with the serial port, the
following operations will be executed:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">free_irq</span> <span class="p">(</span><span class="n">MY_IRQ</span><span class="p">,</span> <span class="n">my_data</span><span class="p">);</span>
</pre></div>
</div>
<p>During the initialization function (<code class="xref c c-func docutils literal"><span class="pre">init_module()</span></code>), or in the
function that opens the device, interrupts must be activated for the
device. This operation is dependent on the device, but most often
involves setting a bit from the control register.</p>
<p>As an example, for the 8250 serial port, the following operations must
be performed to enable interrupts:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/io.h&gt;</span><span class="cp"></span>
<span class="cp">#define MY_BASEPORT 0x3F8</span>

<span class="n">outb</span><span class="p">(</span><span class="mh">0x08</span><span class="p">,</span> <span class="n">MY_BASEPORT</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
<span class="n">outb</span><span class="p">(</span><span class="mh">0x01</span><span class="p">,</span> <span class="n">MY_BASEPORT</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>In the above example, two operations are performed:</p>
<ol class="arabic simple">
<li>All interruptions are activated by setting bit 3 (Aux Output 2) in
the MCR register - Modem Control Register</li>
<li>The RDAI (Transmit Holding Register Empty Interrupt) is activated
by setting the appropriate bit in the IER - Interrupt Enable
Register.</li>
</ol>
</div>
<div class="section" id="implementing-an-interrupt-handler">
<h3>Implementing an interrupt handler<a class="headerlink" href="#implementing-an-interrupt-handler" title="Permalink to this headline">¶</a></h3>
<p>Lets take a look at the signature of the interrupt handler function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">irqreturn_t</span> <span class="p">(</span><span class="o">*</span><span class="n">handler</span><span class="p">)(</span><span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
</pre></div>
</div>
<p>The function receives as parameters the number of the interrupt
(<em>irq_no</em>) and the pointer sent to <code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> when the
interrupt was requested. The interrupt handling routine must return a
value with a type of <code class="xref c c-type docutils literal"><span class="pre">typedef</span> <span class="pre">irqreturn_t</span></code>. For the current kernel
version, there are three valid values: <em>IRQ_NONE</em>, <em>IRQ_HANDLED</em>,
and <em>IRQ_WAKE_THREAD</em>. The device driver must return <em>IRQ_NONE</em> if
it notices that the interrupt has not been generated by the device it
is in charge. Otherwise, the device driver must return <em>IRQ_HANDLED</em>
if the interrupt can be handled directly from the interrupt context or
<em>IRQ_WAKE_THREAD</em> to schedule the running of the process context
processing function.</p>
<p>The skeleton for an interrupt handler is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">irqreturn_t</span> <span class="nf">my_handler</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>

    <span class="cm">/* if interrupt is not for this device (shared interrupts) */</span>
        <span class="cm">/* return IRQ_NONE;*/</span>

    <span class="cm">/* clear interrupt-pending bit */</span>
    <span class="cm">/* read from device or write to device*/</span>

    <span class="k">return</span> <span class="n">IRQ_HANDLED</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Typically, the first thing executed in the interrupt handler is to
determine whether the interrupt was generated by the device that the
driver ordered. This usually reads information from the device's
registers to indicate whether the device has generated an
interrupt. The second thing is to reset the interrupt pending bit on
the physical device as most devices will no longer generate
interruptions until this bit has been reset (e.g. for the 8250
serial port bit 0 in the IIR register must be cleared).</p>
</div>
<div class="section" id="locking">
<h3>Locking<a class="headerlink" href="#locking" title="Permalink to this headline">¶</a></h3>
<p>Because the interrupt handlers run in interrupt context the actions
that can be performed are limited: unable to access user space memory,
can't call blocking functions. Also, synchronization using spinlocks is
tricky and can lead to deadlocks if the spinlock used is already
acquired by a process that has been interrupted by the running
handler.</p>
<p>However, there are cases where device drivers have to synchronize
using interrupts, such as when data is shared between the interrupt
handler and process context or bottom-half handlers. In these
situations it is necessary to both deactivate the interrupt and use
spinlocks.</p>
<p>There are two ways to disable interrupts: disabling all interrupts, at
the processor level, or disabling a particular interrupt at the device
or interrupt controller level. Processor disabling is faster and is
therefore preferred. For this purpose, there are locking functions
that disable and enable interrupts acquiring and release a spinlock at
the same time: <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code>,
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code>, and
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irq()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">spin_lock_irqsave</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">spin_unlock_irqrestore</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">spin_lock_irq</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">spin_unlock_irq</span> <span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span> <span class="n">lock</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> function disables interrupts for the
local processor before it obtains the spinlock; The previous state of
the interrupts is saved in <em>flags</em>.</p>
<p>If you are absolutely sure that the interrupts on the current
processor have not already been disabled by someone else and you are
sure you can activate the interrupts when you release the spinlock,
you can use <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irq()</span></code>.</p>
<p>For read / write spinlocks there are similar functions available:</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">read_lock_irqsave()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">read_unlock_irqrestore()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">read_lock_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">read_unlock_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_lock_irqsave()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_unlock_irqrestore()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_lock_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">write_unlock_irq()</span></code></li>
</ul>
<p>If we want to disable interrupts at the interrupt controller level
(not recommended because disabling a particular interrupt is slower,
we can not disable shared interrupts) we can do this with
<code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">disable_irq_nosync()</span></code>, and
<code class="xref c c-func docutils literal"><span class="pre">enable_irq()</span></code>. Using these functions will disable the interrupts on
all processors. Calls can be nested: if disable_irq is called twice,
it will require as many calls enable_irq to enable it. The difference
between disable_irq and disable_irq_nosync is that the first one will
wait for the executed handlers to finish. Because of this,
<code class="xref c c-func docutils literal"><span class="pre">disable_irq_nosync()</span></code> is generally faster, but may lead to
races with the interrupts handler, so when not sure use
<code class="xref c c-func docutils literal"><span class="pre">disable_irq()</span></code>.</p>
<p>The following sequence disables and then enables the interrupt for
the COM1 serial port:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define MY_IRQ 4</span>

<span class="n">disable_irq</span> <span class="p">(</span><span class="n">MY_IRQ</span><span class="p">);</span>
<span class="n">enable_irq</span> <span class="p">(</span><span class="n">MY_IRQ</span><span class="p">);</span>
</pre></div>
</div>
<p>It is also possible to disable interrupts at the device level. This
approach is also slower than disabling interrupts at the processor
level, but it works with shared interrupts. The way to accomplish this
is device specific and it usually means we have to clear a bit from
one of the control registers.</p>
<p>It is also possible to disable all interrupts for the current
processor independent of taking locks. Disabling all interruptions by
device drivers for synchronization purposes is inappropriate because
races are still possible if the interrupt is handled on another
CPU. For reference, the functions that disable / enable interrupts on
the local processor are <code class="xref c c-func docutils literal"><span class="pre">local_irq_disable()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">local_irq_enable()</span></code>.</p>
<p>In order to use a resource shared between process context and the
interrupt handling routine, the functions described above will be used
as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

<span class="cm">/* IRQ handling routine: interrupt context */</span>
<span class="n">irqreturn_t</span> <span class="nf">kbd_interrupt_handle</span><span class="p">(</span><span class="kt">int</span> <span class="n">irq_no</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">dev_id</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="cm">/* Critical region - access shared resource */</span>
    <span class="n">spin_unlock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="cm">/* Process context: Disable interrupts when locking */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_access</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="cm">/* Critical region - access shared resource */</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">spin_lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <em>my_access function</em> above runs in process context. To
synchronize access to the shared data, we disable the interrupts and
use the spinlock <em>lock</em>, i.e. the <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> functions.</p>
<p>In the interrupt handling routine, we use the <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> functions to access the shared resource.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <em>flags</em> argument for <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> is a value and not a pointer but keep
in mind that <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> function changes the value of
the flag, since this is actually a macro.</p>
</div>
</div>
<div class="section" id="interrupt-statistics">
<h3>Interrupt statistics<a class="headerlink" href="#interrupt-statistics" title="Permalink to this headline">¶</a></h3>
<p>Information and statistics about system interrupts can be found in
<em>/proc/interrupts</em> or <em>/proc/stat</em>. Only system interrupts with
associated interrupt handlers appear in <em>/proc/interrupts</em>:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># cat /proc/interrupts</span>
                CPU0
<span class="m">0</span>:           <span class="m">7514294</span>       IO-APIC-edge   timer
<span class="m">1</span>:              <span class="m">4528</span>       IO-APIC-edge   i8042
<span class="m">6</span>:                 <span class="m">2</span>       IO-APIC-edge   floppy
<span class="m">8</span>:                 <span class="m">1</span>       IO-APIC-edge   rtc
<span class="m">9</span>:                 <span class="m">0</span>       IO-APIC-level  acpi
<span class="m">12</span>:             <span class="m">2301</span>       IO-APIC-edge   i8042
<span class="m">15</span>:               <span class="m">41</span>       IO-APIC-edge   ide1
<span class="m">16</span>:             <span class="m">3230</span>       IO-APIC-level  ioc0
<span class="m">17</span>:             <span class="m">1016</span>       IO-APIC-level  vmxnet ether
NMI:               <span class="m">0</span>
LOC:         <span class="m">7229438</span>
ERR:               <span class="m">0</span>
MIS:               <span class="m">0</span>
</pre></div>
</div>
<p>The first column specifies the IRQ associated with the interrupt. The
following column shows the number of interrupts that were generated
for each processor in the system; The last two columns provide
information about the interrupt controller and the device name that
registered the handler for that interrupt.</p>
<p>The <em>/proc/state</em> file provides information about system activity,
including the number of interruptions generated since the last (re)boot
of the system:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span><span class="c1"># cat /proc/stat | grep in</span>
intr <span class="m">7765626</span> <span class="m">7754228</span> <span class="m">4620</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">2</span> <span class="m">0</span> <span class="m">1</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">2377</span> <span class="m">0</span> <span class="m">0</span> <span class="m">41</span> <span class="m">3259</span> <span class="m">1098</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
<span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span> <span class="m">0</span>
</pre></div>
</div>
<p>Each line in the <em>/proc/state</em> file begins with a keyword that
specifies the meaning of the information on the line. For information
on interrupts, this keyword is intr. The first number on the line
represents the total number of interrupts, and the other numbers
represent the number of interrupts for each IRQ, starting at 0. The
counter includes the number of interrupts for all processors in the
system.</p>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<div class="section" id="serial-port">
<h3>Serial Port<a class="headerlink" href="#serial-port" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Serial_port">Serial Port</a></li>
<li><a class="reference external" href="http://www.beyondlogic.org/serial/serial.htm">Interfacing the Serial / RS232 Port</a></li>
</ul>
</div>
<div class="section" id="parallel-port">
<h3>Parallel port<a class="headerlink" href="#parallel-port" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://www.beyondlogic.org/spp/parallel.htm">Interfacing the Standard Parallel Port</a></li>
<li><a class="reference external" href="http://www.lvr.com/parport.htm">Parallel Port Central</a></li>
</ul>
</div>
<div class="section" id="keyboard-controller">
<h3>Keyboard controller<a class="headerlink" href="#keyboard-controller" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://en.wikipedia.org/wiki/Intel_8042">Intel 8042</a></li>
<li>drivers/input/serio/i8042.c</li>
<li>drivers/input/keyboard/atkbd.c</li>
</ul>
</div>
<div class="section" id="linux-device-drivers">
<h3>Linux device drivers<a class="headerlink" href="#linux-device-drivers" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><a class="reference external" href="http://lwn.net/images/pdf/LDD3/ch09.pdf">Linux Device Drivers, 3rd ed., Ch. 9 - Communicating with Hardware</a></li>
<li><a class="reference external" href="http://lwn.net/images/pdf/LDD3/ch10.pdf">Linux Device Drivers, 3rd ed., Ch. 10 - Interrupt Handling</a></li>
<li><a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x1256.html">Interrupt Handlers</a></li>
</ul>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is interrupts. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/interrupts/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">Connecting to the Virtual Machine</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
<div class="section" id="intro">
<h3>0. Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h3>
<p>Using <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a>, find the definitions of the following symbols in the Linux kernel:</p>
<ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">resource</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">request_region()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">__request_region()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">request_irq()</span></code> and  <code class="xref c c-func docutils literal"><span class="pre">request_threaded_irq()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">inb()</span></code> for the x86 architecture.</li>
</ul>
<p>Analyze the following Linux code:</p>
<ul class="simple">
<li>Keyboard initialization function <code class="xref c c-func docutils literal"><span class="pre">i8042_setup_kbd()</span></code></li>
<li>The AT or PS/2 keyboard interrupt function <code class="xref c c-func docutils literal"><span class="pre">atkbd_interrupt()</span></code></li>
</ul>
</div>
<div class="section" id="keyboard-driver">
<h3>Keyboard driver<a class="headerlink" href="#keyboard-driver" title="Permalink to this headline">¶</a></h3>
<p>The next exercise's objective is to create a driver that uses the
keyboard IRQ, inspect the incoming key codes and stores them in a
buffer. The buffer will be accessible from userspace via character
device driver.</p>
</div>
<div class="section" id="request-the-i-o-ports">
<h3>1. Request the I/O ports<a class="headerlink" href="#request-the-i-o-ports" title="Permalink to this headline">¶</a></h3>
<p>To start with, we aim to allocate memory in the I/O space for hardware
devices. We will see that we cannot allocate space for the keyboard
because the designated region is already allocated. Then we will allocate
I/O space for unused ports.</p>
<p>The <em>kbd.c</em> file contains a skeleton for the keyboard driver. Browse
the source code and inspect <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code>. Notice that the I/O
ports we need are I8042_STATUS_REG and I8042_DATA_REG.</p>
<p>Follow the sections maked with <strong>TODO 1</strong> in the skeleton. Request the I/O
ports in <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code> and make sure to check for errors and to properly
clean-up in case of errors. When requesting, set the reserving caller's ID
string (<code class="docutils literal"><span class="pre">name</span></code>) with <code class="docutils literal"><span class="pre">MODULE_NAME</span></code> macro. Also, add code to release the I/O
ports in <code class="xref c c-func docutils literal"><span class="pre">kbd_exit()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">You can review the <a class="reference internal" href="#request-access-to-i-o-ports">Request access to I/O ports</a> section before
proceeding.</p>
</div>
<p>Now build the module and copy it to the VM image:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
tools/labs $ make copy
</pre></div>
</div>
<p>Now start the VM and insert the module:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# insmod skels/interrupts/kbd.ko
kbd: loading out-of-tree module taints kernel.
insmod: can&#39;t insert &#39;skels/interrupts/kbd.ko&#39;: Device or resource busy
</pre></div>
</div>
<p>Notice that you get an error when trying to request the I/O
ports. This is because we already have a driver that has requested the
I/O ports. To validate check the <code class="file docutils literal"><span class="pre">/proc/ioports</span></code> file for the
<code class="docutils literal"><span class="pre">STATUS_REG</span></code> and <code class="docutils literal"><span class="pre">DATA_REG</span></code> values:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# cat /proc/ioports <span class="p">|</span> egrep <span class="s2">&quot;(0060|0064)&quot;</span>
<span class="m">0060</span>-0060 : keyboard
<span class="m">0064</span>-0064 : keyboard
</pre></div>
</div>
<p>Lets find out which driver register these ports and try to remove the
module associated with it.</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ find -name <span class="se">\*</span>.c <span class="p">|</span> xargs grep <span class="se">\&quot;</span>keyboard<span class="se">\&quot;</span>

find -name <span class="se">\*</span>.c <span class="p">|</span> xargs grep <span class="se">\&quot;</span>keyboard<span class="se">\&quot;</span> <span class="p">|</span> egrep <span class="s1">&#39;(0x60|0x64)&#39;</span>
...
./arch/x86/kernel/setup.c:<span class="o">{</span> .name <span class="o">=</span> <span class="s2">&quot;keyboard&quot;</span>, .start <span class="o">=</span> 0x60, .end <span class="o">=</span> 0x60,
./arch/x86/kernel/setup.c:<span class="o">{</span> .name <span class="o">=</span> <span class="s2">&quot;keyboard&quot;</span>, .start <span class="o">=</span> 0x64, .end <span class="o">=</span> 0x64
</pre></div>
</div>
<p>It looks like the I/O ports are registered by the kernel during the
boot, and we won't be able to remove the associated module. Instead,
let's trick the kernel and register ports 0x61 and 0x65.</p>
<p>Use the function <code class="xref c c-func docutils literal"><span class="pre">request_region()</span></code> (inside the <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code>
function) to allocate the ports and the function <code class="xref c c-func docutils literal"><span class="pre">release_region()</span></code>
(inside the <code class="xref c c-func docutils literal"><span class="pre">kbd_exit()</span></code> function) to release the allocated memory.</p>
<p>This time we can load the module and <em>/proc/ioports</em> shows that the
owner of these ports is our module:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# insmod skels/interrupts/kbd.ko
kbd: loading out-of-tree module taints kernel.
Driver kbd loaded
root@qemux86:~# cat /proc/ioports <span class="p">|</span> grep kbd
<span class="m">0061</span>-0061 : kbd
<span class="m">0065</span>-0065 : kbd
</pre></div>
</div>
<p>Let's remove the module and check that the I/O ports are released:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>root@qemux86:~# rmmod kbd
Driver kbd unloaded
root@qemux86:~# cat /proc/ioports <span class="p">|</span> grep kbd
root@qemux86:~#
</pre></div>
</div>
</div>
<div class="section" id="interrupt-handling-routine">
<h3>2. Interrupt handling routine<a class="headerlink" href="#interrupt-handling-routine" title="Permalink to this headline">¶</a></h3>
<p>For this task we will implement and register an interrupt handler for
the keyboard interrupt. You can review the <a class="reference internal" href="#requesting-an-interrupt">Requesting an interrupt</a>
section before proceeding.</p>
<p>Follow the sections marked with <strong>TODO 2</strong> in the skeleton.</p>
<p>First, define an empty interrupt handling routine named
<code class="xref c c-func docutils literal"><span class="pre">kbd_interrupt_handler()</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Since we already have a driver that uses this interrupt we
should report the interrupt as not handled (i.e. return
<code class="xref c c-type docutils literal"><span class="pre">IRQ_NONE</span></code>) so that the original driver still has a
chance to process it.</p>
</div>
<p>Then register the interrupt handler routine using
<code class="xref c c-type docutils literal"><span class="pre">request_irq</span></code>. The interrupt number is defined by the
<cite>I8042_KBD_IRQ</cite> macro. The interrupt handling routine must be
requested with <code class="xref c c-type docutils literal"><span class="pre">IRQF_SHARED</span></code> to share the interrupt line with
the keyboard driver (i8042).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For shared interrupts, <em>dev_id</em> can not be NULL . Use
<code class="docutils literal"><span class="pre">&amp;devs[0]</span></code>, that is pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code>. This
structure contains all the information needed for device
management. To see the interrupt in <em>/proc/interrupts</em>, do
not use NULL for <em>dev_name</em> . You can use the MODULE_NAME
macro.</p>
<p class="last">If the interrupt requesting fails make sure to properly
cleanup by jumping to the right label, in this case the one
the releases the I/O ports and continues with unregistering
the character device driver.</p>
</div>
<p>Compile, copy and load module in the kernel. Check that the interrupt
line has been registered by looking at <em>/proc/interrupts</em> . Determine
the IRQ number from the source code (see <cite>I8042_KBD_IRQ</cite>) and verify
that there are two drivers registered at this interrupt line (which
means that we have a shared interrupt line): the i8042 initial driver
and our driver.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">More details about the format of the <em>/proc/interrupts</em> can
be found in the <a class="reference internal" href="#interrupt-statistics">Interrupt statistics</a> section.</p>
</div>
<p>Print a message inside the routine to make sure it is called. Compile
and reload the module into the kernel. Check that the interrupt handling
routine is called when you press the keyboard on the virtual machine,
using <strong class="command">dmesg</strong>. Also note that when you use the serial port no
keyboard interrupt is generated.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">To get access to the keyboard on the virtual machine
boot with &quot;QEMU_DISPLAY=gtk make boot&quot;.</p>
</div>
</div>
<div class="section" id="store-ascii-keys-to-buffer">
<h3>3. Store ASCII keys to buffer<a class="headerlink" href="#store-ascii-keys-to-buffer" title="Permalink to this headline">¶</a></h3>
<p>Next, we want to collect the keystrokes in a buffer whose content we
will then send to the user space. For this routine we will add the
following in the interrupt handling:</p>
<ul class="simple">
<li>capture the pressed keys (only pressed, ignore released)</li>
<li>identify the ASCII characters.</li>
<li>copy the ASCII characters corresponding to the keystrokes and store
them in the buffer of the device</li>
</ul>
<p>Follow the sections marked <strong>TODO 3</strong> in the skeleton.</p>
<div class="section" id="reading-the-data-register">
<h4>Reading the data register<a class="headerlink" href="#reading-the-data-register" title="Permalink to this headline">¶</a></h4>
<p>First, fill in the <code class="xref c c-func docutils literal"><span class="pre">i8042_read_data()</span></code> function to read the
<code class="docutils literal"><span class="pre">I8042_DATA_REG</span></code> of the keyboard controller. The function
just needs to return the value of the register. The value of the
registry is also called scancode, which is what is generated at each
keystroke.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Read the <code class="docutils literal"><span class="pre">I8042_DATA_REG</span></code> register using <code class="xref c c-func docutils literal"><span class="pre">inb()</span></code> and
store the value in the local variable <code class="xref c c-type docutils literal"><span class="pre">val</span></code>.
Revisit the <a class="reference internal" href="#accessing-i-o-ports">Accessing I/O ports</a> section.</p>
</div>
<p>Call the <code class="xref c c-func docutils literal"><span class="pre">i8042_read_data()</span></code> in the
<code class="xref c c-func docutils literal"><span class="pre">kbd_interrupt_handler()</span></code> and print the value read.</p>
<p>Print information about the keystrokes in the following format:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IRQ:% d, scancode = 0x%x (%u,%c)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
   <span class="n">irq_no</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">);</span>
</pre></div>
</div>
<p>Where scancode is the value of the read register using the
<code class="xref c c-func docutils literal"><span class="pre">i8042_read_data()</span></code> function.</p>
<p>Notice that the scancode (reading of the read register) is not an ASCII
character of the pressed key. We'll have to understand the scancode.</p>
</div>
<div class="section" id="interpreting-the-scancode">
<h4>Interpreting the scancode<a class="headerlink" href="#interpreting-the-scancode" title="Permalink to this headline">¶</a></h4>
<p>Note that the registry value is a scancode, not the ASCII value of the
character pressed. Also note that an interrupt is sent both when the
key is pressed and when the key is released. We only need to select
the code when the key is pressed and then and decode the ASCII
character.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To check scancode, we can use the showkey command (showkey
-s).</p>
<p>In this form, the command will display the key scancodes for
10 seconds after the last pressed key end then it will
stop. If you press and release a key you will get two
scancodes: one for the pressed key and one for the released
key. E.g:</p>
<ul class="last">
<li><p class="first">If you press the ENTER key, you will get the 0x1c ( 0x1c )
and 0x9c (for the released key)</p>
</li>
<li><p class="first">If you press the key a you will get the 0x1e (key pressed)
and 0x9e (for the key release)</p>
</li>
<li><p class="first">If you press b you will get 0x30 (key pressed) and 0xb0
(for the release key)</p>
</li>
<li><p class="first">If you press the c key, you will get the 0x2e (key
pressed) 0xae and 0xae (for the released key)</p>
</li>
<li><p class="first">If you press the Shift key you will get the 0x2a (key
pressed) 0xaa and 0xaa (for the released key)</p>
</li>
<li><p class="first">If you press the Ctrl key you will get the 0x1d (key
pressed) and 0x9d (for the release key)</p>
<p>As also indicated in this <a class="reference external" href="http://www.linuxjournal.com/article/1080">article</a>, a key
release scancode is 128 (0x80) higher then a key press
scancode. This is how we can distinguish between a press
key scancode and a release scancode.</p>
<p>A scancode is translated into a keycode that matches a
key. A pressed scanned keycode and a released scancode
have the same keycode. For the keys shown above we have
the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Key</td>
<td>Key Press Scancode</td>
<td>Key Release Scancode</td>
<td>Keycode</td>
</tr>
<tr class="row-even"><td>ENTER</td>
<td>0x1c</td>
<td>0x9c</td>
<td>0x1c (28)</td>
</tr>
<tr class="row-odd"><td>a</td>
<td>0x1e</td>
<td>0x9e</td>
<td>0x1e (30)</td>
</tr>
<tr class="row-even"><td>b</td>
<td>0x30</td>
<td>0xb0</td>
<td>0x30 (48)</td>
</tr>
<tr class="row-odd"><td>c</td>
<td>0x2e</td>
<td>0xae</td>
<td>0x2e (46)</td>
</tr>
<tr class="row-even"><td>Shift</td>
<td>0x2a</td>
<td>0xaa</td>
<td>0x2a (42)</td>
</tr>
<tr class="row-odd"><td>Ctrl</td>
<td>0x1d</td>
<td>0x9d</td>
<td>0x1d (29)</td>
</tr>
</tbody>
</table>
<p>The press / release key is performed in the is_key_press()
function and obtaining the ASCII character of a scancode
takes place in the get_ascii() function.</p>
</li>
</ul>
</div>
<p>In the interrupt handler check the scancode to see if the key is
pressed or released then determine the corresponding ASCII
character.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To check for press / release, use <code class="xref c c-func docutils literal"><span class="pre">is_key_press()</span></code>.
Use <code class="xref c c-func docutils literal"><span class="pre">get_ascii()</span></code> function to get the corresponding
ASCII code. Both functions expect the scancode.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>To display the received information use the following
format.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pr_info</span><span class="p">(</span><span class="s">&quot;IRQ %d: scancode=0x%x (%u) pressed=%d ch=%c</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
        <span class="n">irq_no</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">scancode</span><span class="p">,</span> <span class="n">pressed</span><span class="p">,</span> <span class="n">ch</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">Where scancode is the value of the data register, and ch is
the value returned by the get_ascii() function.</p>
</div>
</div>
<div class="section" id="store-characters-to-the-buffer">
<h4>Store characters to the buffer<a class="headerlink" href="#store-characters-to-the-buffer" title="Permalink to this headline">¶</a></h4>
<p>We want to collect the pressed characters (not the other keys) into
a circular buffer that can be consumed from user space.</p>
<p>Update the interrupt handler to add a pressed ASCII character to the
end of the device buffer. If the buffer is full, the character will be
discarded.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>The device buffer is the field <code class="xref c c-type docutils literal"><span class="pre">buf</span></code> in the device's
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code>. To get the device data from the interrupt handler
use the following construct:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kbd</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kbd</span> <span class="o">*</span><span class="p">)</span> <span class="n">dev_id</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">The buffer's dimension is located in <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code>'s field,
<code class="xref c c-type docutils literal"><span class="pre">count</span></code>. The <code class="xref c c-type docutils literal"><span class="pre">put_idx</span></code> and <code class="xref c c-type docutils literal"><span class="pre">get_idx</span></code> fields
specify the next writing and reading index. Take a look at the
<code class="xref c c-func docutils literal"><span class="pre">put_char()</span></code> function's implementation to observe how the data is
added to the circular buffer.</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>Synchronize the access to the buffer and the helper
indexes with a spinlock.
Define the spinlock in the device struct <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kbd</span></code>
and initialize it in <code class="xref c c-func docutils literal"><span class="pre">kbd_init()</span></code>.</p>
<p>Use the <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> functions
to protect the buffer in the interrupt handler.</p>
<p class="last">Revisit the <a class="reference internal" href="#locking">Locking</a> section.</p>
</div>
</div>
</div>
<div class="section" id="reading-the-buffer">
<h3>4. Reading the buffer<a class="headerlink" href="#reading-the-buffer" title="Permalink to this headline">¶</a></h3>
<p>In order to have access to the keylogger's data, we have to send it to
the user space. We will do this using the <em>/dev/kbd</em> character device. When
reading from this device, we will get the data from the buffer in the kernel
space, where we collected the keys pressed.</p>
<p>For this step
follow the sections marked with <strong>TODO 4</strong> in the <code class="xref c c-func docutils literal"><span class="pre">kbd_read()</span></code> function.</p>
<p>Implement <code class="xref c c-func docutils literal"><span class="pre">get_char()</span></code> in a similar way to <code class="xref c c-func docutils literal"><span class="pre">put_char()</span></code>. Be careful
when implementing the circular buffer.</p>
<p>In the <code class="xref c c-func docutils literal"><span class="pre">kbd_read()</span></code> function copy the data from the buffer to the
userspace buffer.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use <code class="xref c c-func docutils literal"><span class="pre">get_char()</span></code> to read a character from the buffer
and <code class="xref c c-func docutils literal"><span class="pre">put_user()</span></code> to store it to the user buffer.</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>In the read function, use <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> for locking.</p>
<p class="last">Revisit the <a class="reference internal" href="#locking">Locking</a> section.</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>We cannot use <code class="xref c c-func docutils literal"><span class="pre">put_user()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">copy_to_user()</span></code>
while holding the lock, as userpace access is not permitted from
atomic contexts.</p>
<p class="last">For more info, read the <span class="xref std std-ref">Access to the address space of the
process section</span> in the
previous lab.</p>
</div>
<p>For testing, you will need to create the <em>/dev/kbd</em> character device
driver using the mknod before reading from it. The device master and
minor are defined as <code class="docutils literal"><span class="pre">KBD_MAJOR</span></code> and <code class="docutils literal"><span class="pre">KBD_MINOR</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mknod</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span> <span class="n">c</span> <span class="mi">42</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Build, copy and boot the virtual machine and load the module. Test it
using the command:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span>
</pre></div>
</div>
</div>
<div class="section" id="reset-the-buffer">
<h3>5. Reset the buffer<a class="headerlink" href="#reset-the-buffer" title="Permalink to this headline">¶</a></h3>
<p>Reset the buffer if the device is written to. For this step follow the
sections marked with <strong>TODO 5</strong> in the skeleton.</p>
<p>Implement <code class="xref c c-func docutils literal"><span class="pre">reset_buffer()</span></code> and add the write operation to <em>kbd_fops</em>.</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>In the write function Use <code class="xref c c-func docutils literal"><span class="pre">spin_lock_irqsave()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">spin_unlock_irqrestore()</span></code> for locking when resetting the
buffer.</p>
<p class="last">Revisit the <a class="reference internal" href="#locking">Locking</a> section.</p>
</div>
<p>For testing, you will need to create the <em>/dev/kbd</em> character device
driver using the mknod before reading from it. The device master and
minor are defined as <code class="docutils literal"><span class="pre">KBD_MAJOR</span></code> and <code class="docutils literal"><span class="pre">KBD_MINOR</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mknod</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span> <span class="n">c</span> <span class="mi">42</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Build, copy and boot the virtual machine and load the module.
Test it using the command:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">cat</span> <span class="o">/</span><span class="n">dev</span><span class="o">/</span><span class="n">kbd</span>
</pre></div>
</div>
<p>Press some keys, then run the command <strong class="command">echo &quot;clear&quot; &gt; /dev/kbd</strong>.
Check the buffer's content again. It should be reset.</p>
</div>
</div>
<div class="section" id="extra-exercises">
<h2>Extra Exercises<a class="headerlink" href="#extra-exercises" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kfifo">
<h3>1. kfifo<a class="headerlink" href="#kfifo" title="Permalink to this headline">¶</a></h3>
<p>Implement a keylogger using the
<a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/include/linux/kfifo.h">kfifo API</a>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Follow the <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/samples/kfifo">API call examples from the kernel code</a>.
For example, the file <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/samples/kfifo/bytestream-example.c">bytestream-examples.c</a>.</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab3-device-drivers.html" class="btn btn-neutral float-left" title="SO2 Lab 03 - Character device drivers" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab5-deferred-work.html" class="btn btn-neutral float-right" title="SO2 Lab 05 - Deferred work" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>