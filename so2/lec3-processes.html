<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 课程 03——进程 &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="SO2 课程 04——中断" href="lec4-interrupts.html" />
    <link rel="prev" title="SO2 课程 02——系统调用" href="lec2-syscalls.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">操作系统 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01——课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 课程 02——系统调用</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 课程 03——进程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">课程目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">进程和线程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-3">进程资源概述</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-task-struct"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#task-struct">检查 task_struct</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-4">测验：查看任务以确定打开的文件</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-5">线程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-6">克隆系统调用</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-7">命名空间和“容器”</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-8">访问当前进程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#current-x86">测验：current 宏的先前实现（x86）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-9">上下文切换</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-10">测验：上下文切换</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-11">阻塞和唤醒任务</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-12">任务状态</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-13">阻塞当前线程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-14">唤醒任务</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-15">任务抢占</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-16">非抢占式内核</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-17">抢占式内核</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-18">进程上下文</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-19">内核线程</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#gdb">使用 gdb 脚本进行内核检查</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gdb-1">测验：内核 gdb 脚本</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 课程 04——中断</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 课程 05——对称多处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 课程 06——地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 课程 07——内存管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 课程 08——文件系统管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 课程 09——内核调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 课程 10——网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 课程 11——体系结构层</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 课程 12——虚拟化</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 实验 01——介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 实验 02——内核 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 实验 03——字符设备驱动</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 实验 04——I/O 访问和中断</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 实验 05——延迟工作</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 实验 06——内存映射</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 实验 07——块设备驱动</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 实验 08——文件系统驱动（第一部分）</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 实验 09——文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 实验 10——网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 实验 11——ARM 内核开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 实验 12——内核分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">合作</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">作业 0——内核 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">作业 1——基于 Kprobe 的跟踪器</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">作业 2——驱动 UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">体系结构层</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">虚拟化</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">操作系统 2</a></li>
      <li class="breadcrumb-item active">SO2 课程 03——进程</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lec3-processes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-03">
<h1>SO2 课程 03——进程<a class="headerlink" href="#so2-03" title="永久链接至标题">¶</a></h1>
<p><a class="reference external" href="lec3-processes-slides.html">查看幻灯片</a></p>
<span class="admonition-so2-03"></span><div class="section" id="section-1">
<h2>课程目标<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h2>
<ul class="admonition- simple">
<li>进程和线程</li>
<li>上下文切换</li>
<li>阻塞和唤醒</li>
<li>进程上下文</li>
</ul>
</div>
<div class="section" id="section-2">
<h2>进程和线程<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<p>进程是操作系统的抽象概念，用于组织多个资源：</p>
<table class="hlist"><tr><td><ul class="simple">
<li>地址空间</li>
<li>一个或多个线程</li>
<li>打开的文件</li>
<li>套接字（Socket）</li>
<li>信号量（semaphore）</li>
</ul>
</td><td><ul class="simple">
<li>共享内存区域</li>
<li>定时器</li>
<li>信号处理程序</li>
<li>许多其他资源和状态信息</li>
</ul>
</td></tr></table>
<p>所有这些信息都被组织在进程控制块（PCB）中。在 Linux 中，PCB 对应的结构体是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>。</p>
<div class="section" id="section-3">
<h3>进程资源概述<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h3>
<p>我们可以在 <cite>/proc/&lt;pid&gt;</cite> 目录中获取关于进程资源的摘要信息，其中 <cite>&lt;pid&gt;</cite> 是我们要查看的进程的进程 ID。</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>                +-------------------------------------------------------------------+
                | dr-x------    2 tavi tavi 0  2021 03 14 12:34 .                   |
                | dr-xr-xr-x    6 tavi tavi 0  2021 03 14 12:34 ..                  |
                | lrwx------    1 tavi tavi 64 2021 03 14 12:34 0 -&gt; /dev/pts/4     |
           +---&gt;| lrwx------    1 tavi tavi 64 2021 03 14 12:34 1 -&gt; /dev/pts/4     |
           |    | lrwx------    1 tavi tavi 64 2021 03 14 12:34 2 -&gt; /dev/pts/4     |
           |    | lr-x------    1 tavi tavi 64 2021 03 14 12:34 3 -&gt; /proc/18312/fd |
           |    +-------------------------------------------------------------------+
           |                 +----------------------------------------------------------------+
           |                 | 08048000-0804c000 r-xp 00000000 08:02 16875609 /bin/cat        |
$ ls -1 /proc/self/          | 0804c000-0804d000 rw-p 00003000 08:02 16875609 /bin/cat        |
cmdline    |                 | 0804d000-0806e000 rw-p 0804d000 00:00 0 [heap]                 |
cwd        |                 | ...                                                            |
environ    |    +-----------&gt;| b7f46000-b7f49000 rw-p b7f46000 00:00 0                        |
exe        |    |            | b7f59000-b7f5b000 rw-p b7f59000 00:00 0                        |
fd --------+    |            | b7f5b000-b7f77000 r-xp 00000000 08:02 11601524 /lib/ld-2.7.so  |
fdinfo          |            | b7f77000-b7f79000 rw-p 0001b000 08:02 11601524 /lib/ld-2.7.so  |
maps -----------+            | bfa05000-bfa1a000 rw-p bffeb000 00:00 0 [stack]                |
mem                          | ffffe000-fffff000 r-xp 00000000 00:00 0 [vdso]                 |
root                         +----------------------------------------------------------------+
stat                 +----------------------------+
statm                |  Name: cat                 |
status ------+       |  State: R (running)        |
task         |       |  Tgid: 18205               |
wchan        +------&gt;|  Pid: 18205                |
                     |  PPid: 18133               |
                     |  Uid: 1000 1000 1000 1000  |
                     |  Gid: 1000 1000 1000 1000  |
                     +----------------------------+
</pre></div>
</div>
</div>
<div class="section" id="struct-task-struct">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code><a class="headerlink" href="#struct-task-struct" title="永久链接至标题">¶</a></h3>
<p>让我们仔细分析 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>。为此，我们可以查看源代码，但在这里我们将使用一个名为 <cite>pahole</cite> 的工具（它是 dwarves 安装包的一部分），来获取有关这个结构的一些见解：</p>
<div class="admonition-struct-task-struct highlight-c"><div class="highlight"><pre><span></span>$ pahole -C task_struct vmlinux

struct task_struct {
    struct thread_info thread_info;                  /*     0     8 */
    volatile long int          state;                /*     8     4 */
    void *                     stack;                /*    12     4 */

    ...

    /* --- cacheline 45 boundary (2880 bytes) --- */
    struct thread_struct thread __attribute__((__aligned__(64))); /*  2880  4288 */

    /* size: 7168, cachelines: 112, members: 155 */
    /* sum members: 7148, holes: 2, sum holes: 12 */
    /* sum bitfield members: 7 bits, bit holes: 2, sum bit holes: 57 bits */
    /* paddings: 1, sum paddings: 2 */
    /* forced alignments: 6, forced holes: 2, sum forced holes: 12 */
} __attribute__((__aligned__(64)));
</pre></div>
</div>
<p>可以看出，这是一个相当大的数据结构：大小接近 8KB，具有 155 个字段（field）。</p>
</div>
<div class="section" id="task-struct">
<h3>检查 task_struct<a class="headerlink" href="#task-struct" title="永久链接至标题">¶</a></h3>
<p>以下屏幕录像（screencast）将演示如何通过连接调试器到正在运行的虚拟机来检查进程控制块（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>）。我们将使用辅助的 gdb 命令 <cite>lx-ps</cite> 来列出进程以及每个进程的 task_struct 地址。</p>
<p class="admonition-inspecting-task-struct">&nbsp;</p>
<asciinema-player src="../_images/inspect_task_struct.cast"></asciinema-player></div>
<div class="section" id="section-4">
<h3>测验：查看任务以确定打开的文件<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h3>
<p class="admonition-">使用调试器来检查名为 syslogd 的进程。</p>
<ul class="simple">
<li>我们应该使用什么命令列出已打开的文件描述符？</li>
<li>有多少个文件描述符已打开？</li>
<li>我们应该使用什么命令来确定打开文件描述符 3 的文件名？</li>
<li>文件描述符 3 的文件名是什么？</li>
</ul>
</div>
<div class="section" id="section-5">
<h3>线程<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h3>
<p>线程是内核进程调度器允许应用程序在 CPU 上运行的基本单位。线程具有以下特点：</p>
<ul class="admonition- simple">
<li>每个线程都拥有独立的堆栈，这个堆栈与线程的寄存器的值共同决定了线程的运行状态</li>
<li>线程在进程的上下文中运行，同一进程中的所有线程共享资源</li>
<li>内核调度的是线程而不是进程，用户级线程（例如纤程（fiber）、协程（coroutine）等）在内核级别不可见</li>
</ul>
<p>典型的线程实现是将线程实现为单独的数据结构，然后将其链接到进程数据结构。例如，Windows 内核就使用了这样的实现方式：</p>
<p class="admonition-windows">&nbsp;</p>
<img alt="../_images/ditaa-4b5c1874d3924d9716f26d4893a3e4f313bf1c43.png" src="../_images/ditaa-4b5c1874d3924d9716f26d4893a3e4f313bf1c43.png" />
<p>Linux 采用了不同的线程实现方式。其基本单位被称为“任务”（task）（因此其结构类型名为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> ），它既可以用于任务也可以用于进程。与将资源直接嵌入到任务结构体中的典型实现不同，它包含了指向这些资源的指针。</p>
<p>因此，如果两个线程属于同一个进程，它们将指向相同的资源结构体实例。如果两个线程属于不同进程，它们将指向不同的资源结构体实例。</p>
<p class="admonition-linux">&nbsp;</p>
<img alt="../_images/ditaa-fd771038e88b95def30ae9bd4df0b7bd6b7b3503.png" src="../_images/ditaa-fd771038e88b95def30ae9bd4df0b7bd6b7b3503.png" />
</div>
<div class="section" id="section-6">
<h3>克隆系统调用<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h3>
<p>在 Linux 中，使用 <code class="xref c c-func docutils literal"><span class="pre">clone()</span></code> 系统调用可以创建新的线程或进程。无论是 <code class="xref c c-func docutils literal"><span class="pre">fork()</span></code> 系统调用，还是 <code class="xref c c-func docutils literal"><span class="pre">pthread_create()</span></code> 函数都使用了 <code class="xref c c-func docutils literal"><span class="pre">clone()</span></code> 系统调用来实现。</p>
<p>它允许调用者决定与父进程共享哪些资源，以及哪些资源应该被复制或隔离：</p>
<ul class="admonition- simple">
<li>CLONE_FILES——与父进程共享文件描述符表</li>
<li>CLONE_VM——与父进程共享地址空间</li>
<li>CLONE_FS——与父进程共享文件系统信息（根目录，当前目录）</li>
<li>CLONE_NEWNS——不与父进程共享挂载命名空间（mount namespace）</li>
<li>CLONE_NEWIPC——不与父进程共享 IPC 命名空间（System V IPC 对象，POSIX 消息队列）</li>
<li>CLONE_NEWNET——不与父进程共享网络命名空间（网络接口，路由表）</li>
</ul>
<p>例如，如果调用者使用了 <cite>CLONE_FILES | CLONE_VM | CLONE_FS</cite>，则实际上创建了一个新的线程。如果未使用这些标志，则创建了一个新的进程。</p>
</div>
<div class="section" id="section-7">
<h3>命名空间和“容器”<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h3>
<p>“容器”是一种轻量级虚拟机，它们共享相同的内核实例。这与正常的虚拟化相反，在正常的虚拟化中，一个虚拟机监视程序（hypervisor）运行多个虚拟机，每个虚拟机都有自己的内核实例。</p>
<p>容器技术的例子包括 LXC（允许运行轻量级的“虚拟机”）和 Docker（一种专门用于运行单个应用程序的容器）。</p>
<p>容器是建立在一些内核特性之上的，其中之一就是命名空间（namespace）。内核空间技术允许隔离不同的资源，如果不隔离的话这些资源将在全局可见。例如，如果没有容器，所有进程都将在 /proc 中可见。有了容器后，一个容器中的进程对其他容器来说是不可见的（在 /proc 中不可见，也不能被终止）。</p>
<p>为了实现这种分区，容器技术使用了 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nsproxy</span></code> 结构来分组我们想要分区的资源类型。它目前支持 IPC、网络、cgroup、挂载、PID、时间命名空间。例如，我们不再使用全局的网络接口列表，而是选择将网络接口列表作为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">net</span></code> 结构的一部分。在系统初始化时，会创建一个默认的命名空间，名为 <code class="xref c c-data docutils literal"><span class="pre">init_net</span></code>。默认情况下，所有的进程都会共享这个命名空间。但是，当我们创建一个新的命名空间时，系统会相应地创建一个新的网络命名空间。这样，新的进程就可以选择指向这个新创建的命名空间，而不是默认的命名空间。</p>
<span class="admonition-"></span></div>
<div class="section" id="section-8">
<h3>访问当前进程<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p class="admonition-">访问当前进程是一个频繁的操作：</p>
<ul class="simple">
<li>打开文件需要访问 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的 file 字段</li>
<li>映射新文件需要访问 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的 mm 字段</li>
<li>超过 90% 的系统调用需要访问当前进程结构体，因此访问需要很快</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 宏可用于访问当前进程的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code></li>
</ul>
<p>为了在多处理器配置中实现快速访问，每个 CPU 中都有一个共同的变量，这个变量可用来存储和检索指向当前 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的指针：</p>
<p class="admonition-x86">&nbsp;</p>
<img alt="../_images/ditaa-019489e686a2f60f1594e37458cfcb10320eae0f.png" src="../_images/ditaa-019489e686a2f60f1594e37458cfcb10320eae0f.png" />
<p>以前，<code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 宏使用以下序列实现：</p>
<div class="admonition-current-x86 highlight-c"><div class="highlight"><pre><span></span>/* 如何用 C 语言获取当前堆栈指针 */
register unsigned long current_stack_pointer asm(&quot;esp&quot;) __attribute_used__;

/* 如何用 C 语言获取线程信息结构体 */
static inline struct thread_info *current_thread_info(void)
{
   return (struct thread_info *)(current_stack_pointer &amp; ~(THREAD_SIZE – 1));
}

#define current current_thread_info()-&gt;task
</pre></div>
</div>
</div>
<div class="section" id="current-x86">
<h3>测验：current 宏的先前实现（x86）<a class="headerlink" href="#current-x86" title="永久链接至标题">¶</a></h3>
<p class="admonition-quiz-current-x86">结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">thread_info</span></code> 的大小是多少？</p>
<p>下列哪个是可能的有效大小：4095、4096、4097？</p>
</div>
</div>
<div class="section" id="section-9">
<h2>上下文切换<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h2>
<p>以下图表展示了 Linux 内核上下文切换过程的概述：</p>
<img alt="../_images/ditaa-f6b228332baf165f498d8a1bb0bc0bdb91ae50c5.png" class="admonition-" src="../_images/ditaa-f6b228332baf165f498d8a1bb0bc0bdb91ae50c5.png" />
<p>请注意，在发生上下文切换之前，我们必须进行内核转换，这可以通过系统调用或中断来实现。此时，用户空间的寄存器会保存在内核堆栈上。在某个时刻，可能会调用 <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> 函数，该函数决定从线程 T0 切换到线程 T1（例如，因为当前线程正在阻塞等待 I/O 操作完成，或者因为它的时间片已经耗尽）。</p>
<p>此时，<code class="xref c c-func docutils literal"><span class="pre">context_switch()</span></code> 函数将执行特定于体系结构的操作，并在需要时切换地址空间：</p>
<div class="admonition-context-switch highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span>
<span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
         <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">prepare_task_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * paravirt 中，这与 switch_to 中的 exit 配对，</span>
<span class="cm">     * 将页表重载和后端切换合并为一个超级调用（hypercall）。</span>
<span class="cm">     */</span>
    <span class="n">arch_start_context_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="cm">/*</span>
<span class="cm">     * kernel -&gt; kernel   lazy + transfer active</span>
<span class="cm">     *   user -&gt; kernel   lazy + mmgrab() active</span>
<span class="cm">     *</span>
<span class="cm">     * kernel -&gt;   user   switch + mmdrop() active</span>
<span class="cm">     *   user -&gt;   user   switch</span>
<span class="cm">     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                                <span class="c1">// 到内核</span>
        <span class="n">enter_lazy_tlb</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>                           <span class="c1">// 来自用户</span>
            <span class="n">mmgrab</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="c1">// 到用户</span>
        <span class="n">membarrier_switch_mm</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="cm">/*</span>
<span class="cm">         * sys_membarrier() 在设置 rq-&gt;curr / membarrier_switch_mm() 和返回用户空间之间需要一个 smp_mb()。</span>
<span class="cm">         *</span>
<span class="cm">         * 下面通过 switch_mm() 或者在 &#39;prev-&gt;active_mm == next-&gt;mm&#39; 的情况下通过 finish_task_switch() 的 mmdrop() 来提供这个功能。</span>
<span class="cm">         */</span>
        <span class="n">switch_mm_irqs_off</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                        <span class="c1">// 来自内核</span>
            <span class="cm">/* 在 finish_task_switch() 中进行 mmdrop()。 */</span>
            <span class="n">rq</span><span class="o">-&gt;</span><span class="n">prev_mm</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">;</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_update_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">RQCF_ACT_SKIP</span><span class="o">|</span><span class="n">RQCF_REQ_SKIP</span><span class="p">);</span>

    <span class="n">prepare_lock_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">rf</span><span class="p">);</span>

    <span class="cm">/* 在这里我们只切换寄存器状态和堆栈。 */</span>
    <span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="n">barrier</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>它将调用特定于架构的 <code class="xref c c-macro docutils literal"><span class="pre">switch_to</span></code> 宏实现来切换寄存器状态和内核堆栈。请注意，寄存器被保存在堆栈上，并且堆栈指针被保存在任务结构体中：</p>
<div class="admonition-switch-to highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define switch_to(prev, next, last)               \</span>
<span class="cp">do {                                              \</span>
<span class="cp">    ((last) = __switch_to_asm((prev), (next)));   \</span>
<span class="cp">} while (0)</span>


<span class="cm">/*</span>
<span class="cm"> * %eax: prev task</span>
<span class="cm"> * %edx: next task</span>
<span class="cm"> */</span>
<span class="p">.</span><span class="n">pushsection</span> <span class="p">.</span><span class="n">text</span><span class="p">,</span> <span class="s">&quot;ax&quot;</span>
<span class="n">SYM_CODE_START</span><span class="p">(</span><span class="n">__switch_to_asm</span><span class="p">)</span>
    <span class="cm">/*</span>
<span class="cm">     * 保存被调用者保存的寄存器</span>
<span class="cm">     * 其必须与 struct inactive_task_frame 中的顺序匹配</span>
<span class="cm">     */</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebp</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">ebx</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">edi</span>
    <span class="n">pushl</span>   <span class="o">%</span><span class="n">esi</span>
    <span class="cm">/*</span>
<span class="cm">     * 保存标志位以防止 AC 泄漏。如果 objtool 支持 32 位，则可以消除此项需求，以验证 STAC/CLAC 的正确性。</span>
<span class="cm">     */</span>
    <span class="n">pushfl</span>

<span class="hll">    <span class="cm">/* 切换堆栈 */</span>
</span><span class="hll">    <span class="n">movl</span>    <span class="o">%</span><span class="n">esp</span><span class="p">,</span> <span class="n">TASK_threadsp</span><span class="p">(</span><span class="o">%</span><span class="n">eax</span><span class="p">)</span>
</span><span class="hll">    <span class="n">movl</span>    <span class="n">TASK_threadsp</span><span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">esp</span>
</span>
  <span class="cp">#ifdef CONFIG_STACKPROTECTOR</span>
    <span class="n">movl</span>    <span class="n">TASK_stack_canary</span><span class="p">(</span><span class="o">%</span><span class="n">edx</span><span class="p">),</span> <span class="o">%</span><span class="n">ebx</span>
    <span class="n">movl</span>    <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="n">PER_CPU_VAR</span><span class="p">(</span><span class="n">stack_canary</span><span class="p">)</span><span class="o">+</span><span class="n">stack_canary_offset</span>
  <span class="cp">#endif</span>

  <span class="cp">#ifdef CONFIG_RETPOLINE</span>
    <span class="cm">/*</span>
<span class="cm">     * 当从较浅的调用堆栈切换到较深的堆栈时，RSB 可能会下溢或使用填充有用户空间地址的条目。</span>
<span class="cm">     * 在存在这些问题的 CPU 上，用捕获推测执行的条目覆盖 RSB，以防止攻击。</span>
<span class="cm">     */</span>
    <span class="n">FILL_RETURN_BUFFER</span> <span class="o">%</span><span class="n">ebx</span><span class="p">,</span> <span class="n">RSB_CLEAR_LOOPS</span><span class="p">,</span> <span class="n">X86_FEATURE_RSB_CTXSW</span>
    <span class="cp">#endif</span>

    <span class="cm">/* 恢复任务的标志位以恢复 AC 状态。 */</span>
    <span class="n">popfl</span>
    <span class="cm">/* 恢复被调用者保存的寄存器 */</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">esi</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">edi</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">ebx</span>
    <span class="n">popl</span>    <span class="o">%</span><span class="n">ebp</span>

<span class="hll">    <span class="n">jmp</span>     <span class="n">__switch_to</span>
</span>  <span class="n">SYM_CODE_END</span><span class="p">(</span><span class="n">__switch_to_asm</span><span class="p">)</span>
  <span class="p">.</span><span class="n">popsection</span>
</pre></div>
</div>
<p>可以注意到指令指针并没有显式保存。这是因为：</p>
<blockquote>
<div><ul class="simple">
<li>任务将始终在此函数中恢复执行</li>
<li><code class="xref c c-func docutils literal"><span class="pre">schedule`（:c:func:`context_switch()</span></code> 总是被内联）调用者的返回地址保存在内核堆栈上</li>
<li>使用 jmp 执行 <code class="xref c c-func docutils literal"><span class="pre">__switch_to()</span></code>，它是一个函数，当函数返回时，它将从堆栈中弹出原始的（下一个任务的）返回地址</li>
</ul>
</div></blockquote>
<p>以下屏幕录像使用调试器在 __switch_to_asm 中设置断点，并在上下文切换期间检查堆栈：</p>
<p class="admonition-task-struct">&nbsp;</p>
<asciinema-player src="../_images/context_switch.cast"></asciinema-player><div class="section" id="section-10">
<h3>测验：上下文切换<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h3>
<p class="admonition-">假设我们正在执行上下文切换，请选择所有正确的陈述。</p>
<ul class="simple">
<li>ESP 寄存器被保存在 task 结构中</li>
<li>EIP 寄存器被保存在 task 结构中</li>
<li>通用寄存器被保存在 task 结构中</li>
<li>ESP 寄存器被保存在堆栈中</li>
<li>EIP 寄存器被保存在堆栈中</li>
<li>通用寄存器被保存在堆栈中</li>
</ul>
</div>
</div>
<div class="section" id="section-11">
<h2>阻塞和唤醒任务<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h2>
<div class="section" id="section-12">
<h3>任务状态<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h3>
<p>以下图表显示了任务（线程）的状态及其之间可能的转换：</p>
<img alt="../_images/ditaa-54b40ea6fbe752f6485ac3d42063a1ec47a2ef69.png" class="admonition-" src="../_images/ditaa-54b40ea6fbe752f6485ac3d42063a1ec47a2ef69.png" />
</div>
<div class="section" id="section-13">
<h3>阻塞当前线程<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h3>
<p>阻塞当前线程是一项重要的操作，我们需要执行它来实现高效的任务调度——我们希望在 I/O 操作完成时运行其他线程。</p>
<p>为了实现这一目标，需要执行以下操作：</p>
<ul class="admonition- simple">
<li>将当前线程状态设置为 TASK_UINTERRUPTIBLE 或 TASK_INTERRUPTIBLE</li>
<li>将任务添加到等待队列中</li>
<li>调用调度程序，从 READY 队列中选择一个新任务</li>
<li>进行上下文切换到新任务</li>
</ul>
<p>以下是对 <code class="xref c c-macro docutils literal"><span class="pre">wait_event</span></code> 的实现的一些代码片段。请注意，等待队列是一个带有额外信息（如指向任务结构体的指针）的列表。</p>
<p>还请注意，为了确保在 <code class="xref c c-macro docutils literal"><span class="pre">wait_event</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">wake_up</span></code> 之间不会发生死锁，任务会在检查 <code class="xref c c-data docutils literal"><span class="pre">condition</span></code> 之前被添加到列表中，并且调用 <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> 之前会进行信号（signal）检查。</p>
<div class="admonition-wait-event highlight-c"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * wait_event——在条件为真之前一直保持睡眠状态</span>
<span class="cm"> * @wq_head: 等待队列</span>
<span class="cm"> * @condition: 用于等待的事件的 C 表达式</span>
<span class="cm"> *</span>
<span class="cm"> * 进程会进入睡眠状态（TASK_UNINTERRUPTIBLE），直到 @condition 为真为止。</span>
<span class="cm"> * 每次唤醒等待队列 @wq_head 时，都会检查 @condition。</span>
<span class="cm"> *</span>
<span class="cm"> * 在更改任何可能改变等待条件结果的变量后，必须调用 wake_up()。</span>
<span class="cm"> */</span>
<span class="cp">#define wait_event(wq_head, condition)            \</span>
<span class="cp">do {                                              \</span>
<span class="cp">  might_sleep();                                  \</span>
<span class="cp">  if (condition)                                  \</span>
<span class="cp">          break;                                  \</span>
<span class="cp">  __wait_event(wq_head, condition);               \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define __wait_event(wq_head, condition)                                  \</span>
<span class="cp">    (void)___wait_event(wq_head, condition, TASK_UNINTERRUPTIBLE, 0, 0,   \</span>
<span class="cp">                        schedule())</span>

<span class="cm">/*</span>
<span class="cm"> * 下面的宏 ___wait_event() 在 wait_event_*() 宏中使用时，有一个显式的 __ret</span>
<span class="cm"> * 变量的影子。</span>
<span class="cm"> *</span>
<span class="cm"> * 这是为了两者都可以使用 ___wait_cond_timeout() 结构来包装条件。</span>
<span class="cm"> *</span>
<span class="cm"> * wait_event_*() 中 __ret 变量的类型不一致也是有意而为的；我们在可以返回超时值的情况下使用 long，否则使用 int。</span>
<span class="cm"> */</span>
<span class="cp">#define ___wait_event(wq_head, condition, state, exclusive, ret, cmd)    \</span>
<span class="cp">({                                                                       \</span>
<span class="cp">    __label__ __out;                                                     \</span>
<span class="cp">    struct wait_queue_entry __wq_entry;                                  \</span>
<span class="cp">    long __ret = ret;       </span><span class="cm">/* 显式影子变量 */</span><span class="cp">                        \</span>
<span class="cp">                                                                         \</span>
<span class="cp">    init_wait_entry(&amp;__wq_entry, exclusive ? WQ_FLAG_EXCLUSIVE : 0);     \</span>
<span class="cp">    for (;;) {                                                           \</span>
<span class="cp">        long __int = prepare_to_wait_event(&amp;wq_head, &amp;__wq_entry, state);\</span>
<span class="cp">                                                                         \</span>
<span class="cp">        if (condition)                                                   \</span>
<span class="cp">            break;                                                       \</span>
<span class="cp">                                                                         \</span>
<span class="cp">        if (___wait_is_interruptible(state) &amp;&amp; __int) {                  \</span>
<span class="cp">            __ret = __int;                                               \</span>
<span class="cp">            goto __out;                                                  \</span>
<span class="cp">        }                                                                \</span>
<span class="cp">                                                                         \</span>
<span class="cp">        cmd;                                                             \</span>
<span class="cp">    }                                                                    \</span>
<span class="cp">    finish_wait(&amp;wq_head, &amp;__wq_entry);                                  \</span>
<span class="cp">   __out:  __ret;                                                        \</span>
<span class="cp"> })</span>

 <span class="kt">void</span> <span class="nf">init_wait_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
 <span class="p">{</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
    <span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">func</span> <span class="o">=</span> <span class="n">autoremove_wake_function</span><span class="p">;</span>
    <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="kt">long</span> <span class="nf">prepare_to_wait_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
     <span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

     <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span> <span class="p">{</span>
      <span class="cm">/*</span>
<span class="cm">      * 如果被唤醒选择的是独占等待者，那么它不能失败，</span>
<span class="cm">      * 它应该“消耗”我们等待的条件。</span>
<span class="cm">      *</span>
<span class="cm">      * 调用者将重新检查条件，并在我们已被唤醒时返回成功，我们不能错过事件，因为唤醒会锁定/解锁相同的 wq_head-&gt;lock。</span>
<span class="cm">      *</span>
<span class="cm">      * 但是我们需要确保在设置条件后+之后的唤醒看不到我们，如果我们失败的话，它应该唤醒另一个独占等待者。</span>
<span class="cm">      */</span>
         <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
         <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
         <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
             <span class="k">if</span> <span class="p">(</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span>
                 <span class="n">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">wq_entry</span><span class="p">);</span>
             <span class="k">else</span>
                 <span class="n">__add_wait_queue</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">wq_entry</span><span class="p">);</span>
         <span class="p">}</span>
         <span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
 <span class="p">}</span>

 <span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__add_wait_queue_entry_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">);</span>
 <span class="p">}</span>

<span class="cm">/**</span>
<span class="cm">* finish_wait - 在队列中等待后进行清理</span>
<span class="cm">* @wq_head: 等待的等待队列头</span>
<span class="cm">* @wq_entry: 等待描述符</span>
<span class="cm">*</span>
<span class="cm">* 将当前线程设置回运行状态，并从给定的等待队列中移除等待描述符（如果仍在队列中）。</span>
<span class="cm">*/</span>
<span class="kt">void</span> <span class="nf">finish_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

   <span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
   <span class="cm">/*</span>
<span class="cm">   * 我们可以在锁之外检查链表是否为空，前提是：</span>
<span class="cm">   *  - 我们使用了“careful”检查，验证了 next 和 prev 指针，以确保没有我们还没有看到的其他 CPU 上可能仍在进行的半完成更新（可能仍会更改堆栈区域）。</span>
<span class="cm">   * 并且</span>
<span class="cm">   *  - 所有其他用户都会获取锁（也就是说，只有一个其他 CPU 可以查看或修改链表）。</span>
<span class="cm">   */</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
      <span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
      <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-14">
<h3>唤醒任务<a class="headerlink" href="#section-14" title="永久链接至标题">¶</a></h3>
<p>我们可以使用 <code class="xref c c-macro docutils literal"><span class="pre">wake_up</span></code> 原语来唤醒任务。唤醒任务需要执行以下高级操作：</p>
<ul class="admonition- simple">
<li>从等待队列中选择一个任务</li>
<li>将任务状态设置为 TASK_READY</li>
<li>将任务插入调度器的 READY 队列中</li>
<li>在 SMP 系统上，这是一个复杂的操作：每个处理器都有自己的队列，队列需要平衡，需要向 CPU 发送信号</li>
</ul>
<div class="admonition-wake-up highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define wake_up(x)                        __wake_up(x, TASK_NORMAL, 1, NULL)</span>

<span class="cm">/**</span>
<span class="cm"> * __wake_up - 唤醒在等待队列上阻塞的线程。</span>
<span class="cm"> * @wq_head: 等待队列</span>
<span class="cm"> * @mode: 哪些线程</span>
<span class="cm"> * @nr_exclusive: 要唤醒的线程数（一次唤醒一个或一次唤醒多个）</span>
<span class="cm"> * @key: 直接传递给唤醒函数</span>
<span class="cm"> *</span>
<span class="cm"> * 如果此函数唤醒了一个任务，则在访问任务状态之前执行完全的内存屏障。</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">__wake_up_common_lock</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__wake_up_common_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
                                  <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
  <span class="n">wait_queue_entry_t</span> <span class="n">bookmark</span><span class="p">;</span>

  <span class="n">bookmark</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">bookmark</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">bookmark</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="p">.</span><span class="n">entry</span><span class="p">);</span>

  <span class="k">do</span> <span class="p">{</span>
          <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
          <span class="n">nr_exclusive</span> <span class="o">=</span> <span class="n">__wake_up_common</span><span class="p">(</span><span class="n">wq_head</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">nr_exclusive</span><span class="p">,</span>
                                          <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bookmark</span><span class="p">);</span>
          <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bookmark</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 核心唤醒函数。非独占唤醒（nr_exclusive == 0）会唤醒所有任务。如果是独占唤醒（nr_exclusive == 一个小正数），则唤醒所有非独占任务和一个独占任务。</span>
<span class="cm"> *</span>
<span class="cm"> * 在某些情况下，我们可能会尝试唤醒已经开始运行但不处于 TASK_RUNNING 状态的任务。在这种（罕见）情况下，try_to_wake_up() 会返回零，我们通过继续扫描队列来处理它。</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wake_up_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_head</span> <span class="o">*</span><span class="n">wq_head</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
                            <span class="kt">int</span> <span class="n">nr_exclusive</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
                            <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">bookmark</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">bookmark</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">list_next_entry</span><span class="p">(</span><span class="n">bookmark</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

          <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
          <span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span>
          <span class="n">curr</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">wait_queue_entry_t</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span>
          <span class="k">return</span> <span class="n">nr_exclusive</span><span class="p">;</span>

  <span class="n">list_for_each_entry_safe_from</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
          <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">)</span>
                  <span class="k">continue</span><span class="p">;</span>

          <span class="n">ret</span> <span class="o">=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">WQ_FLAG_EXCLUSIVE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!--</span><span class="n">nr_exclusive</span><span class="p">)</span>
                  <span class="k">break</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">bookmark</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">++</span><span class="n">cnt</span> <span class="o">&gt;</span> <span class="n">WAITQUEUE_WALK_BREAK_CNT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                  <span class="p">(</span><span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">wq_head</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
                  <span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">WQ_FLAG_BOOKMARK</span><span class="p">;</span>
                  <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bookmark</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>
                  <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">nr_exclusive</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">autoremove_wake_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">wait_queue_entry</span> <span class="o">*</span><span class="n">wq_entry</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">default_wake_function</span><span class="p">(</span><span class="n">wq_entry</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
          <span class="n">list_del_init_careful</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq_entry</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">default_wake_function</span><span class="p">(</span><span class="n">wait_queue_entry_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">,</span>
                          <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_SCHED_DEBUG</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wake_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">WF_SYNC</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">try_to_wake_up</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">wake_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * try_to_wake_up——唤醒线程</span>
<span class="cm"> * @p: 要唤醒的线程</span>
<span class="cm"> * @state: 可以被唤醒的任务状态的掩码</span>
<span class="cm"> * @wake_flags: 唤醒修改标志 (WF_*)</span>
<span class="cm"> *</span>
<span class="cm"> * 概念上执行以下操作：</span>
<span class="cm"> *</span>
<span class="cm"> *   如果 (@state &amp; @p-&gt;state)，则 @p-&gt;state = TASK_RUNNING。</span>
<span class="cm"> *</span>
<span class="cm"> * 如果任务没有放进队列/可运行，还将其放回运行队列。</span>
<span class="cm"> *</span>
<span class="cm"> * 此函数对 schedule() 是原子性的，后者会让该任务出列。</span>
<span class="cm"> *</span>
<span class="cm"> * 在访问 @p-&gt;state 之前，它会触发完整的内存屏障，请参阅 set_current_state() 的注释。</span>
<span class="cm"> *</span>
<span class="cm"> * 使用 p-&gt;pi_lock 来序列化与并发唤醒的操作。</span>
<span class="cm"> *</span>
<span class="cm"> * 依赖于 p-&gt;pi_lock 来稳定下来：</span>
<span class="cm"> *  - p-&gt;sched_class</span>
<span class="cm"> *  - p-&gt;cpus_ptr</span>
<span class="cm"> *  - p-&gt;sched_task_group</span>
<span class="cm"> * 以便进行迁移，请参阅 select_task_rq()/set_task_cpu() 的使用。</span>
<span class="cm"> *</span>
<span class="cm"> * 尽力只获取一个 task_rq(p)-&gt;lock 以提高性能。</span>
<span class="cm"> * 在以下情况下获取 rq-&gt;lock：</span>
<span class="cm"> *  - ttwu_runnable()    -- 旧的 rq，不可避免的，参见该处的注释；</span>
<span class="cm"> *  - ttwu_queue()       -- 新的 rq，用于任务入队；</span>
<span class="cm"> *  - psi_ttwu_dequeue() -- 非常遗憾 :-(，计数将会伤害我们。</span>
<span class="cm"> *</span>
<span class="cm"> * 因此，我们与几乎所有操作都存在竞争。有关详细信息，请参阅许多内存屏障及其注释。</span>
<span class="cm"> *</span>
<span class="cm"> * 返回值：如果 @p-&gt;state 改变（实际进行了唤醒），则为 %true，否则为 %false。</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">try_to_wake_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wake_flags</span><span class="p">)</span>
<span class="p">{</span>
      <span class="p">...</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-15">
<h2>任务抢占<a class="headerlink" href="#section-15" title="永久链接至标题">¶</a></h2>
<p>到目前为止，我们已经讨论了线程之间如何自愿进行上下文切换。接下来，我们将讨论任务抢占的处理方式。我们将从内核配置为非抢占式的简单情况开始，然后再转向抢占式内核的情况。</p>
<div class="section" id="section-16">
<h3>非抢占式内核<a class="headerlink" href="#section-16" title="永久链接至标题">¶</a></h3>
<ul class="admonition- simple">
<li>每个时钟滴答，内核会检查当前进程是否已经用完了它的时间片</li>
<li>如果发生这种情况，会在中断上下文中设置一个标志位</li>
<li>在返回用户空间之前，内核会检查这个标志位，并在需要时调用 <code class="xref c c-func docutils literal"><span class="pre">schedule()</span></code> 函数</li>
<li>在这种情况下，任务在内核模式下运行（例如系统调用）时不会被抢占，因此不存在同步问题</li>
</ul>
</div>
<div class="section" id="section-17">
<h3>抢占式内核<a class="headerlink" href="#section-17" title="永久链接至标题">¶</a></h3>
<p>在这种情况下，即使我们在内核模式下执行系统调用，当前任务也可以被抢占。这需要使用特殊的同步原语：<code class="xref c c-macro docutils literal"><span class="pre">preempt_disable</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">preempt_enable</span></code>。</p>
<p>为了简化抢占式内核的处理，并且由于在 SMP （对称多处理） 情况下需要使用同步原语，当使用自旋锁时会自动禁用抢占。</p>
<p>与之前一样，如果我们遇到需要抢占当前任务的条件（例如时间片用完），会设置一个标志位。每当重新激活抢占时，例如通过 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code> 退出临界区时，会检查这个标志位，并在需要时调用调度器以选择一个新的任务。</p>
<span class="admonition-"></span></div>
</div>
<div class="section" id="section-18">
<h2>进程上下文<a class="headerlink" href="#section-18" title="永久链接至标题">¶</a></h2>
<p>在我们研究了进程和线程（任务）的实现、上下文切换的方式以及如何阻塞、唤醒和抢占任务之后，我们最终可以定义进程上下文及其属性：</p>
<p class="admonition-">当内核执行系统调用时，它处于进程上下文中。</p>
<p>在进程上下文中，存在一个明确定义的上下文，我们可以使用 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 来访问当前进程的数据。</p>
<p>在进程上下文中，我们可以睡眠（等待条件）。</p>
<p>在进程上下文中，我们可以访问用户空间（除非我们在内核线程上下文中运行）。</p>
<div class="section" id="section-19">
<h3>内核线程<a class="headerlink" href="#section-19" title="永久链接至标题">¶</a></h3>
<p class="admonition-">有时候内核核心或设备驱动程序需要执行阻塞操作，因此需要在进程上下文中运行。</p>
<p>内核线程就是为此而使用的一种特殊类别的任务，它们不使用“用户空间”资源（例如没有地址空间或打开的文件）。</p>
<p>以下屏幕录像将更详细地介绍内核线程：</p>
<p class="admonition-">&nbsp;</p>
<asciinema-player src="../_images/kernel_threads.cast"></asciinema-player></div>
</div>
<div class="section" id="gdb">
<h2>使用 gdb 脚本进行内核检查<a class="headerlink" href="#gdb" title="永久链接至标题">¶</a></h2>
<p>Linux 内核附带了一组预定义的 gdb 扩展命令，我们可以在调试过程中使用它们来检查内核。只要正确设置了 gdbinit，它们就会自动加载。</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span>ubuntu@so2:/linux/tools/labs$ cat ~/.gdbinit
add-auto-load-safe-path /linux/scripts/gdb/vmlinux-gdb.py
</pre></div>
</div>
<p>所有与内核相关的命令都以 lx- 为前缀。在 gdb 中可以使用 TAB 键列出所有这些命令：</p>
<div class="highlight-sh"><div class="highlight"><pre><span></span><span class="o">(</span>gdb<span class="o">)</span> lx-
lx-clk-summary        lx-dmesg              lx-mounts
lx-cmdline            lx-fdtdump            lx-ps
lx-configdump         lx-genpd-summary      lx-symbols
lx-cpus               lx-iomem              lx-timerlist
lx-device-list-bus    lx-ioports            lx-version
lx-device-list-class  lx-list-check
lx-device-list-tree   lx-lsmod
</pre></div>
</div>
<p>这些命令的实现可以在 <cite>script/gdb/linux</cite> 目录中找到。让我们仔细看一下 lx-ps 命令的实现：</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="n">task_type</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">CachedType</span><span class="p">(</span><span class="s2">&quot;struct task_struct&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">task_lists</span><span class="p">():</span>
 <span class="n">task_ptr_type</span> <span class="o">=</span> <span class="n">task_type</span><span class="o">.</span><span class="n">get_type</span><span class="p">()</span><span class="o">.</span><span class="n">pointer</span><span class="p">()</span>
 <span class="n">init_task</span> <span class="o">=</span> <span class="n">gdb</span><span class="o">.</span><span class="n">parse_and_eval</span><span class="p">(</span><span class="s2">&quot;init_task&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">address</span>
 <span class="n">t</span> <span class="o">=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">init_task</span>

 <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
     <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
         <span class="k">yield</span> <span class="n">t</span>

         <span class="n">t</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">container_of</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="s1">&#39;thread_group&#39;</span><span class="p">][</span><span class="s1">&#39;next&#39;</span><span class="p">],</span>
                                <span class="n">task_ptr_type</span><span class="p">,</span> <span class="s2">&quot;thread_group&quot;</span><span class="p">)</span>
         <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">g</span><span class="p">:</span>
             <span class="k">break</span>

     <span class="n">t</span> <span class="o">=</span> <span class="n">g</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">container_of</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;tasks&#39;</span><span class="p">][</span><span class="s1">&#39;next&#39;</span><span class="p">],</span>
                                <span class="n">task_ptr_type</span><span class="p">,</span> <span class="s2">&quot;tasks&quot;</span><span class="p">)</span>
     <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="n">init_task</span><span class="p">:</span>
         <span class="k">return</span>


 <span class="k">class</span> <span class="nc">LxPs</span><span class="p">(</span><span class="n">gdb</span><span class="o">.</span><span class="n">Command</span><span class="p">):</span>
 <span class="sd">&quot;&quot;&quot;Dump Linux tasks.&quot;&quot;&quot;</span>

 <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
     <span class="nb">super</span><span class="p">(</span><span class="n">LxPs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;lx-ps&quot;</span><span class="p">,</span> <span class="n">gdb</span><span class="o">.</span><span class="n">COMMAND_DATA</span><span class="p">)</span>

 <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">from_tty</span><span class="p">):</span>
     <span class="n">gdb</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{:&gt;10} {:&gt;12} {:&gt;7}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;TASK&quot;</span><span class="p">,</span> <span class="s2">&quot;PID&quot;</span><span class="p">,</span> <span class="s2">&quot;COMM&quot;</span><span class="p">))</span>
     <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">task_lists</span><span class="p">():</span>
         <span class="n">gdb</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;{} {:^5} {}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
             <span class="n">task</span><span class="o">.</span><span class="n">format_string</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
             <span class="n">task</span><span class="p">[</span><span class="s2">&quot;pid&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">format_string</span><span class="p">(),</span>
             <span class="n">task</span><span class="p">[</span><span class="s2">&quot;comm&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">string</span><span class="p">()))</span>
</pre></div>
</div>
<div class="section" id="gdb-1">
<h3>测验：内核 gdb 脚本<a class="headerlink" href="#gdb-1" title="永久链接至标题">¶</a></h3>
<p class="admonition-gdb">下面对 lx-ps 脚本的修改是为了实现什么目的？</p>
<div class="highlight-diff"><div class="highlight"><pre><span></span><span class="gh">diff --git a/scripts/gdb/linux/tasks.py b/scripts/gdb/linux/tasks.py</span>
<span class="gh">index 17ec19e9b5bf..7e43c163832f 100644</span>
<span class="gd">--- a/scripts/gdb/linux/tasks.py</span>
<span class="gi">+++ b/scripts/gdb/linux/tasks.py</span>
<span class="gu">@@ -75,10 +75,13 @@ class LxPs(gdb.Command):</span>
     def invoke(self, arg, from_tty):
         gdb.write(&quot;{:&gt;10} {:&gt;12} {:&gt;7}\n&quot;.format(&quot;TASK&quot;, &quot;PID&quot;, &quot;COMM&quot;))
         for task in task_lists():
<span class="gd">-            gdb.write(&quot;{} {:^5} {}\n&quot;.format(</span>
<span class="gi">+            check = task[&quot;mm&quot;].format_string() == &quot;0x0&quot;</span>
<span class="gi">+            gdb.write(&quot;{} {:^5} {}{}{}\n&quot;.format(</span>
                 task.format_string().split()[0],
                 task[&quot;pid&quot;].format_string(),
<span class="gd">-                task[&quot;comm&quot;].string()))</span>
<span class="gi">+                &quot;[&quot; if check else &quot;&quot;,</span>
<span class="gi">+                task[&quot;comm&quot;].string(),</span>
<span class="gi">+                &quot;]&quot; if check else &quot;&quot;))</span>


 LxPs()
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lec2-syscalls.html" class="btn btn-neutral float-left" title="SO2 课程 02——系统调用" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lec4-interrupts.html" class="btn btn-neutral float-right" title="SO2 课程 04——中断" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>