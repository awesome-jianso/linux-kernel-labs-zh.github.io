<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta content="熟悉基本的 Linux 内核 API，描述内存分配机制，描述锁定（locking）机制" name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 02 - Kernel API &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh-CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 03 - Character device drivers" href="lab3-device-drivers.html" />
    <link rel="prev" title="SO2 Lab 01 - Introduction" href="lab1-intro.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 02 - Kernel API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">实验目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-3">访问内存</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-4">执行上下文</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-5">锁定</a></li>
<li class="toctree-l3"><a class="reference internal" href="#preemptivity">可抢占性（preemptivity）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#linux-api">Linux 内核 API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-6">表示错误的约定</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-7">字符串处理</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printk">printk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-8">内存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-9">列表</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-10">自旋锁</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutex">互斥锁（Mutex）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-11">原子变量</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-13">原子位操作</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-14">练习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-15">0. 简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux">1. Linux 内核中的内存分配</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-16">2. 在原子上下文中睡眠</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-17">3. 使用内核内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-18">4. 使用内核列表</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-19">5. 使用内核列表进行进程处理</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-20">6. 同步列表工作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-21">7. 在我们的列表模块中测试模块调用</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 02 - Kernel API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab2-kernel-api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-02-kernel-api">
<h1>SO2 Lab 02 - Kernel API<a class="headerlink" href="#so2-lab-02-kernel-api" title="Permalink to this headline">¶</a></h1>
<div class="section" id="section-1">
<h2>实验目标<a class="headerlink" href="#section-1" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>熟悉基本的 Linux 内核 API</li>
<li>描述内存分配机制</li>
<li>描述锁定（locking）机制</li>
</ul>
</div>
<div class="section" id="section-2">
<h2>概述<a class="headerlink" href="#section-2" title="Permalink to this headline">¶</a></h2>
<p>本实验旨在帮助你掌握 Linux 内核编程的一些基本概念和函数。你需要注意，内核编程和用户空间编程有很多不同之处。内核是一个独立运行的实体，不能调用用户空间的任何库，包括 libc 在内。所以，你不能使用 printf、malloc、free、open、read、write、memcpy、strcpy 等常见的用户空间函数。简而言之，内核编程需要使用一套全新的、与用户空间 API 没有关联的独立 API，无论是 POSIX 还是 ANSI C 都不适用于内核编程。</p>
</div>
<div class="section" id="section-3">
<h2>访问内存<a class="headerlink" href="#section-3" title="Permalink to this headline">¶</a></h2>
<p>内存的访问和分配是内核编程中一个重要且不同的方面。内核编程与物理机器紧密相关，因此对内存管理的规则非常重要。首先，它涉及以下几种类型的内存：</p>
<ul class="simple">
<li>物理内存</li>
<li>内核地址空间中的虚拟内存</li>
<li>进程地址空间中的虚拟内存</li>
<li>常驻内存（resident memory）——可以确定所访问的页面存在于物理内存中</li>
</ul>
<p>由于操作系统实现的虚拟内存机制，进程地址空间中的虚拟内存不能被视为常驻内存：页面可能会被交换出去，或者由于需求分页机制的原因可能根本不存在于物理内存中。内核地址空间中的内存可以是常驻或非常驻的。模块的数据和代码段以及进程的内核栈是常驻的。动态内存可能是常驻或非常驻的，具体取决于它是如何被分配的。</p>
<p>在使用常驻内存时，一切都很简单：可以随时访问内存。但是如果使用非常驻内存，则只能从特定的上下文中访问。只能从进程上下文中访问非常驻内存。从中断上下文访问非常驻内存会导致不可预知的结果，因此当操作系统检测到此类访问时，将采取严厉的措施：阻塞或重置系统，以防止严重破坏。</p>
<p>内核不能直接访问进程的虚拟内存。一般来说，强烈不建议访问进程的地址空间，但是在某些情况下，设备驱动程序需要这样做。典型情况是设备驱动程序需要访问用户空间的缓冲（buffer）区。为了避免访问无效的内存区域，设备驱动程序不能直接访问缓冲区，而要通过特殊功能。</p>
<p>内存方面，内核与用户空间的另一个区别是堆栈（stack），内核堆栈的大小是固定且有限的。例如，Linux 的堆栈大小为 4K，而 Windows 的堆栈大小为 12K。因此，我们应该避免在堆栈上分配大型结构或进行递归调用。</p>
</div>
<div class="section" id="section-4">
<h2>执行上下文<a class="headerlink" href="#section-4" title="Permalink to this headline">¶</a></h2>
<p>我们可以根据内核执行的情况，把上下文分为两种：进程上下文和中断上下文。如果我们是因为系统调用而在内核中运行代码，或者是在内核线程中运行，那么我们就在进程上下文中。如果我们是在响应中断或执行延迟操作的函数时运行，那么我们就在中断上下文中。</p>
<p>一些内核 API 调用可以阻塞当前进程。常见的例子是使用信号量（semaphore）或等待条件。在这种情况下，进程被置于“等待”状态，而另一个进程在运行。当从中断上下文中调用可能导致当前进程被挂起的函数时，就会出现有趣的情况。在这种情况下，没有当前进程，因此结果是不可预测的。每当操作系统检测到这种情况时，将生成一个错误条件，导致操作系统关闭。</p>
</div>
<div class="section" id="section-5">
<h2>锁定<a class="headerlink" href="#section-5" title="Permalink to this headline">¶</a></h2>
<p>内核编程中最重要的特性之一是并行性（parallelism）。Linux 支持具有多个处理器和内核可抢占性的 SMP 系统。这使得内核编程更加困难，因为对全局变量的访问必须与自旋锁原语（primitives）或阻塞原语同步。虽然建议使用阻塞原语，但在中断上下文中无法使用它们，因此在中断的上下文中唯一的锁定解决方案是自旋锁。</p>
<p>自旋锁是一种实现互斥的方法。它不会让当前进程进入挂起状态，而是让它一直忙等待（在一个 c:func:<cite>while</cite> 循环中检查锁是否可用）。运行在由自旋锁保护的临界区域的代码不允许挂起当前进程（它必须遵守中断上下文中的执行条件）。此外，除非发生中断，否则 CPU 不会被释放。由于此机制，最好尽可能使持有自旋锁的时长短一些。</p>
</div>
<div class="section" id="preemptivity">
<h2>可抢占性（preemptivity）<a class="headerlink" href="#preemptivity" title="Permalink to this headline">¶</a></h2>
<p>Linux 使用的是可抢占内核。这里，我们需要明确区分可抢占多任务（preemptive multitasking）和可抢占内核两个概念。可抢占多任务是指，当一个进程在用户空间运行时，一旦其分配的时间片（时间片段）到期，操作系统会强制中断该进程，转而运行另一个进程。而如果一个在内核模式下运行的进程（通常是作为系统调用的结果），可以被中断以便运行另一个进程，那么我们就说这个内核具有可抢占性。</p>
<p>由于内核的可抢占性，即使在单处理器环境下，当我们需要在可能来自不同进程上下文的两段代码之间共享资源时，我们也必须使用同步原语进行保护。</p>
</div>
<div class="section" id="linux-api">
<h2>Linux 内核 API<a class="headerlink" href="#linux-api" title="Permalink to this headline">¶</a></h2>
<div class="section" id="section-6">
<h3>表示错误的约定<a class="headerlink" href="#section-6" title="Permalink to this headline">¶</a></h3>
<p>在 Linux 内核编程中，调用函数的返回值被用来表示成功与否，这个约定与 UNIX 编程相同：0 代表成功，非 0 值代表失败。如果失败，返回值应该是负数，如下面的例子所示：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">alloc_memory</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">user_parameter_valid</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
</pre></div>
</div>
<p>可在 <code class="file docutils literal"><span class="pre">include/uapi/asm-generic/errno-base.h</span></code> 和 <code class="file docutils literal"><span class="pre">include/uapi/asm-generic/ernno.h</span></code> 中找到错误的详尽列表和摘要解释。</p>
</div>
<div class="section" id="section-7">
<h3>字符串处理<a class="headerlink" href="#section-7" title="Permalink to this headline">¶</a></h3>
<p>在 Linux 中，内核程序员可以使用常见的常规函数来处理字符串，包括：<code class="xref c c-func docutils literal"><span class="pre">strcpy()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">strncpy()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strlcpy()</span></code> 、<code class="xref c c-func docutils literal"><span class="pre">strcat()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strncat()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strlcat()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strcmp()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strncmp()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strnicmp()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strchr()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strnchr()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strrchr()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strstr()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">strlen()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">memset()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">memmove()</span></code>、 <code class="xref c c-func docutils literal"><span class="pre">memcmp()</span></code> 等。这些函数在 <code class="file docutils literal"><span class="pre">include/linux/string.h</span></code> 头文件中声明，并在内核的 <code class="file docutils literal"><span class="pre">lib/string.c</span></code> 文件中实现。</p>
</div>
<div class="section" id="printk">
<h3>printk<a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p>在内核中，与 printf 等效的函数是 printk，它在 <code class="file docutils literal"><span class="pre">include/linux/printk.h</span></code> 中定义。<code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 的语法与 <cite>printf</cite> 非常相似。<code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 的第一个参数决定了当前日志所属的日志类别：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define KERN_EMERG   &quot;&lt;0&gt;&quot;  </span><span class="cm">/* 系统不可用 */</span><span class="cp"></span>
<span class="cp">#define KERN_ALERT   &quot;&lt;1&gt;&quot;  </span><span class="cm">/* 必须立即采取行动 */</span><span class="cp"></span>
<span class="cp">#define KERN_CRIT    &quot;&lt;2&gt;&quot;  </span><span class="cm">/* 严重情况 */</span><span class="cp"></span>
<span class="cp">#define KERN_ERR     &quot;&lt;3&gt;&quot;  </span><span class="cm">/* 错误情况 */</span><span class="cp"></span>
<span class="cp">#define KERN_WARNING &quot;&lt;4&gt;&quot;  </span><span class="cm">/* 警告情况 */</span><span class="cp"></span>
<span class="cp">#define KERN_NOTICE  &quot;&lt;5&gt;&quot;  </span><span class="cm">/* 正常但重要的情况 */</span><span class="cp"></span>
<span class="cp">#define KERN_INFO    &quot;&lt;6&gt;&quot;  </span><span class="cm">/* 信息 */</span><span class="cp"></span>
<span class="cp">#define KERN_DEBUG   &quot;&lt;7&gt;&quot;  </span><span class="cm">/* 调试级别的消息 */</span><span class="cp"></span>
</pre></div>
</div>
<p>因此，在内核中发送警告消息的方式如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;my_module 的输入字符串 %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">buff</span><span class="p">);</span>
</pre></div>
</div>
<p>如果在 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 调用中缺少日志级别，日志记录将使用调用时的默认级别。注意，只有当消息级别超过控制台上设置的默认级别时，使用 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 发送的消息才会在控制台上可见。</p>
<p>为了减小使用 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 时的行长度，建议使用以下辅助函数（help functions）而不是直接调用 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> ：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">pr_emerg</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_EMERG pr_fmt(fmt), ...); */</span>
<span class="n">pr_alert</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_ALERT pr_fmt(fmt), ...); */</span>
<span class="n">pr_crit</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_CRIT pr_fmt(fmt), ...); */</span>
<span class="n">pr_err</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_ERR pr_fmt(fmt), ...); */</span>
<span class="n">pr_warn</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_WARNING pr_fmt(fmt), ...); */</span>
<span class="n">pr_notice</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_NOTICE pr_fmt(fmt), ...); */</span>
<span class="n">pr_info</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_INFO pr_fmt(fmt), ...); */</span>
<span class="n">pr_debug</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...);</span> <span class="cm">/* 类似于 printk(KERN_DEBUG pr_fmt(fmt), ...); */</span>
</pre></div>
</div>
<p>一个特殊情况是 <code class="xref c c-func docutils literal"><span class="pre">pr_debug()</span></code>，它只在定义了 <cite>DEBUG</cite> 宏或使用动态调试时才会调用 <cite>printk</cite> 函数。</p>
</div>
<div class="section" id="section-8">
<h3>内存分配<a class="headerlink" href="#section-8" title="Permalink to this headline">¶</a></h3>
<p>在 Linux 内核中，只能分配驻留内存。要想分配驻留内存，可以使用 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 调用。下面是一个典型的 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 调用示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp"></span>

<span class="n">string</span> <span class="o">=</span> <span class="n">kmalloc</span> <span class="p">(</span><span class="n">string_len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//报告错误：-ENOMEM;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如你所见，第一个参数表示分配区域的字节大小。这个函数返回一个指向内核中可直接使用的内存区域的指针，如果无法分配内存，则返回 <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>。第二个参数指定了如何进行分配，最常用的取值有：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-data docutils literal"><span class="pre">GFP_KERNEL</span></code> ——使用此值可能导致当前进程被挂起。因此，它不能在中断上下文中使用。</li>
<li><code class="xref c c-data docutils literal"><span class="pre">GFP_ATOMIC</span></code> ——使用此值确保 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 函数不会挂起当前进程。它可以随时使用。</li>
</ul>
</div></blockquote>
<p>与 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 函数相对应的是 <code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code>，它接收由 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 分配的区域作为参数。该函数不会挂起当前进程，因此可以从任何上下文中调用。</p>
</div>
<div class="section" id="section-9">
<h3>列表<a class="headerlink" href="#section-9" title="Permalink to this headline">¶</a></h3>
<p>由于链表经常被使用，Linux 内核 API 提供了一种统一的方式来定义和使用链表。这涉及在我们希望将其视为链表节点的结构中使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> 元素。 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> 在 <code class="file docutils literal"><span class="pre">include/linux/list.h</span></code> 中定义，同时还定义了所有其他操作链表的函数。以下代码展示了 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> 的定义，以及在 Linux 内核中另一个众所周知的结构中使用该类型的元素的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">list_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>操作链表的常用惯例如下：</p>
<ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">LIST_HEAD(name)</span></code> 用于声明链表的标记（sentinel）。</li>
<li><code class="xref c c-func docutils literal"><span class="pre">INIT_LIST_HEAD(struct</span> <span class="pre">list_head</span> <span class="pre">*list)()</span></code> 用于在进行动态分配时，通过设置链表字段 <code class="xref c c-data docutils literal"><span class="pre">next</span></code> 和 <code class="xref c c-data docutils literal"><span class="pre">prev</span></code>，来初始化链表的标记。</li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_add(struct</span> <span class="pre">list_head</span> <span class="pre">*new,</span> <span class="pre">struct</span> <span class="pre">list_head</span> <span class="pre">*head)()</span></code> 将 <code class="xref c c-data docutils literal"><span class="pre">new</span></code> 指针所引用的元素添加到 <code class="xref c c-data docutils literal"><span class="pre">head</span></code> 指针所引用的元素之后。</li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_del(struct</span> <span class="pre">list_head</span> <span class="pre">*entry)()</span></code> 删除属于列表的 <code class="xref c c-data docutils literal"><span class="pre">entry</span></code> 地址处的项目。</li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_entry(ptr,</span> <span class="pre">type,</span> <span class="pre">member)()</span></code> 返回列表中包含元素 <code class="xref c c-data docutils literal"><span class="pre">ptr</span></code> 的类型为 <code class="xref c c-type docutils literal"><span class="pre">type</span></code> 的结构，该结构中具有名为 <code class="xref c c-member docutils literal"><span class="pre">member</span></code> 的成员。</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_for_each(pos,</span> <span class="pre">head)</span></code> 使用 <code class="xref c c-data docutils literal"><span class="pre">pos</span></code> 作为游标来迭代列表。</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_for_each_safe(pos,</span> <span class="pre">n,</span> <span class="pre">head)</span></code> 使用 <code class="xref c c-data docutils literal"><span class="pre">pos</span></code> 作为游标，<code class="xref c c-data docutils literal"><span class="pre">n</span></code> 作为临时游标来迭代列表。此宏用于从列表中删除项目。</li>
</ul>
<p>以下代码展示了如何使用这些惯例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/list.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">pid_list</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">my_list</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_pid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">ple</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="o">*</span><span class="n">ple</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ple</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="n">ple</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ple</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">del_pid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">ple</span><span class="p">;</span>

    <span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ple</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ple</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list_del</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">kfree</span><span class="p">(</span><span class="n">ple</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_list</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">ple</span><span class="p">;</span>

    <span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_list</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ple</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="n">list_del</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">ple</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>列表的演变可以在下图中看到：</p>
<a class="reference internal image-reference" href="../_images/list_evolution1.png"><img alt="../_images/list_evolution1.png" src="../_images/list_evolution1.png" style="width: 85%;" /></a>
<p>从上面的例子可以看出，通过 <code class="xref c c-macro docutils literal"><span class="pre">list_add</span></code> 宏引入了堆栈类型的行为，并使用了标记。</p>
<p>通过上述示例可以看出，定义和使用一个（双向）列表的方法是通用的，并且同时不引入额外的开销。<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code> 用于维护列表元素之间的链接。可以注意到，对列表的迭代也是使用这个结构进行的，使用 <code class="xref c c-macro docutils literal"><span class="pre">list_entry</span></code> 可以获取列表元素。这种实现和使用列表的思想并不新鲜，在 20 世纪 80 年代，Donald Knuth 的《计算机程序设计艺术》中已经有描述。</p>
<p>在 <code class="file docutils literal"><span class="pre">include/linux/list.h</span></code> 头文件中介绍并且解释了几个内核列表函数和宏定义。</p>
</div>
<div class="section" id="section-10">
<h3>自旋锁<a class="headerlink" href="#section-10" title="Permalink to this headline">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">spinlock_t</span></code> （在 <code class="file docutils literal"><span class="pre">linux/spinlock.h</span></code> 中定义）是在 Linux 中实现自旋锁概念的基本类型。它描述了自旋锁，与自旋锁相关的操作有 <code class="xref c c-func docutils literal"><span class="pre">spin_lock_init()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">spin_lock()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock()</span></code>。以下是一个使用示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp"></span>

<span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">lock1</span><span class="p">);</span>
<span class="n">spinlock_t</span> <span class="n">lock2</span><span class="p">;</span>

<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock2</span><span class="p">);</span>

<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock1</span><span class="p">);</span>
<span class="cm">/* 临界区（critical region） */</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock1</span><span class="p">);</span>

<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock2</span><span class="p">);</span>
<span class="cm">/* 临界区 */</span>
<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock2</span><span class="p">);</span>
</pre></div>
</div>
<p>在 Linux 中，你可以使用读写自旋锁来解决读者—写者问题。这种类型的锁由 <code class="xref c c-type docutils literal"><span class="pre">rwlock_t</span></code> 标识，并且可以使用以下函数来操作读写自旋锁： <code class="xref c c-func docutils literal"><span class="pre">rwlock_init()</span></code> 、 <code class="xref c c-func docutils literal"><span class="pre">read_lock()</span></code> 以及 <code class="xref c c-func docutils literal"><span class="pre">write_lock()</span></code> 。以下是使用读写自旋锁的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/spinlock.h&gt;</span><span class="cp"></span>

<span class="n">DEFINE_RWLOCK</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">pid_list</span> <span class="p">{</span>
    <span class="kt">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">have_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

    <span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">list_for_each</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">lh</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">pl</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">==</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">add_pid</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">lh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pid_list</span> <span class="o">*</span><span class="n">pl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">lh</span><span class="p">);</span>
    <span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="mutex">
<h3>互斥锁（Mutex）<a class="headerlink" href="#mutex" title="Permalink to this headline">¶</a></h3>
<p>互斥锁是一种 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mutex</span></code> 类型的变量（定义在 <code class="file docutils literal"><span class="pre">linux/mutex.h</span></code> 中）。下面列出了用于处理互斥锁的函数和宏：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/mutex.h&gt;</span><span class="cp"></span>

<span class="cm">/* 互斥锁初始化函数 */</span>
<span class="kt">void</span> <span class="nf">mutex_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>

<span class="cm">/* 互斥锁获取函数 */</span>
<span class="kt">void</span> <span class="nf">mutex_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>

<span class="cm">/* 互斥锁释放函数 */</span>
<span class="kt">void</span> <span class="nf">mutex_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>
</div>
<p>这些操作与在用户空间中进行的经典互斥锁操作或自旋锁操作类似：在进入临界区之前获取互斥锁，在退出临界区之后释放互斥锁。不同于自旋锁，这些操作只能在进程上下文中使用。</p>
</div>
<div class="section" id="section-11">
<span id="atomic-variables"></span><h3>原子变量<a class="headerlink" href="#section-11" title="Permalink to this headline">¶</a></h3>
<p>通常，你只需要对简单的变量（如计数器）进行访问同步。为此，可以使用 <code class="xref c c-type docutils literal"><span class="pre">atomic_t</span></code> 类型（定义在 <code class="file docutils literal"><span class="pre">include/linux/atomic.h</span></code> 中），它保存一个整数值。下面是一些可以对 <code class="xref c c-type docutils literal"><span class="pre">atomic_t</span></code> 变量执行的操作。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/atomic.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">atomic_set</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_read</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_sub</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_inc</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">atomic_dec</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_inc_and_test</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_dec_and_test</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">atomic_cmpxchg</span><span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="n">old</span><span class="p">,</span> <span class="kt">int</span> <span class="n">new</span><span class="p">);</span>
</pre></div>
</div>
<div class="section" id="section-12">
<h4>原子变量的使用<a class="headerlink" href="#section-12" title="Permalink to this headline">¶</a></h4>
<p>原子变量的常见使用方式是存储一个操作的状态（例如，一个标志）。因此，我们可以使用原子变量来标记独占操作。例如，我们可以考虑一个原子变量可以具有 LOCKED 和 UNLOCKED 两个值，如果该变量等于 LOCKED，则特定函数应返回 -EBUSY。下面的代码示例展示了这种用法：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define LOCKED 0</span>
<span class="cp">#define UNLOCKED 1</span>

<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">flag</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_acquire</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">int</span> <span class="n">initial_flag</span><span class="p">;</span>

   <span class="cm">/*</span>
<span class="cm">   * 检查 flag 是否为 UNLOCKED；如果是，则以原子方式将其锁定。</span>
<span class="cm">   *</span>
<span class="cm">   * 这个原子操作相当于：</span>
<span class="cm">   *   if (flag == UNLOCKED)</span>
<span class="cm">   *       flag = LOCKED;</span>
<span class="cm">   *   else</span>
<span class="cm">   *       return -EBUSY;</span>
<span class="cm">   */</span>
   <span class="n">initial_flag</span> <span class="o">=</span> <span class="n">atomic_cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">,</span> <span class="n">LOCKED</span><span class="p">);</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">initial_flag</span> <span class="o">==</span> <span class="n">LOCKED</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;已经被锁定。</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="cm">/* 在获取锁之后进行操作。 */</span>
   <span class="p">[...]</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_release</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="cm">/* 释放 flag，将其标记为解锁状态。 */</span>
   <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
   <span class="p">[...]</span>
   <span class="cm">/* 原子变量最初处于解锁状态。 */</span>
   <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">,</span> <span class="n">UNLOCKED</span><span class="p">);</span>

   <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以上代码是 trylock（例如 <code class="xref c c-func docutils literal"><span class="pre">pthread_mutex_trylock()</span></code> ）的等效代码。</p>
<p>我们还可以使用一个变量来存储缓冲区的大小，并进行相应变量的原子更新。下面是示例代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">MAX_SIZE</span><span class="p">];</span>
<span class="k">static</span> <span class="n">atomic_t</span> <span class="n">size</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_buffer</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">buffer</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
     <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="nf">remove_from_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">value</span><span class="p">;</span>

     <span class="n">value</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">)];</span>
     <span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>

     <span class="k">return</span> <span class="n">value</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">reset_buffer</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
     <span class="p">[...]</span>
     <span class="cm">/* 初始化缓冲和大小 */</span>
     <span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
     <span class="n">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

     <span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-13">
<h3>原子位操作<a class="headerlink" href="#section-13" title="Permalink to this headline">¶</a></h3>
<p>内核提供了一组函数（在 <code class="file docutils literal"><span class="pre">asm/bitops.h</span></code> 中），可以以原子方式修改或测试位（bit）。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/bitops.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_and_set_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_and_clear_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_and_change_bit</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">addr</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-data docutils literal"><span class="pre">Addr</span></code> 表示要修改或测试位的内存区域的地址，<code class="xref c c-data docutils literal"><span class="pre">nr</span></code> 是要执行操作的位。</p>
</div>
</div>
<div class="section" id="section-14">
<h2>练习<a class="headerlink" href="#section-14" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 kernel_api。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/kernel_api/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-14">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-15">
<h3>0. 简介<a class="headerlink" href="#section-15" title="Permalink to this headline">¶</a></h3>
<p>使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 在 Linux 内核中查找以下符号的定义：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">INIT_LIST_HEAD()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">list_add()</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_for_each</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">list_entry</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">container_of</span></code></li>
<li><code class="xref c c-macro docutils literal"><span class="pre">offsetof</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="linux">
<h3>1. Linux 内核中的内存分配<a class="headerlink" href="#linux" title="Permalink to this headline">¶</a></h3>
<p>生成名为 <strong>1-mem</strong> 的任务骨架，并浏览 <code class="file docutils literal"><span class="pre">mem.c</span></code> 文件的内容。观察使用 <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> 函数进行内存分配的情况。</p>
<blockquote>
<div><ol class="arabic simple">
<li>编译源代码并使用 <strong class="command">insmod</strong> 加载 <code class="file docutils literal"><span class="pre">mem.ko</span></code> 模块。</li>
<li>使用 <strong class="command">dmesg</strong> 命令查看内核消息。</li>
<li>使用 <strong class="command">rmmod mem</strong> 命令卸载内核模块。</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请参阅实验中的 <a class="reference internal" href="#section-8">内存分配</a> 部分。</p>
</div>
</div>
<div class="section" id="section-16">
<h3>2. 在原子上下文中睡眠<a class="headerlink" href="#section-16" title="Permalink to this headline">¶</a></h3>
<p>生成名为 <strong>2-sched-spin</strong> 的任务骨架，并浏览 <code class="file docutils literal"><span class="pre">sched-spin.c</span></code> 文件的内容。</p>
<blockquote>
<div><ol class="arabic simple">
<li>根据上述信息编译源代码并加载模块（使用命令 <strong class="command">make build</strong> 和 <strong class="command">make copy</strong> ）。</li>
<li>注意：插入顺序完成之前需要等待 5 秒时间。</li>
<li>卸载内核模块。</li>
<li>查找标记为：<code class="docutils literal"><span class="pre">TODO</span> <span class="pre">0</span></code> 的行以创建原子段（atomic section）。重新编译源代码并将模块重新加载到内核。</li>
</ol>
</div></blockquote>
<p>现在你应该会遇到一个错误。查看堆栈跟踪。错误的原因是什么？</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">在错误消息中，跟踪包含 <code class="xref c c-macro docutils literal"><span class="pre">BUG</span></code> 的行查看对错误的描述。在原子上下文中不允许睡眠。在这里原子上下文是处于自旋锁进行锁定操作和解锁操作之间的部分。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="xref c c-func docutils literal"><span class="pre">schedule_timeout()</span></code> 函数与 <code class="xref c c-macro docutils literal"><span class="pre">set_current_state</span></code> 宏结合使用，强制当前进程等待了 5 秒钟。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请查阅 <a class="reference internal" href="#section-4">执行上下文</a> 、<a class="reference internal" href="#section-5">锁定</a> 和 <a class="reference internal" href="#section-10">自旋锁</a> 部分。</p>
</div>
</div>
<div class="section" id="section-17">
<h3>3. 使用内核内存<a class="headerlink" href="#section-17" title="Permalink to this headline">¶</a></h3>
<p>为名为 <strong>3-memory</strong> 的任务生成骨架，并浏览 <code class="file docutils literal"><span class="pre">memory.c</span></code> 文件的内容。请注意带有 <code class="docutils literal"><span class="pre">TODO</span></code> 标记的注释。你需要分配 4 个类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code> 的结构体并将其初始化（在 <code class="xref c c-func docutils literal"><span class="pre">memory_init()</span></code> 中），然后打印并释放它们（在 <code class="xref c c-func docutils literal"><span class="pre">memory_exit()</span></code> 中）。</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">（TODO 1）为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code> 结构体分配内存并初始化其字段：</p>
<ul class="simple">
<li>将 <code class="xref c c-member docutils literal"><span class="pre">pid</span></code> 字段设置为作为参数传递的 PID 值；</li>
<li>将 <code class="xref c c-member docutils literal"><span class="pre">timestamp</span></code> 字段设置为 <code class="xref c c-data docutils literal"><span class="pre">jiffies</span></code> 变量的值，该变量存储了自系统启动以来发生的滴答数（tick）。</li>
</ul>
</li>
<li><p class="first">（TODO 2）为当前进程、父进程、下一个进程和下一个进程的下一个进程分别分配 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code>，并获取以下信息：</p>
<ul class="simple">
<li>当前进程的 PID，其可以从 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 结构体中检索到，该结构体由 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 宏返回。</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">在 <code class="xref c c-type docutils literal"><span class="pre">task_struct</span></code> 中搜索 <code class="xref c c-type docutils literal"><span class="pre">pid</span></code>。</p>
</div>
<ul class="simple">
<li>当前进程的父进程的 PID。</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 结构体中搜索相关字段。查找“parent”。</p>
</div>
<ul class="simple">
<li>相对于当前进程，进程列表中的下一个进程的 PID。</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">使用 <code class="xref c c-macro docutils literal"><span class="pre">next_task</span></code> 宏，该宏返回指向下一个进程的指针（即 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 结构体）。</p>
</div>
<ul class="simple">
<li>相对于当前进程，下一个进程的下一个进程的 PID。</li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">调用 <code class="xref c c-macro docutils literal"><span class="pre">next_task</span></code> 宏 2 次。</p>
</div>
</li>
<li><p class="first">（TODO 3）显示这四个结构体。</p>
<ul class="simple">
<li>使用 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 显示它们的两个字段：<code class="xref c c-member docutils literal"><span class="pre">pid</span></code> 和 <code class="xref c c-member docutils literal"><span class="pre">timestamp</span></code>。</li>
</ul>
</li>
<li><p class="first">（TODO 4）释放结构体占用的内存（使用 <code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code>）。</p>
</li>
</ol>
</div></blockquote>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<ul class="last simple">
<li>你可以使用 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 宏访问当前进程。</li>
<li>在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 结构体中查找相关字段（<code class="xref c c-member docutils literal"><span class="pre">pid</span></code>、<code class="xref c c-member docutils literal"><span class="pre">parent</span></code>）。</li>
<li>使用 <code class="xref c c-macro docutils literal"><span class="pre">next_task</span></code> 宏。该宏返回指向下一个进程的指针（即 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct*</span></code> 结构体）。</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 结构体包含两个字段用于指定任务的父进程：</p>
<ul class="simple">
<li><code class="xref c c-member docutils literal"><span class="pre">real_parent</span></code> 指向创建任务的进程，或者如果父进程已完成执行，则指向具有 pid 1（init）的进程。</li>
<li><code class="xref c c-member docutils literal"><span class="pre">parent</span></code> 指示当前任务的父进程（如果任务完成执行，则向该进程报告）。</li>
</ul>
<p class="last">通常情况下，这两个字段的值是相同的，但在某些情况下它们可能不同，例如使用 <code class="xref c c-func docutils literal"><span class="pre">ptrace()</span></code> 系统调用时。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">请查阅实验中的 <a class="reference internal" href="#section-8">内存分配</a> 小节。</p>
</div>
</div>
<div class="section" id="section-18">
<h3>4. 使用内核列表<a class="headerlink" href="#section-18" title="Permalink to this headline">¶</a></h3>
<p>生成名为 <strong>4-list</strong> 的任务骨架。浏览 <code class="file docutils literal"><span class="pre">list.c</span></code> 文件的内容，并注意标有 <code class="docutils literal"><span class="pre">TODO</span></code> 的注释。当前的进程将在列表中添加前面练习中的四个结构体。列表将在加载模块时在 <code class="xref c c-func docutils literal"><span class="pre">task_info_add_for_current()</span></code> 函数中构建。列表将在 <code class="xref c c-func docutils literal"><span class="pre">list_exit()</span></code> 函数和 <code class="xref c c-func docutils literal"><span class="pre">task_info_purge_list()</span></code> 函数中打印和删除。</p>
<blockquote>
<div><ol class="arabic simple">
<li>(TODO 1) 补全 <code class="xref c c-func docutils literal"><span class="pre">task_info_add_to_list()</span></code> 函数，此函数会分配 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_info</span></code> 结构体，并将其添加到列表中。</li>
<li>(TODO 2) 补全 <code class="xref c c-func docutils literal"><span class="pre">task_info_purge_list()</span></code> 函数，此函数会删除列表中的所有元素。</li>
<li>编译内核模块。按照内核显示的消息加载和卸载模块。</li>
</ol>
</div></blockquote>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">回顾一下实验中的 <a class="reference internal" href="#section-9">列表</a> 部分。在从列表中删除项目时，你需要使用 <code class="xref c c-macro docutils literal"><span class="pre">list_for_each_safe</span></code> 或 <code class="xref c c-macro docutils literal"><span class="pre">list_for_each_entry_safe</span></code> 宏。</p>
</div>
</div>
<div class="section" id="section-19">
<h3>5. 使用内核列表进行进程处理<a class="headerlink" href="#section-19" title="Permalink to this headline">¶</a></h3>
<p>生成名为 <strong>5-list-full</strong> 的任务骨架。浏览 <code class="file docutils literal"><span class="pre">list-full.c</span></code> 文件的内容，并注意标有 <code class="docutils literal"><span class="pre">TODO</span></code> 的注释。除了 <code class="file docutils literal"><span class="pre">4-list</span></code> 的功能外，我们还添加了以下内容：</p>
<blockquote>
<div><ul>
<li><p class="first">一个 <code class="xref c c-member docutils literal"><span class="pre">count</span></code> 字段，显示一个进程被“添加”到列表中的次数。</p>
</li>
<li><p class="first">如果一个进程被“添加”了多次，则不会在列表中创建新的条目，而是：</p>
<blockquote>
<div><ul class="simple">
<li>更新 <code class="xref c c-member docutils literal"><span class="pre">timestamp</span></code> 字段。</li>
<li>增加 <code class="xref c c-member docutils literal"><span class="pre">count</span></code>。</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">为了实现计数器功能，请添加一个 <code class="xref c c-func docutils literal"><span class="pre">task_info_find_pid()</span></code> 函数，用于在现有列表中搜索 pid。</p>
</li>
<li><p class="first">如果找到，则返回对 <code class="xref c c-type docutils literal"><span class="pre">task_info</span></code> 结构的引用。如果没有找到，则返回 <code class="xref c c-macro docutils literal"><span class="pre">NULL</span></code>。</p>
</li>
<li><p class="first">过期处理功能。如果一个进程从被添加到现在已超过 3 秒，并且它的 <code class="xref c c-member docutils literal"><span class="pre">count</span></code> 不大于 5，则被视为过期并从列表中删除。</p>
</li>
<li><p class="first">过期处理功能已经在 <code class="xref c c-func docutils literal"><span class="pre">task_info_remove_expired()</span></code> 函数中实现。</p>
</li>
</ul>
<ol class="arabic">
<li><p class="first">(TODO 1) 实现 <code class="xref c c-func docutils literal"><span class="pre">task_info_find_pid()</span></code> 函数。</p>
</li>
<li><p class="first">(TODO 2) 更改列表中的一个项目的字段，使其不会过期。它不应满足 <code class="xref c c-func docutils literal"><span class="pre">task_info_remove_expired()</span></code> 中的任何过期条件。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">要想完成 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code>，可以从列表中提取第一个元素（由 <code class="xref c c-member docutils literal"><span class="pre">head.next</span></code> 引用），并将其 <code class="xref c c-member docutils literal"><span class="pre">count</span></code> 字段设置为足够大的值。使用 <code class="xref c c-func docutils literal"><span class="pre">atomic_set()</span></code> 函数。</p>
</div>
</li>
<li><p class="first">编译、复制、加载和卸载内核模块，这个过程中请遵从显示的消息来操作。加载内核模块需要一些时间，因为 <code class="xref c c-func docutils literal"><span class="pre">schedule_timeout()</span></code> 函数会调用 <code class="xref c c-func docutils literal"><span class="pre">sleep()</span></code>。</p>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="section-20">
<h3>6. 同步列表工作<a class="headerlink" href="#section-20" title="Permalink to this headline">¶</a></h3>
<p>为名为 <strong>6-list-sync</strong> 的任务生成骨架。</p>
<blockquote>
<div><ol class="arabic simple">
<li>浏览代码并查找``TODO 1``字符串。</li>
<li>使用自旋锁或读写锁来同步对列表的访问。</li>
<li>编译、加载和卸载内核模块。</li>
</ol>
</div></blockquote>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">始终锁定数据，而不是代码！</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请阅读实验的 <a class="reference internal" href="#section-10">自旋锁</a> 小节。</p>
</div>
</div>
<div class="section" id="section-21">
<h3>7. 在我们的列表模块中测试模块调用<a class="headerlink" href="#section-21" title="Permalink to this headline">¶</a></h3>
<p>为名为 <strong>7-list-test</strong> 的任务生成骨架，并浏览 <code class="file docutils literal"><span class="pre">list-test.c</span></code> 文件的内容。我们将使用它作为测试模块。它将调用由 <strong>6-list-sync</strong> 任务导出的函数。在 <code class="file docutils literal"><span class="pre">list-test.c</span></code> 文件中，已经用 <strong>extern</strong> 标记出了导出的函数。</p>
<p>取消注释 <code class="file docutils literal"><span class="pre">7-list-test.c</span></code> 中的注释代码。查找 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code>。</p>
<p>要从位于 <code class="file docutils literal"><span class="pre">6-list-sync/</span></code> 目录中的模块导出上述函数，需要执行以下步骤：</p>
<blockquote>
<div><ol class="arabic simple">
<li>函数不能是静态的。</li>
<li>使用 <code class="xref c c-macro docutils literal"><span class="pre">EXPORT_SYMBOL</span></code> 宏导出内核符号。例如：<code class="xref c c-macro docutils literal"><span class="pre">EXPORT_SYMBOL(task_info_remove_expired);</span></code>。该宏必须在函数定义后使用。浏览代码并查找 <code class="file docutils literal"><span class="pre">list-sync.c</span></code> 中的 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> 字符串。</li>
<li>从 <strong>6-list-sync</strong> 模块中删除避免列表项过期的代码（它与我们的练习相矛盾）。</li>
<li>编译并加载 <code class="file docutils literal"><span class="pre">6-list-sync/</span></code> 中的模块。一旦加载，它会公开导出的函数，使其可以被测试模块使用。你可以通过分别在加载模块之前和之后在 <code class="file docutils literal"><span class="pre">/proc/kallsyms</span></code> 中搜索函数名称来检查这一点。</li>
<li>编译测试模块，然后加载它。</li>
<li>使用 <strong class="command">lsmod</strong> 命令检查这两个模块是否已加载。你注意到了什么？</li>
<li>卸载内核测试模块。</li>
</ol>
</div></blockquote>
<p>两个模块（来自 <strong>6-list-sync</strong> 的模块和测试模块）的卸载顺序应该是什么？如果使用其他顺序会发生什么？</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab1-intro.html" class="btn btn-neutral float-left" title="SO2 Lab 01 - Introduction" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab3-device-drivers.html" class="btn btn-neutral float-right" title="SO2 Lab 03 - Character device drivers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>