<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lecture 06 - Address Space &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="SO2 Lecture 07 - Memory Management" href="lec7-memory-management.html" />
    <link rel="prev" title="SO2 Lecture 05 - Symmetric Multi-Processing" href="lec5-smp.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lecture 06 - Address Space</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">课程目标：</a></li>
<li class="toctree-l3"><a class="reference internal" href="#x86-mmu">x86 MMU</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-2">选择器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-3">段描述符</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux">Linux 中的分段</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-4">检查选择器和段</a></li>
<li class="toctree-l4"><a class="reference internal" href="#x86">x86 分页</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-5">页表</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linux-1">Linux 分页</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tlb">转译后备缓冲区（TLB）</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#linux-2">Linux 地址空间</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-6">32 位系统的地址空间选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-7">线性映射</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-8">高内存</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-9">固定映射的线性地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-10">临时映射</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-11">永久映射</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lecture 06 - Address Space</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lec6-address-space.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lecture-06-address-space">
<h1>SO2 Lecture 06 - Address Space<a class="headerlink" href="#so2-lecture-06-address-space" title="永久链接至标题">¶</a></h1>
<p><a class="reference external" href="lec6-address-space-slides.html">View slides</a></p>
<span class="admonition-so2-lecture-06-address-space"></span><div class="section" id="section-1">
<h2>课程目标：<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h2>
<ul class="admonition- simple">
<li>x86 MMU<ul>
<li>分段</li>
<li>分页</li>
<li>TLB</li>
</ul>
</li>
<li>Linux 地址空间<ul>
<li>用户空间</li>
<li>内核空间</li>
<li>高内存（high memory）</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="x86-mmu">
<h2>x86 MMU<a class="headerlink" href="#x86-mmu" title="永久链接至标题">¶</a></h2>
<p>x86 内存管理单元（MMU）包括分段单元和分页单元。分段单元可用于定义由逻辑（虚拟）起始地址、基本线性（映射）地址和大小定义的逻辑内存段。段也可以根据访问类型（读取、执行、写入）或特权级别（例如，我们可以定义一些只能由内核访问的段）来限制访问。</p>
<p>当 CPU 进行内存访问时，它将使用分段单元根据段描述符中的信息将逻辑地址转换为线性地址。</p>
<p>如果启用了分页，线性地址将使用页表中的信息进一步转换为物理地址。</p>
<p>请注意，分段单元无法禁用，因此如果启用了 MMU，将始终使用分段。</p>
<p class="admonition-x86-mmu">&nbsp;</p>
<img alt="../_images/ditaa-f3703e3f627a948c59f6f960518d5f68eb7becec.png" src="../_images/ditaa-f3703e3f627a948c59f6f960518d5f68eb7becec.png" />
<div class="section" id="section-2">
<h3>选择器<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h3>
<p>程序可以使用多个段（segment），为了确定使用哪个段，使用了特殊寄存器（称为选择器）。常用的基本选择器有 CS——“代码选择器”，DS——“数据选择器”和 SS——“堆栈选择器”。</p>
<p>指令获取默认使用 CS，而数据访问默认使用 DS，除非使用了堆栈（例如，通过 pop 和 push 指令进行数据访问），这种情况下默认使用 SS。</p>
<p>选择器有三个主要字段：索引，表索引（TI）和运行特权级别（RPL）：</p>
<p class="admonition-">&nbsp;</p>
<img alt="../_images/ditaa-d6845a04f0ec792beec598d2a9f4c5b92c65529e.png" src="../_images/ditaa-d6845a04f0ec792beec598d2a9f4c5b92c65529e.png" />
<p>索引用于确定应使用描述符表的哪个条目。 <cite>TI</cite> 用于选择全局描述符表（GDT）或局部描述符表（LDT）。这些表实际上是从特殊寄存器 <a href="#system-message-1"><span class="problematic" id="problematic-1">`</span></a>GDTR`（用于 GDT）和 <a href="#system-message-2"><span class="problematic" id="problematic-2">`</span></a>LDTR`（用于 LDT）指定的位置开始的数组。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">LDT 设计用于允许应用程序可以定义它们自己的特定段。尽管不是很多应用程序使用此功能，但 Linux（和 Windows）提供了系统调用，允许应用程序创建自己的段。</p>
</div>
<p><cite>RPL</cite> 仅用于 CS，并表示当前特权级别。有 4 个特权级别，最高级别为 0（通常由内核使用），最低级别为 3（通常由用户应用程序使用）。</p>
</div>
<div class="section" id="section-3">
<h3>段描述符<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h3>
<p>CPU 使用选择器的 <cite>index</cite> 字段来访问一个 8 字节的描述符：</p>
<p class="admonition-">&nbsp;</p>
<img alt="../_images/ditaa-5cd4a8fa1ad97cff4bb1f64da13ce9ebfcfc4562.png" src="../_images/ditaa-5cd4a8fa1ad97cff4bb1f64da13ce9ebfcfc4562.png" />
<ul class="simple">
<li>Base: 段的起始线性地址</li>
<li>Limit: 段的大小</li>
<li>G: 粒度位：如果设置，则大小以字节为单位，否则以 4K 页面为单位</li>
<li>B/D: 数据/代码</li>
<li>Type: 代码段、数据/堆栈、TSS、LDT、GDT</li>
<li>Protection: 访问段所需的最低特权级别（RPL 与 DPL 进行比较）</li>
</ul>
<p>一些描述符字段你应该比较熟悉。这是因为它们与我们之前讨论的中断描述符有一些相似之处。</p>
</div>
<div class="section" id="linux">
<h3>Linux 中的分段<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h3>
<p>在 Linux 中，段不用于定义堆栈、代码或数据。这些将使用分页单元进行设置，因为它允许更好的粒度，并且更重要的是，它允许 Linux 使用通用的方法，使得其在其他（不支持分段）的体系架构上也能工作。</p>
<p>然而，由于分段单元无法禁用，Linux 必须创建 4 个通用的 0-4GB 段，分别用于内核代码、内核数据、用户代码和用户数据。</p>
<p>除此之外，Linux 还使用段与 <cite>set_thread_area</cite> 系统调用一起来实现线程本地存储（TLS）。</p>
<p>它还使用 TSS 段来定义内核堆栈，以备在特权级别变化时（例如，在用户空间运行时的系统调用、中断发生时）使用。</p>
<div class="admonition-linux highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Linux 中每个 CPU 的 GDT 布局：</span>
<span class="cm"> *</span>
<span class="cm"> *   0——空（null）                                            &lt;=== 缓存行 #1</span>
<span class="cm"> *   1——保留</span>
<span class="cm"> *   2——保留</span>
<span class="cm"> *   3——保留</span>
<span class="cm"> *</span>
<span class="cm"> *   4——未使用                                                &lt;=== 缓存行 #2</span>
<span class="cm"> *   5——未使用</span>
<span class="cm"> *</span>
<span class="cm"> *  ------- TLS（线程本地存储）段的开始：</span>
<span class="cm"> *</span>
<span class="cm"> *   6——TLS 段 #1                   [ glibc 的 TLS 段 ]</span>
<span class="cm"> *   7——TLS 段 #2                   [ Wine 的 %fs Win32 段 ]</span>
<span class="cm"> *   8——TLS 段 #3                                             &lt;=== 缓存行 #3</span>
<span class="cm"> *   9——保留</span>
<span class="cm"> *  10——保留</span>
<span class="cm"> *  11——保留</span>
<span class="cm"> *</span>
<span class="cm"> *  ------- 内核段的开始：</span>
<span class="cm"> *</span>
<span class="cm"> *  12——内核代码段                                             &lt;=== 缓存行 #4</span>
<span class="cm"> *  13——内核数据段</span>
<span class="cm"> *  14——默认用户 CS</span>
<span class="cm"> *  15——默认用户 DS</span>
<span class="cm"> *  16——TSS                                                   &lt;=== 缓存行 #5</span>
<span class="cm"> *  17——LDT</span>
<span class="cm"> *  18——PNPBIOS 支持（16-&gt;32 门）</span>
<span class="cm"> *  19——PNPBIOS 支持</span>
<span class="cm"> *  20——PNPBIOS 支持                                          &lt;=== 缓存行 #6</span>
<span class="cm"> *  21——PNPBIOS 支持</span>
<span class="cm"> *  22——PNPBIOS 支持</span>
<span class="cm"> *  23——APM BIOS 支持</span>
<span class="cm"> *  24——APM BIOS 支持                                         &lt;=== 缓存行 #7</span>
<span class="cm"> *  25——APM BIOS 支持</span>
<span class="cm"> *</span>
<span class="cm"> *  26——ESPFIX 小型 SS</span>
<span class="cm"> *  27——每个 CPU                 [ 指向每个 CPU 数据区的偏移量 ]</span>
<span class="cm"> *  28——stack_canary-20          [ 用于栈保护 ]                &lt;=== 缓存行 #8</span>
<span class="cm"> *  29——未使用</span>
<span class="cm"> *  30——未使用</span>
<span class="cm"> *  31——用于双重故障处理的 TSS</span>
<span class="cm"> */</span>

 <span class="n">DEFINE_PER_CPU_PAGE_ALIGNED</span><span class="p">(</span><span class="k">struct</span> <span class="n">gdt_page</span><span class="p">,</span> <span class="n">gdt_page</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">gdt</span> <span class="o">=</span> <span class="p">{</span>
 <span class="cp">#ifdef CONFIG_X86_64</span>
         <span class="cm">/*</span>
<span class="cm">          * 在长模式下，我们也需要有效的内核数据和代码段</span>
<span class="cm">          * IRET 将检查段类型  kkeil 2000/10/28</span>
<span class="cm">          * 同样，sysret 需要特殊的 GDT 布局</span>
<span class="cm">          *</span>
<span class="cm">          * 目前，TLS 描述符与 i386 上的位置不同。</span>
<span class="cm">          * 希望没有人期望它们位置固定（Wine？）</span>
<span class="cm">          */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_KERNEL32_CS</span><span class="p">]</span>         <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc09b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_CS</span><span class="p">]</span>           <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xa09b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_DS</span><span class="p">]</span>           <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc093</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER32_CS</span><span class="p">]</span>   <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_DS</span><span class="p">]</span>     <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0f3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_CS</span><span class="p">]</span>     <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xa0fb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
 <span class="cp">#else</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_CS</span><span class="p">]</span>           <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc09a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_KERNEL_DS</span><span class="p">]</span>           <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_CS</span><span class="p">]</span>     <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0fa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_DEFAULT_USER_DS</span><span class="p">]</span>     <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc0f2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="cm">/*</span>
<span class="cm">          * 用于调用 PnPBIOS 的段具有字节粒度。</span>
<span class="cm">          * 代码段和数据段具有固定的 64K 限制，</span>
<span class="cm">          * 传输段的大小在运行时设置。</span>
<span class="cm">          */</span>
         <span class="cm">/* 32 位代码 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_CS32</span><span class="p">]</span>        <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x409a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
         <span class="cm">/* 16 位代码 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_CS16</span><span class="p">]</span>        <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x009a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
         <span class="cm">/* 16 位数据 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_DS</span><span class="p">]</span>          <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x0092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
         <span class="cm">/* 16 位数据 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_TS1</span><span class="p">]</span>         <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x0092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
         <span class="cm">/* 16 位数据 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_PNPBIOS_TS2</span><span class="p">]</span>         <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x0092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
         <span class="cm">/*</span>
<span class="cm">          * APM 段具有字节粒度，并且它们的基址在运行时设置。</span>
<span class="cm">          * 所有段的限制都是 64K。</span>
<span class="cm">          */</span>
         <span class="cm">/* 32 位代码 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_APMBIOS_BASE</span><span class="p">]</span>        <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x409a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
         <span class="cm">/* 16 位代码 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_APMBIOS_BASE</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>      <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x009a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>
         <span class="cm">/* 数据 */</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_APMBIOS_BASE</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>      <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0x4092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xffff</span><span class="p">),</span>

         <span class="p">[</span><span class="n">GDT_ENTRY_ESPFIX_SS</span><span class="p">]</span>           <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="p">[</span><span class="n">GDT_ENTRY_PERCPU</span><span class="p">]</span>              <span class="o">=</span> <span class="n">GDT_ENTRY_INIT</span><span class="p">(</span><span class="mh">0xc092</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mh">0xfffff</span><span class="p">),</span>
         <span class="n">GDT_STACK_CANARY_INIT</span>
 <span class="cp">#endif</span>
 <span class="p">}</span> <span class="p">};</span>
 <span class="n">EXPORT_PER_CPU_SYMBOL_GPL</span><span class="p">(</span><span class="n">gdt_page</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h3>检查选择器和段<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h3>
<p class="admonition-">&nbsp;</p>
<asciinema-player src="../_images/selectors-and-segments.cast"></asciinema-player></div>
<div class="section" id="x86">
<h3>x86 分页<a class="headerlink" href="#x86" title="永久链接至标题">¶</a></h3>
<p>x86 分页单元支持两种类型的分页：常规分页和扩展分页。</p>
<p>常规分页有 2 级，并且固定的页面大小为 4KB。线性地址被分割为三个字段：</p>
<ul class="simple">
<li>目录（directory）（最高的 10 位）</li>
<li>表（table）（接下来的 10 位）</li>
<li>偏移量（offset）（最低的 12 位）</li>
</ul>
<p class="admonition-">&nbsp;</p>
<img alt="../_images/ditaa-def299abebe530d760a6c8f16c791bbb016f9238.png" src="../_images/ditaa-def299abebe530d760a6c8f16c791bbb016f9238.png" />
<p>当启用扩展分页时，使用单级分页，页面大小为 4MB。线性地址被分割为两个字段：</p>
<ul class="simple">
<li>目录（最高的10位）</li>
<li>偏移量（最低的22位）</li>
</ul>
<img alt="../_images/ditaa-709c2e7a68bfcdcfe9c1938d6ef2a0c9b5627931.png" class="admonition-" src="../_images/ditaa-709c2e7a68bfcdcfe9c1938d6ef2a0c9b5627931.png" />
</div>
<div class="section" id="section-5">
<h3>页表<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h3>
<p>我们可以混合使用常规分页和扩展分页，目录页有一个位来指定是使用扩展分页还是常规分页。特殊的 CR3 寄存器指向页目录的基址，而页目录项指向页表的基址。</p>
<p>页目录和页表都有 1024 个条目，每个条目占用 4 字节。</p>
<p>所有表都存储在内存中，页表地址是物理地址。</p>
<span class="admonition-"></span><p>页表项字段：</p>
<ul class="admonition- simple">
<li>存在/不存在</li>
<li>PFN（页面帧号）：物理地址的最高 20 位</li>
<li>访问位——不由硬件更新（可由操作系统用于管理）</li>
<li>脏位——不由硬件更新（可由操作系统用于管理）</li>
<li>访问权限：读/写</li>
<li>特权级别：用户/特权级</li>
<li>页面大小——仅适用于页目录；如果设置，将使用扩展分页</li>
<li>PCD（页面缓存禁用），PWT（页面写穿透）</li>
</ul>
</div>
<div class="section" id="linux-1">
<h3>Linux 分页<a class="headerlink" href="#linux-1" title="永久链接至标题">¶</a></h3>
<p>Linux 分页使用 4 个级别以支持 64 位架构。下图显示了如何使用多个虚拟地址块来索引页表并计算物理地址。</p>
<img alt="../_images/ditaa-5e4d73e3fcb24db9d1f8c16daddf98694c063fe6.png" class="admonition-linux" src="../_images/ditaa-5e4d73e3fcb24db9d1f8c16daddf98694c063fe6.png" />
<p>Linux 具有用于创建和遍历页表的通用 API。借助于此我们可以实现使用相同的通用代码来创建和修改内核和进程的地址空间，该代码依赖于宏和函数，将这些通用操作转换为在不同体系结构上运行的代码。</p>
<p>以下是使用 Linux 页表 API 将虚拟地址转换为物理地址的示例：</p>
<div class="admonition-linux-api highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="o">*</span> <span class="n">page</span><span class="p">;</span>
<span class="n">pgd_t</span> <span class="n">pgd</span><span class="p">;</span>
<span class="n">pmd_t</span> <span class="n">pmd</span><span class="p">;</span>
<span class="n">pud_t</span> <span class="n">pud</span><span class="p">;</span>
<span class="n">pte_t</span> <span class="n">pte</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="n">laddr</span><span class="p">,</span> <span class="o">*</span><span class="n">paddr</span><span class="p">;</span>

<span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_offset</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="n">pud</span> <span class="o">=</span> <span class="n">pud_offet</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="n">pmd</span> <span class="o">=</span> <span class="n">pmd_offset</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="n">pte</span> <span class="o">=</span> <span class="n">pte_offset</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="n">page</span> <span class="o">=</span> <span class="n">pte_page</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="n">laddr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="n">paddr</span> <span class="o">=</span> <span class="n">virt_to_phys</span><span class="p">(</span><span class="n">laddr</span><span class="p">);</span>
</pre></div>
</div>
<p>为了支持具有少于 4 级分页的体系结构（例如32位 x86），某些宏和/或函数可以为 0/空：</p>
<div class="admonition- highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kr">inline</span> <span class="n">pud_t</span> <span class="o">*</span> <span class="nf">pud_offset</span><span class="p">(</span><span class="n">pgd_t</span> <span class="o">*</span> <span class="n">pgd</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pgd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">pmd_t</span> <span class="o">*</span> <span class="nf">pmd_offset</span><span class="p">(</span><span class="n">pud_t</span> <span class="o">*</span> <span class="n">pud</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pmd_t</span> <span class="o">*</span><span class="p">)</span><span class="n">pud</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="tlb">
<h3>转译后备缓冲区（TLB）<a class="headerlink" href="#tlb" title="永久链接至标题">¶</a></h3>
<p>在使用虚拟内存时，由于表页组织的原因，我们可能需要额外进行 1 次（x86 扩展分页）、2 次（x86 常规分页）或 3 次（x86 64 位）内存访问。</p>
<p>一个称为转译后备缓冲区（TLB）的特殊缓存用于加速从虚拟地址到物理地址的转换。</p>
<p>TLB 具有以下特性：</p>
<ul class="admonition-tlb simple">
<li>缓存分页信息（PFN、权限、特权级别）</li>
<li>内容寻址存储器/关联存储器<ul>
<li>非常小（64-128）</li>
<li>非常快（由于并行搜索实现，单周期）</li>
</ul>
</li>
<li>CPU 通常有两个 TLB：i-TLB（代码）和 d-TLB（数据）</li>
<li>TLB 缺失耗损：高达数百个周期</li>
</ul>
<p>与其他缓存一样，我们必须小心，以免产生一致性问题。</p>
<p>例如，当更改将一页的映射指向页表中的另一个物理内存位置时，我们必须使关联的 TLB 条目无效。否则，MMU 将执行转换到旧的物理地址而不是新的物理地址。</p>
<p>x86 平台可以通过两种类型的操作使 TLB 失效。</p>
<p class="admonition-tlb">单地址失效：</p>
<div class="highlight-asm"><div class="highlight"><pre><span></span>mov $addr, %eax
invlpg %(eax)
</pre></div>
</div>
<p>全失效：</p>
<div class="highlight-asm"><div class="highlight"><pre><span></span><span class="nf">mov</span> <span class="nv">%cr3</span><span class="p">,</span> <span class="nv">%eax</span>
<span class="nf">mov</span> <span class="nv">%eax</span><span class="p">,</span> <span class="nv">%cr3</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="linux-2">
<h2>Linux 地址空间<a class="headerlink" href="#linux-2" title="永久链接至标题">¶</a></h2>
<div class="section" id="section-6">
<h3>32 位系统的地址空间选项<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h3>
<p>实现内核和用户空间有两个主要选项：为每个空间提供专用地址空间，或者分割一个共享的地址空间。</p>
<p class="admonition-">&nbsp;</p>
<img alt="../_images/ditaa-4e8b5b1d7c8bd252282e6e72f5fd44a839e028ca.png" src="../_images/ditaa-4e8b5b1d7c8bd252282e6e72f5fd44a839e028ca.png" />
<p>每种选项都有优缺点：</p>
<ul class="admonition- simple">
<li>专用内核空间的缺点：<ul>
<li>每次系统调用都需要完全使 TLB 失效</li>
</ul>
</li>
<li>共享地址空间的缺点：<ul>
<li>内核和用户进程的地址空间较小</li>
</ul>
</li>
</ul>
<p>Linux 在 32 位系统中使用分割地址空间，尽管在过去还有支持 4/4 分割或专用内核地址空间的选项（在支持的体系结构上，如 x86）。Linux 在 64 位系统中始终使用分割地址空间。</p>
<p>下面是 Linux 地址空间的概述：</p>
<p class="admonition-linux">&nbsp;</p>
<img alt="../_images/ditaa-3985c420def8f30934a72ea8c738a00ed629c298.png" src="../_images/ditaa-3985c420def8f30934a72ea8c738a00ed629c298.png" />
</div>
<div class="section" id="section-7">
<h3>线性映射<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h3>
<p>线性映射是一种特定的虚拟页面到物理页面的映射方式，其中虚拟页面 V、V + 1、...、V + n 被映射到物理页面 P、P + 1、...、P + n。</p>
<p>为了理解线性映射的必要性，我们应该看一下涉及同时使用虚拟地址和物理地址的页面的常见内核操作，如 I/O 传输：</p>
<ul class="admonition-i-o simple">
<li>使用内核缓冲区的虚拟地址从用户空间复制数据</li>
<li>遍历页表将内核缓冲区的虚拟地址转换为物理地址</li>
<li>使用内核缓冲区的物理地址启动 DMA 传输</li>
</ul>
<p>但是，如果我们使用线性映射，并且内核缓冲区位于线性映射区域中，那么：</p>
<ul class="admonition- simple">
<li>虚拟地址到物理地址空间的转换可以减少为一次操作（而不是遍历页表）</li>
<li>使用更少的内存来创建页表</li>
<li>内核内存使用更少的 TLB 条目</li>
</ul>
</div>
<div class="section" id="section-8">
<h3>高内存<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p>虚拟地址空间中的“高内存”部分用于创建任意映射（与低内存中的线性映射相对）。在 32 位系统中，高内存区域绝对是必需的，以便访问低内存以外的物理内存。然而，高内存在 64 位系统上也被使用，但主要用于允许内核空间中的任意映射。</p>
<p class="admonition-">&nbsp;</p>
<img alt="../_images/ditaa-bb8455a43088bf800eece11869f6ff857574605d.png" src="../_images/ditaa-bb8455a43088bf800eece11869f6ff857574605d.png" />
<p>高内存区域有多种类型的映射：</p>
<ul class="simple">
<li>多页面永久映射（vmalloc、ioremap）</li>
<li>临时的单页面映射（atomic_kmap）</li>
<li>永久的单页面映射（kmap、固定映射的线性地址）</li>
</ul>
<p>多页面映射允许将物理内存范围映射到高内存区域。每个这样的映射都由一个不可访问的页面保护，以捕获缓冲区溢出和下溢错误。</p>
<p>将多个页面映射到高内存的 API 包括：</p>
<div class="admonition- highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span> <span class="nf">vmalloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">vfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">);</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">ioremap</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">iounmap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">addr</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">vmalloc()</span></code> 用于在内核虚拟地址空间中分配非连续的系统内存页面作为连续段。它在分配大型缓冲区时非常有用，因为由于碎片化，很难找到连续的大块物理内存空闲。</p>
<p><code class="xref c c-func docutils literal"><span class="pre">ioremap()</span></code> 用于将内核地址空间映射到设备内存或设备寄存器。它将连续的物理内存范围映射到高内存，并禁用页面缓存。</p>
</div>
<div class="section" id="section-9">
<h3>固定映射的线性地址<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h3>
<p>固定映射的线性地址是一类特殊的单页面映射，用于访问常用外设（如 APIC 或 IO APIC）的寄存器。</p>
<p>典型的外设 I/O 访问方式是使用基址（内核虚拟地址空间中映射外设寄存器的位置）+ 不同寄存器的偏移量。</p>
<p>为了优化访问速度，基址在编译时被预留（例如，0xFFFFF000）。由于基址是常量，形如 <cite>base + register offset</cite> 的寄存器访问也是常量，因此编译器会避免生成额外的指令。</p>
<p>总结一下，固定映射的线性地址是：</p>
<ul class="admonition- simple">
<li>预留的虚拟地址（常量）</li>
<li>在引导（boot）过程中映射到物理地址</li>
</ul>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">set_fixmap</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">)</span>
<span class="n">set_fixmap_nocache</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">phys_addr</span><span class="p">)</span>
</pre></div>
</div>
<p>这些地址是由体系结构定义的，以 x86 为例，以下是其映射表：</p>
<div class="admonition- highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * 这里定义了所有在编译时“特殊”的虚拟地址。</span>
<span class="cm"> * 目的是在编译时有一个常量地址，但物理地址只在引导过程中设置。</span>
<span class="cm"> * 对于 x86_32：我们从虚拟内存的末尾（0xfffff000）开始分配这些特殊地址。</span>
<span class="cm"> * 这样还可以保证安全的 vmalloc()，可以确保这些特殊地址和 vmalloc() 的地址不重叠。</span>
<span class="cm"> *</span>
<span class="cm"> * 这些“编译时分配”的内存缓冲区是固定大小的 4k 页（如果使用的增量大于 1，则可以更大）。</span>
<span class="cm"> * 使用 set_fixmap(idx,phys) 将物理内存与 fixmap 索引关联起来。</span>
<span class="cm"> *</span>
<span class="cm"> * 这些缓冲区的 TLB 条目在任务切换时不会被刷新。</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">fixed_addresses</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
    <span class="n">FIX_HOLE</span><span class="p">,</span>
<span class="cp">#else</span>
<span class="cp">#ifdef CONFIG_X86_VSYSCALL_EMULATION</span>
    <span class="n">VSYSCALL_PAGE</span> <span class="o">=</span> <span class="p">(</span><span class="n">FIXADDR_TOP</span> <span class="o">-</span> <span class="n">VSYSCALL_ADDR</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
    <span class="n">FIX_DBGP_BASE</span><span class="p">,</span>
    <span class="n">FIX_EARLYCON_MEM_BASE</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PROVIDE_OHCI1394_DMA_INIT</span>
    <span class="n">FIX_OHCI1394_BASE</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_LOCAL_APIC</span>
    <span class="n">FIX_APIC_BASE</span><span class="p">,</span>        <span class="cm">/* 本地（CPU）APIC - 对 SMP 有要求或无要求 */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_IO_APIC</span>
    <span class="n">FIX_IO_APIC_BASE_0</span><span class="p">,</span>
    <span class="n">FIX_IO_APIC_BASE_END</span> <span class="o">=</span> <span class="n">FIX_IO_APIC_BASE_0</span> <span class="o">+</span> <span class="n">MAX_IO_APICS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_32</span>
    <span class="n">FIX_KMAP_BEGIN</span><span class="p">,</span>       <span class="cm">/* 用于临时内核映射的保留 pte */</span>
    <span class="n">FIX_KMAP_END</span> <span class="o">=</span> <span class="n">FIX_KMAP_BEGIN</span><span class="o">+</span><span class="p">(</span><span class="n">KM_TYPE_NR</span><span class="o">*</span><span class="n">NR_CPUS</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_PCI_MMCONFIG</span>
    <span class="n">FIX_PCIE_MCFG</span><span class="p">,</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>请注意，虚拟地址和固定地址索引之间的转换是多么容易：</p>
<div class="admonition- highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define __fix_to_virt(x)  (FIXADDR_TOP - ((x) &lt;&lt; PAGE_SHIFT))</span>
<span class="cp">#define __virt_to_fix(x)  ((FIXADDR_TOP - ((x)&amp;PAGE_MASK)) &gt;&gt; PAGE_SHIFT)</span>

<span class="cp">#ifndef __ASSEMBLY__</span>
<span class="cm">/*</span>
<span class="cm"> * ‘索引到地址’转换。如果有人直接使用索引而没有进行转换，我们会通过一个空指针解引用内核崩溃来捕捉该错误。我们还会捕捉到非法的索引范围。</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">fix_to_virt</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">__end_of_fixed_addresses</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">virt_to_fix</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">vaddr</span> <span class="o">&gt;=</span> <span class="n">FIXADDR_TOP</span> <span class="o">||</span> <span class="n">vaddr</span> <span class="o">&lt;</span> <span class="n">FIXADDR_START</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">__virt_to_fix</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
<span class="p">}</span>


<span class="kr">inline</span> <span class="kt">long</span> <span class="nf">fix_to_virt</span><span class="p">(</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">__end_of_fixed_addresses</span><span class="p">)</span>
        <span class="n">__this_fixmap_does_not_exist</span><span class="p">();</span>
    <span class="k">return</span> <span class="p">(</span><span class="mh">0xffffe000UL</span> <span class="o">-</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-10">
<h3>临时映射<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h3>
<p>临时映射可用于在内核空间中快速映射单个物理页面。它可以在中断上下文中使用，但是原子 kmap 部分在 <code class="xref c c-func docutils literal"><span class="pre">kmap_atomic()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">kunmap_atomic()</span></code> 之间定义，不能被抢占。这就是为什么它们被称为临时映射，因为它们只能短暂使用。</p>
<span class="admonition-"></span><p>临时映射非常快速，因为不需要锁定或搜索，并且不需要完全无效化 TLB，只需无效化特定的虚拟页。</p>
<p>以下是一些展示临时映射实现的代码片段：</p>
<div class="admonition- highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define kmap_atomic(page) kmap_atomic_prot(page, kmap_prot)</span>

<span class="kt">void</span> <span class="o">*</span><span class="nf">kmap_atomic_high_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">pgprot_t</span> <span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">idx</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>

   <span class="n">type</span> <span class="o">=</span> <span class="n">kmap_atomic_idx_push</span><span class="p">();</span>
   <span class="n">idx</span> <span class="o">=</span> <span class="n">type</span> <span class="o">+</span> <span class="n">KM_TYPE_NR</span><span class="o">*</span><span class="n">smp_processor_id</span><span class="p">();</span>
   <span class="n">vaddr</span> <span class="o">=</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_KMAP_BEGIN</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>
   <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">kmap_pte</span><span class="o">-</span><span class="n">idx</span><span class="p">)));</span>
   <span class="n">set_pte</span><span class="p">(</span><span class="n">kmap_pte</span><span class="o">-</span><span class="n">idx</span><span class="p">,</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">prot</span><span class="p">));</span>
   <span class="n">arch_flush_lazy_mmu_mode</span><span class="p">();</span>

   <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmap_atomic_high_prot</span><span class="p">);</span>

      <span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">kmap_atomic_idx_push</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
      <span class="p">{</span>
   <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">__this_cpu_inc_return</span><span class="p">(</span><span class="n">__kmap_atomic_idx</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

      <span class="cp">#ifdef CONFIG_DEBUG_HIGHMEM</span>
   <span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">in_irq</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">irqs_disabled</span><span class="p">());</span>
   <span class="n">BUG_ON</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">KM_TYPE_NR</span><span class="p">);</span>
      <span class="cp">#endif</span>
   <span class="k">return</span> <span class="n">idx</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>请注意，这里使用了固定映射的线性地址和类似堆栈的方法：每个 CPU 都有 KM_TYPE_NR 个保留条目，按照先入先出的顺序使用。这允许同时使用多个临时映射，例如在进程上下文中使用一个，在中断处理程序中使用一个，以及在任务队列或软中断中使用几个。</p>
<span class="admonition-"></span></div>
<div class="section" id="section-11">
<h3>永久映射<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h3>
<p>永久映射允许用户在长时间（未定义的）期间保持映射，这意味着在映射之后和释放之前可以进行上下文切换。</p>
<p>然而，这种灵活性是有代价的。需要执行搜索操作来找到一个空闲条目，并且它们不能在中断上下文中使用——尝试找到一个空闲的虚拟地址页面的操作可能会阻塞。永久映射的可用数量是有限的（通常保留一页用于永久映射）。</p>
<span class="admonition-"></span></div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lec5-smp.html" class="btn btn-neutral float-left" title="SO2 Lecture 05 - Symmetric Multi-Processing" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lec7-memory-management.html" class="btn btn-neutral float-right" title="SO2 Lecture 07 - Memory Management" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>