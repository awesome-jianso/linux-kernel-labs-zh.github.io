<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta content="了解 Linux 中虚拟文件系统（VFS）的知识，理解有关“inode”、“dentry”、“文件”、“超级块”和数据块的概念，理解在 VFS 内挂载文件系统的过程了解各种文件系统类型，并理解具有物理支持（在磁盘上）和没有物理支持的文件系统之间的区别" name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 实验 08——文件系统驱动（第一部分） &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="SO2 实验 09——文件系统驱动程序（第二部分）" href="lab9-filesystems-part2.html" />
    <link rel="prev" title="SO2 实验 07——块设备驱动" href="lab7-block-device-drivers.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">操作系统 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01——课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 课程 02——系统调用</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 课程 03——进程</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 课程 04——中断</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 课程 05——对称多处理</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 课程 06——地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 课程 07——内存管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 课程 08——文件系统管理</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 课程 09——内核调试</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 课程 10——网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 课程 11——体系结构层</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 课程 12——虚拟化</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 实验 01——介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 实验 02——内核 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 实验 03——字符设备驱动</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 实验 04——I/O 访问和中断</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 实验 05——延迟工作</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 实验 06——内存映射</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 实验 07——块设备驱动</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 实验 08——文件系统驱动（第一部分）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-1">实验目标</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vfs">虚拟文件系统（VFS）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">常见的文件系统模型</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-3">超级块</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inode">inode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#file">file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-7">目录项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-8">注册和注销文件系统</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#mount-kill-sb">mount 和 kill_sb 函数</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#vfs-1">VFS 中的超级块</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-9">超级块操作</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#fill-super"><code class="docutils literal"><span class="pre">fill_super()</span></code> 函数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-10">缓冲区缓存</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-11">函数和有用的宏</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-12">进一步阅读</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">练习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#myfs">myfs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minfs">minfs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 实验 09——文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 实验 10——网络</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 实验 11——ARM 内核开发</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 实验 12——内核分析</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">合作</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">作业 0——内核 API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">作业 1——基于 Kprobe 的跟踪器</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">作业 2——驱动 UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">作业 3——软件 RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">作业 4——SO2 传输协议</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">作业 7——使用 KVM 的 SO2 虚拟机管理器</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">体系结构层</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">虚拟化</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">操作系统 2</a></li>
      <li class="breadcrumb-item active">SO2 实验 08——文件系统驱动（第一部分）</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab8-filesystems-part1.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-08">
<h1>SO2 实验 08——文件系统驱动（第一部分）<a class="headerlink" href="#so2-08" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-1">
<h2>实验目标<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>了解 Linux 中虚拟文件系统（VFS）的知识，理解有关“inode”、“dentry”、“文件”、“超级块”和数据块的概念。</li>
<li>理解在 VFS 内挂载文件系统的过程。</li>
<li>了解各种文件系统类型，并理解具有物理支持（在磁盘上）和没有物理支持的文件系统之间的区别。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="vfs">
<h2>虚拟文件系统（VFS）<a class="headerlink" href="#vfs" title="永久链接至标题">¶</a></h2>
<p>虚拟文件系统（也称为 VFS）是内核的组件，处理所有与文件和文件系统相关的系统调用。VFS 是用户与特定文件系统之间的通用接口。这种抽象简化了文件系统的实现，并使得多个文件系统更容易集成。这样，通过使用 VFS 提供的 API 来实现文件系统，通用硬件以及 I/O 子系统的通信部分由 VFS 处理。</p>
<p>从功能的角度来看，文件系统可以分为以下几类：</p>
<blockquote>
<div><ul class="simple">
<li>磁盘文件系统（ext3、ext4、xfs、fat 以及 ntfs 等）</li>
<li>网络文件系统（nfs、smbfs/cifs、ncp 等）</li>
<li>虚拟文件系统（procfs、sysfs、sockfs、pipefs 等）</li>
</ul>
</div></blockquote>
<p>Linux 内核实例使用 VFS 来处理目录和文件的层次结构（一棵树）。通过挂载操作，新的文件系统将被添加为 VFS 子树。文件系统通常是从其所对应的环境中挂载的（从块类型设备、网络等）。然而，VFS 可以将普通文件作为虚拟块设备使用，因此可以将普通文件挂载为磁盘文件系统。这样，可以创建文件系统的堆叠。</p>
<p>VFS 的基本思想是提供可以表示任何文件系统文件的单一文件模型。文件系统驱动程序需要遵守公共的基准。这样，内核可以创建包含整个系统的单一目录结构。其中一个文件系统将作为根文件系统，其他文件系统将挂载在其各个目录下。</p>
</div>
<div class="section" id="section-2">
<h2>常见的文件系统模型<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<p>常见的文件系统模型（任何实现的文件系统都需要符合该模型）包括几种明确定义的实体: <code class="xref c c-type docutils literal"><span class="pre">superblock</span></code>, <code class="xref c c-type docutils literal"><span class="pre">inode</span></code>, <code class="xref c c-type docutils literal"><span class="pre">file</span></code> 和 <code class="xref c c-type docutils literal"><span class="pre">dentry</span></code>。这些实体是文件系统的元数据（包含有关数据或其他元数据的信息）。</p>
<p>模型实体间通过某些 VFS 子系统或内核子系统进行交互：dentry cache（目录项缓存）、inode cache（索引节点缓存）和 buffer cache（缓冲区缓存）。每个实体都被视为对象：它具有关联的数据结构和指向方法表的指针。通过替换关联的方法来为每个组件引入特定的行为。</p>
<div class="section" id="section-3">
<h3>超级块<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h3>
<p>超级块存储了挂载文件系统所需的信息：</p>
<blockquote>
<div><ul class="simple">
<li>inode 和块的位置</li>
<li>文件系统块大小</li>
<li>最大文件名长度</li>
<li>最大文件大小</li>
<li>根 inode 的位置</li>
</ul>
</div></blockquote>
<div class="section" id="section-4">
<h4>本地化：<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>对于磁盘文件系统，超级块在磁盘的第一个块中有对应项（文件系统控制块）。</li>
<li>在 VFS 中，所有文件系统的超级块都保留在类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 的结构列表中，方法则保留在类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> 的结构中。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="inode">
<h3>inode<a class="headerlink" href="#inode" title="永久链接至标题">¶</a></h3>
<p>inode（索引节点）保存了有关文件的信息。注意这里的文件指的是泛指意义上的文件，常规文件、目录、特殊文件（管道、fifo）、块设备、字符设备、链接或可以抽象为文件的任何内容都包括在内。</p>
<p>inode 存储了以下信息：</p>
<blockquote>
<div><ul class="simple">
<li>文件类型；</li>
<li>文件大小；</li>
<li>访问权限；</li>
<li>访问或修改时间；</li>
<li>数据在磁盘上的位置（指向包含数据的磁盘块的指针）。</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">通常，inode 不包含文件名。文件名由 <code class="xref c c-type docutils literal"><span class="pre">dentry</span></code> 实体存储。这样，一个 inode 可以有多个名称（硬链接）。</p>
</div>
<div class="section" id="section-5">
<h4>本地化：<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h4>
<p>与 superblock 类似，<code class="xref c c-type docutils literal"><span class="pre">inode</span></code> 也有磁盘对应项。磁盘上的 inodes 通常分组存储在一个专用区域（inode 区域）中，与数据块区域分开；在某些文件系统中，与 inodes 等效的内容分散在文件系统结构中（FAT）；作为 VFS 实体，inode 由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> 结构表示，并由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode_operations</span></code> 结构定义与之相关的操作。</p>
<p>通常，每个 inode 都通过编号进行标识。在 Linux 上, <code class="docutils literal"><span class="pre">ls</span></code> 命令的 <code class="docutils literal"><span class="pre">-i</span></code> 实参显示与每个文件关联的 inode 编号：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">razvan@valhalla:~/school/so2/wiki$</span> ls -i
<span class="go">1277956 lab10.wiki  1277962 lab9.wikibak  1277964 replace_lxr.sh</span>
<span class="go">1277954 lab9.wiki   1277958 link.txt      1277955 homework.wiki</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="file">
<h3>file<a class="headerlink" href="#file" title="永久链接至标题">¶</a></h3>
<p>file 是文件系统模型中距离用户最近的组件。该结构体仅作为 VFS（虚拟文件系统）在内存中的实体存在，没有在磁盘上的物理对应物。</p>
<p>inode 抽象了磁盘上的文件，而 file 结构抽象了打开的文件。从进程的角度来看，file 实体抽象了文件。然而，从文件系统实现的角度来看，inode 才是抽象文件的那个实体。</p>
<p>file 结构维护了以下信息：</p>
<blockquote>
<div><ul class="simple">
<li>文件游标位置；</li>
<li>文件打开权限；</li>
<li>指向关联 inode 的指针（最终是 inode 的索引）。</li>
</ul>
</div></blockquote>
<div class="section" id="section-6">
<h4>本地化：<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><ul class="simple">
<li>与之关联的 VFS 实体是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> 结构，与之相关的操作由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> 结构表示。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="section-7">
<h3>目录项<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h3>
<p>目录项（dentry）将 inode 与文件名关联起来。</p>
<p>通常，dentry 结构包含两个字段：</p>
<blockquote>
<div><ul class="simple">
<li>用于标识 inode 的整数；</li>
<li>表示文件名的字符串。</li>
</ul>
</div></blockquote>
<p>dentry 是目录或文件路径的特定部分。例如，对于路径 <code class="docutils literal"><span class="pre">/bin/vi</span></code>，将为 <code class="docutils literal"><span class="pre">/</span></code>, <code class="docutils literal"><span class="pre">bin</span></code> 和 <code class="docutils literal"><span class="pre">vi</span></code> 创建 dentry 对象（总共 3 个 dentry 对象）。</p>
<blockquote>
<div><ul class="simple">
<li>dentry 在磁盘上有对应物，但对应关系不是直接的，因为每个文件系统都以特定方式维护 dentry。</li>
<li>在 VFS 中，dentry 实体由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span></code> 结构表示，与之相关的操作在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry_operations</span></code> 结构中定义。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="section-8">
<h2>注册和注销文件系统<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h2>
<p>在当前版本中，Linux 内核支持约 50 种文件系统，包括：</p>
<blockquote>
<div><ul class="simple">
<li>ext2/ext4</li>
<li>reiserfs</li>
<li>xfs</li>
<li>fat</li>
<li>ntfs</li>
<li>iso9660</li>
<li>用于 CD 和 DVD 的 udf</li>
<li>hpfs</li>
</ul>
</div></blockquote>
<p>然而，在单个系统上，不太可能有超过 5-6 个文件系统。因此，文件系统（更准确地说，文件系统类型）被实现为模块，并可以随时加载或卸载。</p>
<p>为了能够动态加载/卸载文件系统模块，文件系统注册/注销 API 是不可或缺的。描述特定文件系统的结构是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code>：</p>
<blockquote>
<div><blockquote>
<div><div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">file_system_type</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
         <span class="kt">int</span> <span class="n">fs_flags</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mount</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
         <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
         <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">fs_supers</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_lock_key</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">s_umount_key</span><span class="p">;</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">name</span></code> 是表示文件系统名称的字符串（传递给 <code class="docutils literal"><span class="pre">mount</span> <span class="pre">-t</span></code> 的参数）。</li>
<li><code class="docutils literal"><span class="pre">owner</span></code> 对于以模块形式实现的文件系统来说是 <code class="docutils literal"><span class="pre">THIS_MODULE</span></code>，如果直接编写在内核中，则 <code class="docutils literal"><span class="pre">owner</span></code> 为 <code class="docutils literal"><span class="pre">NULL</span></code>。</li>
<li><code class="docutils literal"><span class="pre">mount</span></code> 函数在加载文件系统时从磁盘中读取超级块到内存中。每种文件系统的函数都是独一无二的。</li>
<li><code class="docutils literal"><span class="pre">kill_sb</span></code> 函数释放内存中的超级块。</li>
<li><code class="docutils literal"><span class="pre">fs_flags</span></code> 指定文件系统必须以哪些标志挂载。例如, <code class="docutils literal"><span class="pre">FS_REQUIRES_DEV</span></code> 是一个标志，指定 VFS 文件系统需要一个磁盘（而不是虚拟文件系统）。</li>
<li><code class="docutils literal"><span class="pre">fs_supers</span></code> 是一个列表，包含与该文件系统关联的所有超级块。由于同一文件系统可能会被多次挂载，因此每个挂载点都会有一个单独的超级块。</li>
</ul>
</div></blockquote>
<p>通常，在模块初始化函数中，将 <em>文件系统注册</em> 到内核。要进行注册，程序员需要：</p>
<blockquote>
<div><ol class="arabic simple">
<li>使用名称、标志、实现超级块读取操作的函数以及对标识当前模块的结构的引用来初始化 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> 类型的结构体。</li>
<li>调用 <code class="xref c c-func docutils literal"><span class="pre">register_filesystem()</span></code> 函数。</li>
</ol>
</div></blockquote>
<p>在卸载模块时，必须调用 <code class="xref c c-func docutils literal"><span class="pre">unregister_filesystem()</span></code> 函数来注销文件系统。</p>
<p>在 <code class="docutils literal"><span class="pre">ramfs</span></code> 的代码中可以找到注册虚拟文件系统的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">ramfs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">&quot;ramfs&quot;</span><span class="p">,</span>
        <span class="p">.</span><span class="n">mount</span>          <span class="o">=</span> <span class="n">ramfs_mount</span><span class="p">,</span>
        <span class="p">.</span><span class="n">kill_sb</span>        <span class="o">=</span> <span class="n">ramfs_kill_sb</span><span class="p">,</span>
        <span class="p">.</span><span class="n">fs_flags</span>       <span class="o">=</span> <span class="n">FS_USERNS_MOUNT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_ramfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">once</span><span class="p">))</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ramfs_fs_type</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="mount-kill-sb">
<span id="functionsmountkillsbsection"></span><h3>mount 和 kill_sb 函数<a class="headerlink" href="#mount-kill-sb" title="永久链接至标题">¶</a></h3>
<p>在挂载文件系统时，内核调用了在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> 结构中定义的 mount 函数。该函数进行一系列的初始化操作，并返回表示挂载点目录的 dentry（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span></code> 结构）。通常，<code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> 是一个简单的函数，该函数调用以下函数之一：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">mount_bdev()</span></code>：挂载存储在块设备上的文件系统</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mount_single()</span></code>：挂载在所有挂载操作之间共享实例的文件系统</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mount_nodev()</span></code>：挂载不在物理设备上的文件系统</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mount_pseudo()</span></code>：用于伪文件系统的辅助函数（如 <code class="docutils literal"><span class="pre">sockfs</span></code>, <code class="docutils literal"><span class="pre">pipefs</span></code> 等无法被挂载的文件系统）</li>
</ul>
</div></blockquote>
<p>这些函数的其中一个参数是指向 <code class="xref c c-func docutils literal"><span class="pre">fill_super()</span></code> 函数的指针，该函数在超级块初始化之后被调用，以借助驱动程序完成超级块的初始化。在 <code class="docutils literal"><span class="pre">fill_super</span></code> 部分可以找到此类函数的示例。</p>
<p>在卸载文件系统时，内核调用 <code class="xref c c-func docutils literal"><span class="pre">kill_sb()</span></code> 函数，执行清理操作，并调用以下函数之一：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">kill_block_super()</span></code>：卸载块设备上的文件系统</li>
<li><code class="xref c c-func docutils literal"><span class="pre">kill_anon_super()</span></code>：卸载虚拟文件系统（当请求时生成信息）</li>
<li><code class="xref c c-func docutils literal"><span class="pre">kill_litter_super()</span></code>：卸载不在物理设备上的文件系统（信息保存在内存中）。</li>
</ul>
</div></blockquote>
<p>关于没有磁盘支持的文件系统，一个示例是 <code class="docutils literal"><span class="pre">ramfs</span></code> 文件系统的 <code class="xref c c-func docutils literal"><span class="pre">ramfs_mount()</span></code> 函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">ramfs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">mount_nodev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ramfs_fill_super</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>关于来自磁盘的文件系统，一个示例是 <code class="docutils literal"><span class="pre">minix</span></code> 文件系统的 <code class="xref c c-func docutils literal"><span class="pre">minix_mount()</span></code> 函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">minix_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
         <span class="k">return</span> <span class="n">mount_bdev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">minix_fill_super</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="vfs-1">
<h2>VFS 中的超级块<a class="headerlink" href="#vfs-1" title="永久链接至标题">¶</a></h2>
<p>超级块既作为物理实体（磁盘上的实体）存在，也作为 VFS 实体（在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 结构中）存在。超级块仅包含元信息，并用于从磁盘中读取和写入元数据（如 inode、目录项）。超级块（以及隐式的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 结构）将包含有关所使用的块设备、inode 列表、文件系统根目录的 inode 指针以及超级块操作的指针的信息。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 结构的部分定义如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">super_block</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="kt">dev_t</span>                   <span class="n">s_dev</span><span class="p">;</span>              <span class="cm">/* 标识符 */</span>
        <span class="kt">unsigned</span> <span class="kt">char</span>           <span class="n">s_blocksize_bits</span><span class="p">;</span>   <span class="cm">/* 块大小（以位为单位） */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">s_blocksize</span><span class="p">;</span>        <span class="cm">/* 块大小（以字节为单位） */</span>
        <span class="kt">unsigned</span> <span class="kt">char</span>           <span class="n">s_dirt</span><span class="p">;</span>             <span class="cm">/* 脏标志 */</span>
        <span class="n">loff_t</span>                  <span class="n">s_maxbytes</span><span class="p">;</span>         <span class="cm">/* 最大文件大小 */</span>
        <span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">s_type</span><span class="p">;</span>            <span class="cm">/* 文件系统类型 */</span>
        <span class="k">struct</span> <span class="n">super_operations</span> <span class="o">*</span><span class="n">s_op</span><span class="p">;</span>              <span class="cm">/* 超级块方法 */</span>
        <span class="c1">//...</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">s_flags</span><span class="p">;</span>            <span class="cm">/* 挂载标志 */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">s_magic</span><span class="p">;</span>            <span class="cm">/* 文件系统的魔数 */</span>
        <span class="k">struct</span> <span class="n">dentry</span>           <span class="o">*</span><span class="n">s_root</span><span class="p">;</span>            <span class="cm">/* 目录挂载点 */</span>
        <span class="c1">//...</span>
        <span class="kt">char</span>                    <span class="n">s_id</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>           <span class="cm">/* 信息标识符 */</span>
        <span class="kt">void</span>                    <span class="o">*</span><span class="n">s_fs_info</span><span class="p">;</span>         <span class="cm">/* 文件系统私有信息 */</span>
<span class="p">};</span>
</pre></div>
</div>
<dl class="docutils">
<dt>超级块存储了文件系统实例的全局信息：</dt>
<dd><ul class="first last simple">
<li>所使用的物理设备</li>
<li>块大小</li>
<li>文件的最大大小</li>
<li>文件系统类型</li>
<li>支持的操作</li>
<li>魔数（用于标识文件系统）</li>
<li>根目录的 <code class="docutils literal"><span class="pre">dentry</span></code></li>
</ul>
</dd>
</dl>
<p>此外，一个通用指针 (<code class="docutils literal"><span class="pre">void</span> <span class="pre">*</span></code>) 用于存储文件系统的私有数据。超级块可以被视为一个抽象对象，在具体实现时，会向其中添加自己的数据。</p>
<div class="section" id="section-9">
<span id="superblocksection"></span><h3>超级块操作<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h3>
<p>超级块操作由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> 结构描述：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">super_operations</span> <span class="p">{</span>
       <span class="c1">//...</span>
       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">);</span>
       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">);</span>
       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>

       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
       <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>该结构的字段是具有以下含义的函数指针：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">write_inode</span></code>, <code class="docutils literal"><span class="pre">alloc_inode</span></code> 与 <code class="docutils literal"><span class="pre">destroy_inode</span></code> 分别用于写入、分配和释放与 inode 相关的资源，将在下一个实验中进行详细描述。</li>
<li><code class="docutils literal"><span class="pre">put_super</span></code> 在卸载时调用，释放文件系统私有数据的任何资源（通常是内存）；</li>
<li><code class="docutils literal"><span class="pre">remount_fs</span></code> 在内核检测到重新挂载尝试（挂载标志 <code class="docutils literal"><span class="pre">MS_REMOUNTM</span></code>）时调用；大部分情况下，需要检测是否尝试从只读切换到读写或反之；这可以简单地通过访问旧标志（在 <code class="docutils literal"><span class="pre">sb-&gt;s_flags</span></code> 中）和新标志 (<code class="docutils literal"><span class="pre">flags</span></code> 参数) 来完成; <code class="docutils literal"><span class="pre">data</span></code> 是由 <code class="xref c c-func docutils literal"><span class="pre">mount()</span></code> 发送的表示文件系统特定选项的数据的指针；</li>
<li><code class="docutils literal"><span class="pre">statfs</span></code> 在执行 <code class="docutils literal"><span class="pre">statfs</span></code> 系统调用时调用（尝试 <code class="docutils literal"><span class="pre">stat</span> <span class="pre">-f</span></code> 或 <code class="docutils literal"><span class="pre">df</span></code>）；此调用必须填充 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kstatfs</span></code> 结构的字段，就像在 <code class="xref c c-func docutils literal"><span class="pre">ext4_statfs()</span></code> 函数中所做的那样。</li>
</ul>
</div>
</div>
<div class="section" id="fill-super">
<span id="fillsupersection"></span><h2><code class="xref c c-func docutils literal"><span class="pre">fill_super()</span></code> 函数<a class="headerlink" href="#fill-super" title="永久链接至标题">¶</a></h2>
<p>如前所述, <code class="xref c c-func docutils literal"><span class="pre">fill_super()</span></code> 函数用于超级块初始化的最后一段。此初始化包括填充 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 结构字段和根目录 inode 的初始化。</p>
<p>一个实现示例是 <code class="xref c c-func docutils literal"><span class="pre">ramfs_fill_super()</span></code> 函数，它用于初始化超级块中的其余字段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/pagemap.h&gt;</span><span class="cp"></span>

<span class="cp">#define RAMFS_MAGIC     0x858458f6</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">ramfs_ops</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">statfs</span>         <span class="o">=</span> <span class="n">simple_statfs</span><span class="p">,</span>
  <span class="p">.</span><span class="n">drop_inode</span>     <span class="o">=</span> <span class="n">generic_delete_inode</span><span class="p">,</span>
  <span class="p">.</span><span class="n">show_options</span>   <span class="o">=</span> <span class="n">ramfs_show_options</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ramfs_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">ramfs_fs_info</span> <span class="o">*</span><span class="n">fsi</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">save_mount_options</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

  <span class="n">fsi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ramfs_fs_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">fsi</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fsi</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

  <span class="n">err</span> <span class="o">=</span> <span class="n">ramfs_parse_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsi</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span>          <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span>         <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span>    <span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span>             <span class="o">=</span> <span class="n">RAMFS_MAGIC</span><span class="p">;</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span>                <span class="o">=</span> <span class="o">&amp;</span><span class="n">ramfs_ops</span><span class="p">;</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span>         <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

  <span class="n">inode</span> <span class="o">=</span> <span class="n">ramfs_get_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">fsi</span><span class="o">-&gt;</span><span class="n">mount_opts</span><span class="p">.</span><span class="n">mode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>内核提供了实现文件系统结构的操作的通用函数。上面代码中使用的 <code class="xref c c-func docutils literal"><span class="pre">generic_delete_inode()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">simple_statfs()</span></code> 函数就是这种函数，如果它们的功能足够，可以用于实现驱动程序。</p>
<p>上面代码中的 <code class="xref c c-func docutils literal"><span class="pre">ramfs_fill_super()</span></code> 函数填充了超级块中的一些字段，然后读取根 inode 并分配根 dentry。读取根 inode 在 <code class="xref c c-func docutils literal"><span class="pre">ramfs_get_inode()</span></code> 函数中完成，它包括使用 <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code> 函数分配新的 inode 并进行初始化。为了释放 inode，使用了 <code class="xref c c-func docutils literal"><span class="pre">iput()</span></code>，并使用 <code class="xref c c-func docutils literal"><span class="pre">d_make_root()</span></code> 函数分配根 dentry。</p>
<p>一个用于磁盘文件系统的示例实现是 minix 文件系统中的 <code class="xref c c-func docutils literal"><span class="pre">minix_fill_super()</span></code> 函数。磁盘文件系统的功能与虚拟文件系统类似，唯一的区别是使用了缓冲区缓存。此外，minix 文件系统使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minix_sb_info</span></code> 结构来保存私有数据。这个函数的很大一部分工作是初始化这些私有数据。私有数据使用 <code class="xref c c-func docutils literal"><span class="pre">kzalloc()</span></code> 函数进行分配，并存储在超级块结构的 <code class="docutils literal"><span class="pre">s_fs_info</span></code> 字段中。</p>
<p>VFS 函数通常以超级块、索引节点和/或包含指向超级块的指针的目录项作为实参，以便能够轻松访问这些私有数据。</p>
</div>
<div class="section" id="section-10">
<span id="buffercachesection"></span><h2>缓冲区缓存<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h2>
<p>缓冲区缓存是处理块设备读写缓存的内核子系统。缓冲区缓存使用的基本实体是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code> 结构。该结构中最重要的字段包括：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">b_data</span></code>，指向读取数据或写入数据的内存区域的指针</li>
<li><code class="docutils literal"><span class="pre">b_size</span></code>，缓冲区大小</li>
<li><code class="docutils literal"><span class="pre">b_bdev</span></code>，块设备</li>
<li><code class="docutils literal"><span class="pre">b_blocknr</span></code>，已加载或需要保存在磁盘上的设备的块号</li>
<li><code class="docutils literal"><span class="pre">b_state</span></code>，缓冲区的状态</li>
</ul>
</div></blockquote>
<p>以下是与这些结构一起使用的一些重要函数：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">__bread()</span></code>：读取具有给定编号和给定大小的块到一个 <code class="docutils literal"><span class="pre">buffer_head</span></code> 结构中；如果成功，则返回指向 <code class="docutils literal"><span class="pre">buffer_head</span></code> 结构的指针，否则返回 <code class="docutils literal"><span class="pre">NULL</span></code>；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code>：与前一个函数相同，但读取的块的大小从超级块中获取，读取的设备也从超级块中获取；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">mark_buffer_dirty()</span></code>：将缓冲区标记为脏（设置 <code class="docutils literal"><span class="pre">BH_Dirty</span></code> 位）；缓冲区将在稍后的时间写入磁盘 (<code class="docutils literal"><span class="pre">bdflush</span></code> 内核线程会定期唤醒并将缓冲区写入磁盘)；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">brelse()</span></code>：在先前将缓冲区写入磁盘（如果需要）后，释放缓冲区使用的内存；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">map_bh()</span></code>：将 buffer-head 与相应的扇区关联。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-11">
<h2>函数和有用的宏<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h2>
<p>超级块通常包含以位图（位向量）形式表示的占用块的映射（由索引节点、目录条目、数据占用）。为了处理这种映射，建议使用以下功能：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">find_first_zero_bit()</span></code>，用于在内存区域中查找第一个为零的位。size 参数表示搜索区域中的位数；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_set_bit()</span></code>，设置位并获取旧值；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_clear_bit()</span></code>，删除位并获取旧值；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_change_bit()</span></code>，取反位的值并获取旧值。</li>
</ul>
</div></blockquote>
<p>以下宏定义可用于验证索引节点的类型：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">S_ISDIR</span></code> (<code class="docutils literal"><span class="pre">inode-&gt;i_mode</span></code>)，用于检查索引节点是否为目录；</li>
<li><code class="docutils literal"><span class="pre">S_ISREG</span></code> (<code class="docutils literal"><span class="pre">inode-&gt;i_mode</span></code>)，用于检查索引节点是否为普通文件（非链接或设备文件）。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-12">
<h2>进一步阅读<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>Robert Love——Linux 内核开发，第二版——第 12 章 虚拟文件系统</li>
<li>《深入理解 Linux 内核》，第 3 版——第 12 章 虚拟文件系统</li>
<li><a class="reference external" href="http://www.coda.cs.cmu.edu/doc/talks/linuxvfs/">Linux 虚拟文件系统（演示）</a></li>
<li><a class="reference external" href="http://www.cyberciti.biz/tips/understanding-unixlinux-file-system-part-i.html">理解 Unix/Linux 文件系统</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/57369/">创建 Linux 虚拟文件系统</a></li>
<li><a href="#system-message-2"><span class="problematic" id="problematic-2">`Linux 文档项目——VFS`_</span></a></li>
<li><a class="reference external" href="http://www.linux.it/~rubini/docs/vfs/vfs.html">Linux 中的“虚拟文件系统”</a></li>
<li><a class="reference external" href="http://inglorion.net/documents/tutorials/tutorfs/">Linux 文件系统教程</a></li>
<li><a class="reference external" href="http://www.win.tue.nl/~aeb/linux/lk/lk-8.html">Linux 虚拟文件系统</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/Documentation/filesystems/vfs.txt">Documentation/filesystems/vfs.txt</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/fs/">文件系统源代码</a></li>
</ol>
</div>
<div class="section" id="section-13">
<h2>练习<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 文件系统。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/文件系统/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-13">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p class="last">为了更好地了解我们在教学、课外活动和职业活动中做得好和可以做得更好的方面，我们请你填写 <a class="reference external" href="https://forms.office.com/r/SqBF2kfzk5">这份调查问卷</a>。这份调查问卷非常简短，你只需选择答案，预计完成时间为 3-5 分钟。当然，我们将向你发送调查分析结果，并将用它来改进教学活动。</p>
</div>
<div class="section" id="myfs">
<h3>myfs<a class="headerlink" href="#myfs" title="永久链接至标题">¶</a></h3>
<p>首先，我们计划熟悉 Linux 内核和虚拟文件系统（VFS）组件所提供的接口。为此，我们将使用一个简单的虚拟文件系统（即没有物理磁盘支持）。该文件系统名为 <code class="docutils literal"><span class="pre">myfs</span></code>。</p>
<p>我们将在实验框架的 <code class="docutils literal"><span class="pre">myfs/</span></code> 子目录中进行操作。我们将在此实验中实现超级块操作，下一个实验将继续进行索引节点操作。</p>
<div class="section" id="myfs-1">
<h4>1. 注册和注销 myfs 文件系统<a class="headerlink" href="#myfs-1" title="永久链接至标题">¶</a></h4>
<p>处理文件系统的第一步是注册和注销它。我们要为 <code class="docutils literal"><span class="pre">myfs.c</span></code> 中描述的文件系统执行此操作。查看文件内容并按照标记为 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> 的指示进行操作。</p>
<p>在 <span class="xref std std-ref">RegisterUnregisterSection</span> 部分描述了需要执行的步骤。使用字符串 <code class="docutils literal"><span class="pre">&quot;myfs&quot;</span></code> 作为文件系统名称。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>在文件系统结构中，使用代码框架中的 <code class="docutils literal"><span class="pre">myfs_mount</span></code> 函数填充超级块（在挂载时完成）。在 <code class="docutils literal"><span class="pre">myfs_mount</span></code> 中调用专用于没有磁盘支持的文件系统的函数。作为特定挂载函数的参数，使用代码框架中定义的 <code class="docutils literal"><span class="pre">fill_super</span></code> 类型的函数。你可以查看 <a class="reference internal" href="#functionsmountkillsbsection"><span class="std std-ref">mount 和 kill_sb 函数</span></a> 部分。</p>
<p class="last">要销毁超级块（在卸载时完成），请使用 <code class="docutils literal"><span class="pre">kill_litter_super</span></code>，这也是特定于没有磁盘支持的文件系统的函数。该函数已经实现，你需要在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code> 结构中填充它。</p>
</div>
<p>完成标记为 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> 的部分后，编译模块，将其复制到 QEMU 虚拟机中，并启动虚拟机。加载内核模块，然后检查 <code class="docutils literal"><span class="pre">/proc/filesystems</span></code> 文件中是否存在 <code class="docutils literal"><span class="pre">myfs</span></code> 文件系统。</p>
<p>目前，文件系统只是注册了，它没有暴露可以使用的操作。如果我们尝试挂载它，操作将失败。为了尝试挂载，我们创建挂载点 <code class="docutils literal"><span class="pre">/mnt/myfs/</span></code>。</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir -p /mnt/myfs
</pre></div>
</div>
<p>然后我们使用 <code class="docutils literal"><span class="pre">mount</span></code> 命令：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mount -t myfs none /mnt/myfs
</pre></div>
</div>
<p>我们得到的错误消息显示我们还没有实现在超级块上的操作。我们将需要实现超级块上的操作并初始化根索引节点。我们将在后续步骤中完成这些操作。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">发送给 <code class="docutils literal"><span class="pre">mount</span></code> 命令的 <code class="docutils literal"><span class="pre">none</span></code> 实参表示我们没有要挂载的设备，因为文件系统是虚拟的。类似地，这也是 Linux 系统上挂载 <code class="docutils literal"><span class="pre">procfs</span></code> 或 <code class="docutils literal"><span class="pre">sysfs</span></code> 文件系统的方式。</p>
</div>
</div>
<div class="section" id="myfs-2">
<h4>2. 完成 myfs 的超级块<a class="headerlink" href="#myfs-2" title="永久链接至标题">¶</a></h4>
<p>为了能够挂载文件系统，我们需要填充其超级块的字段，即类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 的通用 VFS 结构。我们将在 <code class="xref c c-func docutils literal"><span class="pre">myfs_fill_super()</span></code> 函数内填充该结构；超级块由作为函数实参传递的变量 <code class="docutils literal"><span class="pre">sb</span></code> 表示。请按照标记为 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> 的提示进行操作。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要填充 <code class="docutils literal"><span class="pre">myfs_fill_super</span></code> 函数，你可以从 <a class="reference internal" href="#fillsupersection"><span class="std std-ref">fill_super() 函数</span></a> 部分中的示例开始。</p>
<p class="last">对于超级块结构字段，请尽可能使用代码框架中定义的宏。</p>
</div>
<p>超级块结构中的 <code class="docutils literal"><span class="pre">s_op</span></code> 字段必须初始化为超级块操作结构（类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code>）。你需要定义这样的结构。</p>
<p>有关定义 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> 结构和填充超级块的信息，请参阅 <a class="reference internal" href="#superblocksection"><span class="std std-ref">超级块操作</span></a> 部分。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">初始化 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> 结构的 <code class="docutils literal"><span class="pre">drop_inode</span></code> 和 <code class="docutils literal"><span class="pre">statfs</span></code> 字段。</p>
</div>
<p>尽管此时超级块将被正确初始化，但挂载操作仍将失败。为了成功完成挂载操作，还需要初始化根索引节点，这将在下一个练习中进行操作。</p>
</div>
<div class="section" id="myfs-3">
<h4>3. 初始化 myfs 根索引节点<a class="headerlink" href="#myfs-3" title="永久链接至标题">¶</a></h4>
<p>根索引节点是文件系统根目录（即 <code class="docutils literal"><span class="pre">/</span></code>）的索引节点。初始化是在文件系统挂载时完成的。在挂载时调用的 <code class="docutils literal"><span class="pre">myfs_fill_super</span></code> 函数会调用 <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> 函数来创建并初始化索引节点。通常，所有索引节点都是由此函数创建和初始化；但是，在本练习中，我们只创建根索引节点。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">inode</span></code> 在 <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> 函数内进行分配（调用 <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code> 函数，将返回的结果分配给局部变量 <code class="docutils literal"><span class="pre">inode</span></code>）。</p>
<p>为了成功完成文件系统的挂载，你需要填充 <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> 函数。按照标记为 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">3</span></code> 的指示进行操作。可以参考 <a class="reference external" href="https://elixir.bootlin.com/linux/latest/source/fs/ramfs/inode.c#L63">ramfs_get_inode</a> 函数。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要初始化 <code class="docutils literal"><span class="pre">uid</span></code>, <code class="docutils literal"><span class="pre">gid</span></code> 和 <code class="docutils literal"><span class="pre">mode</span></code>，可以使用 <code class="xref c c-func docutils literal"><span class="pre">inode_init_owner()</span></code> 函数，就像在 <code class="xref c c-func docutils literal"><span class="pre">ramfs_get_inode()</span></code> 中那样。调用 <code class="xref c c-func docutils literal"><span class="pre">inode_init_owner()</span></code> 时，应将 <code class="docutils literal"><span class="pre">NULL</span></code> 作为第二个参数，因为创建的索引节点没有父目录。</p>
<p>将 VFS 索引节点的 <code class="docutils literal"><span class="pre">i_atime</span></code>, <code class="docutils literal"><span class="pre">i_ctime</span></code> 和 <code class="docutils literal"><span class="pre">i_mtime</span></code> 初始化为 <code class="xref c c-func docutils literal"><span class="pre">current_time()</span></code> 函数返回的值。</p>
<p>你需要为目录类型的索引节点初始化操作。执行以下步骤：</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>使用 <code class="docutils literal"><span class="pre">S_ISDIR</span></code> 宏检查这是否是目录类型的索引节点。</li>
<li>对于 <code class="docutils literal"><span class="pre">i_op</span></code> 和 <code class="docutils literal"><span class="pre">i_fop</span></code> 字段，请使用已经实现的内核函数：<ul>
<li>对于 <code class="docutils literal"><span class="pre">i_op</span></code>：使用 <code class="xref c c-type docutils literal"><span class="pre">simple_dir_inode_operations</span></code>。</li>
<li>对于 <code class="docutils literal"><span class="pre">i_fop</span></code>：使用 <code class="xref c c-type docutils literal"><span class="pre">simple_dir_operations</span></code>。</li>
</ul>
</li>
<li>使用 <code class="xref c c-func docutils literal"><span class="pre">inc_nlink()</span></code> 函数增加目录的链接数。</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="myfs-4">
<h4>4. 测试 myfs 的挂载和卸载<a class="headerlink" href="#myfs-4" title="永久链接至标题">¶</a></h4>
<p>现在我们可以挂载文件系统了。按照上述步骤编译内核模块，将其复制到虚拟机中，启动虚拟机，然后插入内核模块，创建挂载点 <code class="docutils literal"><span class="pre">/mnt/myfs/</span></code>，并挂载文件系统。我们可以通过检查 <code class="docutils literal"><span class="pre">/proc/mounts</span></code> 文件来验证文件系统是否已挂载。</p>
<p><a href="#system-message-1"><span class="problematic" id="problematic-1">``</span></a>/mnt/myfs``目录的索引节点号是多少？为什么？</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要显示目录的索引节点号，请使用以下命令：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">ls -di /path/to/directory</span>
</pre></div>
</div>
<p class="last">其中 <code class="docutils literal"><span class="pre">/path/to/directory/</span></code> 是要显示其索引节点号的目录的路径。</p>
</div>
<p>我们使用以下命令检查 myfs 文件系统的统计信息：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">stat -f /mnt/myfs</span>
</pre></div>
</div>
<p>我们想查看挂载点 <code class="docutils literal"><span class="pre">/mnt/myfs</span></code> 的内容以及是否可以创建文件。为此，我们运行以下命令：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ls -la /mnt/myfs
<span class="gp">#</span> touch /mnt/myfs/a.txt
</pre></div>
</div>
<p>我们可以看到我们无法在文件系统上创建 <code class="docutils literal"><span class="pre">a.txt</span></code> 文件。这是因为我们尚未在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> 结构中实现与索引节点相关的操作。我们将在下一个实验中实现这些操作。</p>
<p>使用以下命令卸载文件系统：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">umount /mnt/myfs</span>
</pre></div>
</div>
<p>同时卸载对应的内核模块。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要测试整个功能，你可以使用 <code class="docutils literal"><span class="pre">test-myfs.sh</span></code> 脚本：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">./test-myfs.sh</span>
</pre></div>
</div>
<p>该脚本将使用 <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> 将其复制到虚拟机，但前提是它具有可执行权限：</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="gp">student@workstation:~/linux/tools/labs$</span> chmod +x skels/filesystems/myfs/test-myfs.sh
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">显示的文件系统统计信息很简单，因为这些信息是由 simple_statfs 函数提供的。</p>
</div>
</div>
</div>
<div class="section" id="minfs">
<h3>minfs<a class="headerlink" href="#minfs" title="永久链接至标题">¶</a></h3>
<p>接下来，我们将实现一个非常简单的文件系统，名为 <code class="docutils literal"><span class="pre">minfs</span></code>，这个文件系统支持磁盘。我们将使用虚拟机中的一个磁盘，格式化并挂载 <code class="docutils literal"><span class="pre">minfs</span></code> 文件系统。</p>
<p>为此，我们需要从实验框架中访问 <code class="docutils literal"><span class="pre">minfs/kernel</span></code> 目录，并处理 <code class="docutils literal"><span class="pre">minfs.c</span></code> 中的代码。与 <code class="docutils literal"><span class="pre">myfs</span></code> 类似，我们不会实现与索引节点相关的操作，只限于处理超级块和挂载。其他操作将在下一个实验中实现。</p>
<p>请按照下面的图表来理解 <code class="docutils literal"><span class="pre">minfs</span></code> 文件系统中各个结构的作用。</p>
<img alt="../_images/minfs1.png" src="../_images/minfs1.png" />
<div class="section" id="minfs-1">
<h4>1. 注册和注销 minfs 文件系统<a class="headerlink" href="#minfs-1" title="永久链接至标题">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>在解决本练习之前，我们需要在虚拟机中添加一个磁盘。你可以使用以下命令生成一个文件作为磁盘镜像：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">dd if=/dev/zero of=mydisk.img bs=1M count=100</span>
</pre></div>
</div>
<p class="last">并且在 <code class="docutils literal"><span class="pre">qemu/Makefile</span></code> 文件中的 <code class="docutils literal"><span class="pre">qemu</span></code> 命令中添加 <code class="docutils literal"><span class="pre">-drive</span> <span class="pre">file=mydisk.img,if=virtio,format=raw</span></code> 参数（在 <code class="docutils literal"><span class="pre">QEMU_OPTS</span></code> 变量中）。新的 <code class="docutils literal"><span class="pre">qemu</span></code> 命令参数必须在现有磁盘参数 (<code class="docutils literal"><span class="pre">YOCTO_IMAGE</span></code>) 之后添加。</p>
</div>
<p>要注册和注销文件系统，你需要在 <code class="docutils literal"><span class="pre">minfs.c</span></code> 中填写 <code class="docutils literal"><span class="pre">minfs_fs_type</span></code> 和 <code class="docutils literal"><span class="pre">minfs_mount</span></code> 函数。按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> 的指引进行操作。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>在文件系统结构中，对于挂载，请使用代码框架中的 <code class="docutils literal"><span class="pre">minfs_mount</span></code> 函数。在此函数中，调用带有磁盘支持的文件系统挂载函数（请参见 <a class="reference internal" href="#functionsmountkillsbsection"><span class="std std-ref">mount 和 kill_sb 函数</span></a> 部分。使用 <code class="xref c c-func docutils literal"><span class="pre">mount_bdev()</span></code>）。选择最合适的函数来销毁超级块（在卸载时完成）；请记住这是带有磁盘支持的文件系统。使用 <code class="xref c c-func docutils literal"><span class="pre">kill_block_super()</span></code> 函数。</p>
<p>使用适当的值初始化 <code class="xref c c-type docutils literal"><span class="pre">minfs_fs_type</span></code> 结构的 <code class="docutils literal"><span class="pre">fs_flags</span></code> 字段，以适应带有磁盘支持的文件系统。请参阅 <span class="xref std std-ref">RegisterUnregisterSection</span> 部分。</p>
<p class="last">填充超级块的函数是 <code class="docutils literal"><span class="pre">minfs_fill_super</span></code>。</p>
</div>
<p>完成标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> 的部分后，编译模块，将其复制到 QEMU 虚拟机中，并启动虚拟机。加载内核模块，然后检查 <code class="docutils literal"><span class="pre">/proc/filesystems</span></code> 文件中是否存在 <code class="docutils literal"><span class="pre">minfs</span></code> 文件系统。</p>
<p>为了测试 <code class="docutils literal"><span class="pre">minfs</span></code> 文件系统的挂载，我们需要使用其结构对磁盘进行格式化。格式化需要使用 <code class="docutils literal"><span class="pre">minfs/user</span></code> 目录下的 <code class="docutils literal"><span class="pre">mkfs.minfs</span></code> 格式化工具。该工具在运行 <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code> 时会自动编译，并在 <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> 时复制到虚拟机中。</p>
<p>编译、复制和启动虚拟机后，使用格式化工具对 <code class="docutils literal"><span class="pre">/dev/vdd</span></code> 进行格式化：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./mkfs.minfs /dev/vdd
</pre></div>
</div>
<p>加载内核模块：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> insmod minfs.ko
</pre></div>
</div>
<p>创建挂载点 <code class="docutils literal"><span class="pre">/mnt/minfs/</span></code>：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mkdir -p /mnt/minfs/
</pre></div>
</div>
<p>并挂载文件系统</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mount -t minfs /dev/vdd /mnt/minfs/
</pre></div>
</div>
<p>操作失败，因为根索引节点未初始化。</p>
</div>
<div class="section" id="minfs-2">
<h4>2. 完善 minfs 超级块<a class="headerlink" href="#minfs-2" title="永久链接至标题">¶</a></h4>
<p>为了能够挂载文件系统，你需要在 <code class="docutils literal"><span class="pre">minfs_fill_super</span></code> 函数中填充超级块（即类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 的结构体），超级块对应该函数的 <code class="docutils literal"><span class="pre">s</span></code> 实参。操作超级块的结构已经定义好了: <code class="docutils literal"><span class="pre">minfs_ops</span></code>。按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> 的指引操作。你还可以参考 <a class="reference external" href="https://elixir.bootlin.com/linux/latest/source/fs/minix/inode.c#L153">minix_fill_super</a> 函数的实现。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>一些结构可以在头文件 <code class="docutils literal"><span class="pre">minfs.h</span></code> 中找到。</p>
<p>有关使用缓冲区的信息，请参阅 <a class="reference internal" href="#buffercachesection"><span class="std std-ref">缓冲区缓存</span></a> 部分。</p>
<p>读取磁盘上的第一个块（索引为 0 的块）。要读取块，请使用 <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> 函数。将读取的数据（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code> 结构中的 <code class="docutils literal"><span class="pre">b_data</span></code> 字段）转换为存储磁盘上的 <code class="docutils literal"><span class="pre">minfs</span></code> 超级块的信息的结构体：在源代码文件中定义的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_super_block</span></code>。</p>
<p class="last">结构 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_super_block</span></code> 包含了文件系统特定的信息，这些信息在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> 通用结构中找不到（在这种情况下只有版本号）。这些附加信息（在磁盘上的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_super_block</span></code> 中找到，但在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block`（VFS）中找不到）将存储在</span> <span class="pre">:c:type:`struct</span> <span class="pre">minfs_sb_info</span></code> 结构中。</p>
</div>
<p>为了检查功能，我们需要用于读取根索引节点的函数。这里暂时使用 <code class="docutils literal"><span class="pre">myfs</span></code> 文件系统练习中的 <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> 函数。将该函数复制到源代码中，并像处理 myfs 时一样调用它。调用 <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> 函数时的第三个参数是索引节点的创建权限，与虚拟文件系统练习（myfs）中的类似。</p>
<p>执行上一个练习中的命令来验证实现。</p>
</div>
<div class="section" id="minfs-3">
<h4>3. 创建和销毁 minfs 索引节点<a class="headerlink" href="#minfs-3" title="永久链接至标题">¶</a></h4>
<p>挂载操作中，我们需要初始化根索引节点，并且为了获得根索引节点，我们需要实现与索引节点相关的函数。也就是说，你需要实现 <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> 和 <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> 函数。按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">3</span></code> 的指示进行操作。你可以将 <code class="xref c c-func docutils literal"><span class="pre">minix_alloc_inode`()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">minix_destroy_inode()</span></code> 函数作为参考。</p>
<p>为了实现，请查看 <code class="docutils literal"><span class="pre">minfs.h</span></code> 头文件中的宏和结构。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要想实现在 <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> 和 <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> 中的内存分配/释放，建议使用 <code class="xref c c-func docutils literal"><span class="pre">kzalloc()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">kfree()</span></code>。</p>
<p>在 <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> 中，分配类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> 的结构体，但只返回类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> 的结构体，即返回 <code class="docutils literal"><span class="pre">vfs_inode</span></code> 字段对应的结构体。</p>
<p>在 <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> 函数中，调用 <code class="xref c c-func docutils literal"><span class="pre">inode_init_once()</span></code> 来初始化索引节点。</p>
<p class="last">在 <code class="docutils literal"><span class="pre">destroy_inode</span></code> 函数中，你可以使用 <code class="docutils literal"><span class="pre">container_of</span></code> 宏访问 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> 结构体。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在本练习中，你已经实现了 <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> 和 <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> 函数，但尚未调用它们。实现的正确性将在下一个练习的最后进行检查。</p>
</div>
</div>
<div class="section" id="minfs-4">
<h4>4. 初始化 minfs 根索引节点<a class="headerlink" href="#minfs-4" title="永久链接至标题">¶</a></h4>
<p>为了挂载文件系统，需要初始化根索引节点。为此，你需要完成 <code class="docutils literal"><span class="pre">minfs_ops</span></code> 结构体，包括 <code class="docutils literal"><span class="pre">minfs_alloc_inode</span></code> 和 <code class="docutils literal"><span class="pre">minfs_destroy_inode</span></code> 函数，并填充 <code class="docutils literal"><span class="pre">minfs_iget</span></code> 函数。</p>
<p><code class="docutils literal"><span class="pre">minfs_iget</span></code> 函数用于分配 VFS 索引节点（即 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>），并用磁盘中的 minfs 索引节点特定信息（即 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code>）来填充它。</p>
<p>按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">4</span></code> 的指示进行操作。在 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> 结构体的 <code class="docutils literal"><span class="pre">alloc_inode</span></code> 和 <code class="docutils literal"><span class="pre">destroy_inode</span></code> 字段中填写在上一步中实现的函数。</p>
<p>根索引节点的信息存储在磁盘上的第二个块中（索引为 1 的索引节点）。使 <code class="docutils literal"><span class="pre">minfs_iget</span></code> 从磁盘中读取根 minfs 索引节点（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code>）并填充 VFS 索引节点（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>）。</p>
<p>在 <code class="docutils literal"><span class="pre">minfs_fill_super</span></code> 函数中，用 <code class="docutils literal"><span class="pre">minfs_iget</span></code> 函数调用替换 <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> 的调用。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要实现 <code class="docutils literal"><span class="pre">minfs_iget</span></code> 函数，请参考 <a class="reference external" href="https://elixir.bootlin.com/linux/v4.15/source/fs/minix/inode.c#L460">V1_minix_iget</a> 的实现。要读取块，请使用 <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> 函数。将读取的数据（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">buffer_head</span></code> 结构中的 <code class="docutils literal"><span class="pre">b_data</span></code> 字段）强制转换为磁盘上的 minfs 索引节点（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code>）。</p>
<p>使用从磁盘读取的 minfs 索引节点结构中的值填充 VFS 索引节点中的 <code class="docutils literal"><span class="pre">i_uid</span></code>, <code class="docutils literal"><span class="pre">i_gid</span></code>, <code class="docutils literal"><span class="pre">i_mode</span></code> 以及 <code class="docutils literal"><span class="pre">i_size</span></code> 字段。要初始化 <code class="docutils literal"><span class="pre">i_uid</span></code> 和 <code class="docutils literal"><span class="pre">i_gid</span></code> 字段，请使用函数 <code class="xref c c-func docutils literal"><span class="pre">i_uid_write()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">i_gid_write()</span></code>。</p>
<p>将 VFS 索引节点的 <code class="docutils literal"><span class="pre">i_atime</span></code>, <code class="docutils literal"><span class="pre">i_ctime</span></code> 和 <code class="docutils literal"><span class="pre">i_mtime</span></code> 字段初始化为 <code class="xref c c-func docutils literal"><span class="pre">current_time()</span></code> 函数的返回值。</p>
<p>你需要为目录类型的索引节点初始化操作。请按照以下步骤进行操作：</p>
<blockquote class="last">
<div><ol class="arabic simple">
<li>使用 <code class="docutils literal"><span class="pre">S_ISDIR</span></code> 宏检查是否为目录类型的索引节点。</li>
<li>对于 <code class="docutils literal"><span class="pre">i_op</span></code> 和 <code class="docutils literal"><span class="pre">i_fop</span></code> 字段，使用已实现的内核函数：<ul>
<li>对于 <code class="docutils literal"><span class="pre">i_op</span></code>：<code class="xref c c-func docutils literal"><span class="pre">simple_dir_inode_operations()</span></code>。</li>
<li>对于 <code class="docutils literal"><span class="pre">i_fop</span></code>：<code class="xref c c-func docutils literal"><span class="pre">simple_dir_operations()</span></code>。</li>
</ul>
</li>
<li>使用 <code class="xref c c-func docutils literal"><span class="pre">inc_nlink()</span></code> 函数增加目录的链接数。</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="minfs-5">
<h4>5. minfs 挂载和卸载的测试<a class="headerlink" href="#minfs-5" title="永久链接至标题">¶</a></h4>
<p>现在我们可以挂载文件系统了。按照上述步骤编译内核模块，将其复制到虚拟机中，启动虚拟机，然后插入内核模块，创建挂载点 <code class="docutils literal"><span class="pre">/mnt/minfs/</span></code> 并挂载文件系统。我们通过查看 <code class="docutils literal"><span class="pre">/proc/mounts</span></code> 文件来验证文件系统是否已挂载。</p>
<p>通过列出挂载点内容 <code class="docutils literal"><span class="pre">/mnt/minfs/</span></code> 来检查是否一切正常：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ls /mnt/minfs/
</pre></div>
</div>
<p>挂载和验证完成后，卸载文件系统并从内核中卸载模块。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>或者，你可以使用 <code class="docutils literal"><span class="pre">test-minfs.sh</span></code> 脚本来完整测试功能：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-minfs.sh
</pre></div>
</div>
<p>仅当该脚本是可执行文件，在运行 <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> 命令时该脚本会被复制到虚拟机中。</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="gp">student@workstation:~/linux/tools/labs$</span> chmod +x skels/filesystems/minfs/user/test-minfs.sh
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab7-block-device-drivers.html" class="btn btn-neutral float-left" title="SO2 实验 07——块设备驱动" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab9-filesystems-part2.html" class="btn btn-neutral float-right" title="SO2 实验 09——文件系统驱动程序（第二部分）" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>