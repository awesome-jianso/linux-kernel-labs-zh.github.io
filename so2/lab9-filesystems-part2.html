<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 09 - File system drivers (Part 2) &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 10 - Networking" href="lab10-networking.html" />
    <link rel="prev" title="SO2 Lab 08 - File system drivers (Part 1)" href="lab8-filesystems-part1.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab1-intro.html">SO2 Lab 01 - Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 09 - File system drivers (Part 2)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inode">Inode</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-inode-structure">The inode structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inode-operations">Inode operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#the-file-structure">The file structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#regular-files-inodes">Regular files inodes</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#regular-files-inode-operations">Regular files inode operations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#address-space-operations">Address space operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dentry-structure">Dentry structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dentry-operations">Dentry operations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#directory-inodes-operations">Directory inodes operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-an-inode">Creating an inode</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-directory">Creating a directory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-link">Creating a link</a></li>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-symbolic-link">Creating a symbolic link</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deleting-a-link">Deleting a link</a></li>
<li class="toctree-l4"><a class="reference internal" href="#deleting-a-directory">Deleting a directory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#searching-for-an-inode-in-a-directory">Searching for an inode in a directory</a></li>
<li class="toctree-l4"><a class="reference internal" href="#iterating-through-entries-in-a-directory">Iterating through entries in a directory</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bitmap-operations">Bitmap operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#further-reading">Further reading</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#myfs">myfs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minfs">minfs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 09 - File system drivers (Part 2)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab9-filesystems-part2.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-09-file-system-drivers-part-2">
<h1>SO2 Lab 09 - File system drivers (Part 2)<a class="headerlink" href="#so2-lab-09-file-system-drivers-part-2" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>Improving the knowledge about inode, file and dentry.</li>
<li>Acquiring knowledge about adding support for working with regular files and directories in VFS (<em>Virtual File System</em>).</li>
<li>Acquiring knowledge about the internal implementation of a file system.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="inode">
<h2>Inode<a class="headerlink" href="#inode" title="Permalink to this headline">¶</a></h2>
<p>The inode is an essential component of a UNIX file system and, at the same time, an important component of VFS. An inode is a metadata (it has information about information).
An inode uniquely identifies a file on disk and holds information about it (uid, gid, access rights, access times, pointers to data blocks, etc.).
An important aspect is that an inode does not have information about the file name (it is retained by the associated <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span></code> structure).</p>
<p>The inode refers to a file on the disk. To refer an open file (associated with a file descriptor within a process), the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> structure is used.
An inode can have any number of (zero or more) <code class="docutils literal"><span class="pre">file</span></code> structures associated (multiple processes can open the same file, or a process can open the same file several times).</p>
<p>Inode exists both as a VFS entity (in memory) and as a disk entity (for UNIX, HFS, NTFS, etc.).
The inode in VFS is represented by the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>.
Like the other structures in VFS, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> is a generic structure that covers the options for all supported file types, even those that do not have an associated disk entity (such as FAT).</p>
<div class="section" id="the-inode-structure">
<h3>The inode structure<a class="headerlink" href="#the-inode-structure" title="Permalink to this headline">¶</a></h3>
<p>The inode structure is the same for all file systems. In general, file systems also have private information. These are referenced through the <code class="docutils literal"><span class="pre">i_private</span></code> field of the structure.
Conventionally, the structure that keeps that particular information is called <code class="docutils literal"><span class="pre">&lt;fsname&gt;_inode_info</span></code>, where <code class="docutils literal"><span class="pre">fsname</span></code> represents the file system name. For example, minix and ext4 filesystems store particular information in structures <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">minix_inode_info</span></code>, or <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">ext4_inode_info</span></code>.</p>
<p>Some of the important fields of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">i_sb</span></code> : The superblock structure of the file system the inode belongs to.</li>
<li><code class="docutils literal"><span class="pre">i_rdev</span></code>: the device on which this file system is mounted</li>
<li><code class="docutils literal"><span class="pre">i_ino</span></code> : the number of the inode (uniquely identifies the inode within the file system)</li>
<li><code class="docutils literal"><span class="pre">i_blkbits</span></code>: number of bits used for the block size == log<sub>2</sub>(block size)</li>
<li><code class="docutils literal"><span class="pre">i_mode</span></code>, <code class="docutils literal"><span class="pre">i_uid</span></code>, <code class="docutils literal"><span class="pre">i_gid</span></code>: access rights, uid, gid</li>
<li><code class="docutils literal"><span class="pre">i_size</span></code>: file/directory/etc. size in bytes</li>
<li><code class="docutils literal"><span class="pre">i_mtime</span></code>, <code class="docutils literal"><span class="pre">i_atime</span></code>, <code class="docutils literal"><span class="pre">i_ctime</span></code>: change, access, and creation time</li>
<li><code class="docutils literal"><span class="pre">i_nlink</span></code>: the number of names entries (dentries) that use this inode; for file systems without links (either hard or symbolic) this is always set to 1</li>
<li><code class="docutils literal"><span class="pre">i_blocks</span></code>: the number of blocks used by the file (all blocks, not just data); this is only used by the quota subsystem</li>
<li><code class="docutils literal"><span class="pre">i_op</span></code>, <code class="docutils literal"><span class="pre">i_fop</span></code>: pointers to operations structures: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode_operations</span></code> and <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code>; <code class="docutils literal"><span class="pre">i_mapping-&gt;a_ops</span></code> contains a pointer to <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">address_space_operations</span></code>.</li>
<li><code class="docutils literal"><span class="pre">i_count</span></code>: the inode counter indicating how many kernel components use it.</li>
</ul>
</div></blockquote>
<p>Some functions that can be used to work with inodes:</p>
<blockquote>
<div><ul>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code>: creates a new inode, sets the <code class="docutils literal"><span class="pre">i_nlink</span></code> field to 1 and initializes <code class="docutils literal"><span class="pre">i_blkbits</span></code>, <code class="docutils literal"><span class="pre">i_sb</span></code> and <code class="docutils literal"><span class="pre">i_dev</span></code>;</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">insert_inode_hash()</span></code>: adds the inode to the hash table of inodes; an interesting effect of this call is that the inode will be written to the disk if it is marked as dirty;</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">An inode created with <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code> is not in the hash table, and unless you have serious reasons not to, you must enter it in the hash table;</p>
</div>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">mark_inode_dirty()</span></code>: marks the inode as dirty; at a later moment, it will be written on the disc;</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">iget_locked()</span></code>: loads the inode with the given number from the disk, if it is not already loaded;</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">unlock_new_inode()</span></code>: used in conjunction with <code class="xref c c-func docutils literal"><span class="pre">iget_locked()</span></code>, releases the lock on the inode;</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">iput()</span></code>: tells the kernel that the work on the inode is finished; if no one else uses it, it will be destroyed (after being written on the disk if it is maked as dirty);</p>
</li>
<li><p class="first"><code class="xref c c-func docutils literal"><span class="pre">make_bad_inode()</span></code>: tells the kernel that the inode can not be used; It is generally used from the function that reads the inode when the inode could not be read from the disk, being invalid.</p>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="inode-operations">
<h3>Inode operations<a class="headerlink" href="#inode-operations" title="Permalink to this headline">¶</a></h3>
<div class="section" id="getting-an-inode">
<h4>Getting an inode<a class="headerlink" href="#getting-an-inode" title="Permalink to this headline">¶</a></h4>
<p>One of the main inode operations is obtaining an inode (the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> in VFS).
Until version <code class="docutils literal"><span class="pre">2.6.24</span></code> of the Linux kernel, the developer defined a <code class="docutils literal"><span class="pre">read_inode</span></code> function.
Starting with version <code class="docutils literal"><span class="pre">2.6.25</span></code>, the developer must define a <code class="docutils literal"><span class="pre">&lt;fsname&gt;_iget</span></code> where <code class="docutils literal"><span class="pre">&lt;fsname&gt;</span></code> is the name of the file system.
This function is responsible with finding the VFS inode if it exists or creating a new one and filling it with the information from the disk.</p>
<p>Generally, this function will call <code class="xref c c-func docutils literal"><span class="pre">iget_locked()</span></code> to get the inode structure from VFS. If the inode is newly created then it will need to read the inode from the disk (using <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code>) and fill in the useful information.</p>
<p>An example of such a function is <code class="xref c c-func docutils literal"><span class="pre">minix_iget()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">V1_minix_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bh</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">minix_inode</span> <span class="o">*</span> <span class="n">raw_inode</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">minix_inode_info</span> <span class="o">*</span><span class="n">minix_inode</span> <span class="o">=</span> <span class="n">minix_i</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
      <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

      <span class="n">raw_inode</span> <span class="o">=</span> <span class="n">minix_V1_raw_inode</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw_inode</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
              <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EIO</span><span class="p">);</span>
      <span class="p">...</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">minix_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

      <span class="n">inode</span> <span class="o">=</span> <span class="n">iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
              <span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
              <span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">INODE_VERSION</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">MINIX_V1</span><span class="p">)</span>
              <span class="k">return</span> <span class="n">V1_minix_iget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The minix_iget function gets the VFS inode using <code class="xref c c-func docutils literal"><span class="pre">iget_locked()</span></code>.
If the inode is already existing (not new == the <code class="docutils literal"><span class="pre">I_NEW</span></code> flag is not set) the function returns.
Otherwise, the function calls the <code class="xref c c-func docutils literal"><span class="pre">V1_minix_iget()</span></code> function that will read the inode from the disk using <code class="xref c c-func docutils literal"><span class="pre">minix_V1_raw_inode()</span></code> and then complete the VFS inode with the read information.</p>
</div>
<div class="section" id="superoperations">
<h4>Superoperations<a class="headerlink" href="#superoperations" title="Permalink to this headline">¶</a></h4>
<p>Many of the superoperations (components of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_operations</span></code> structure used by the superblock) are used when working with inodes. These operations are described next:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">alloc_inode</span></code>: allocates an inode.
Usually, this funcion allocates a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">&lt;fsname&gt;_inode_info</span></code> structure and performs basic VFS inode initialization (using <code class="xref c c-func docutils literal"><span class="pre">inode_init_once()</span></code>);
minix uses for allocation the <code class="xref c c-func docutils literal"><span class="pre">kmem_cache_alloc()</span></code> function that interacts with the SLAB subsystem.
For each allocation, the cache construction is called, which in the case of minix is the <code class="xref c c-func docutils literal"><span class="pre">init_once()</span></code> function.
Alternatively, <code class="xref c c-func docutils literal"><span class="pre">kmalloc()</span></code> can be used, in which case the <code class="xref c c-func docutils literal"><span class="pre">inode_init_once()</span></code> function should be called.
The <code class="xref c c-func docutils literal"><span class="pre">alloc_inode()</span></code> function will be called by the <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">iget_locked()</span></code> functions.</li>
<li><code class="docutils literal"><span class="pre">write_inode</span></code> : saves/updates the inode received as a parameter on disk; to update the inode, though inefficient, for beginners it is recommended to use the following sequence of operations:<ul>
<li>load the inode from the disk using the <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> function;</li>
<li>modify the buffer according to the saved inode;</li>
<li>mark the buffer as dirty using <code class="xref c c-func docutils literal"><span class="pre">mark_buffer_dirty()</span></code>; the kernel will then handle its writing on the disk;</li>
<li>an example is the <code class="xref c c-func docutils literal"><span class="pre">minix_write_inode()</span></code> function in the <code class="docutils literal"><span class="pre">minix</span></code> file system</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">evict_inode</span></code>: removes any information about the inode with the number received in the <code class="docutils literal"><span class="pre">i_ino</span></code> field from the disk and memory (both the inode on the disk and the associated data blocks). This involves performing the following operations:<ul>
<li>delete the inode from the disk;</li>
<li>updates disk bitmaps (if any);</li>
<li>delete the inode from the page cache by calling <code class="xref c c-func docutils literal"><span class="pre">truncate_inode_pages()</span></code>;</li>
<li>delete the inode from memory by calling <code class="xref c c-func docutils literal"><span class="pre">clear_inode()</span></code> ;</li>
<li>an example is the <code class="xref c c-func docutils literal"><span class="pre">minix_evict_inode()</span></code> function from the minix file system.</li>
</ul>
</li>
<li><code class="docutils literal"><span class="pre">destroy_inode</span></code> releases the memory occupied by inode</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="inode-operations-1">
<h4>inode_operations<a class="headerlink" href="#inode-operations-1" title="Permalink to this headline">¶</a></h4>
<p>The inode operations are described by the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode_operations</span></code> structure.</p>
<p>Inodes are of several types: file, directory, special file (pipe, fifo), block device, character device, link etc.
For this reason, the operations that an inode needs to implement are different for each type of inode.
Below are detailed operations for a <a class="reference internal" href="#fileinodes"><span class="std std-ref">file type inode</span></a> and a <a class="reference internal" href="#directoryinodes"><span class="std std-ref">directory inode</span></a>.</p>
<p>The operations of an inode are initialized and accessed using the <code class="docutils literal"><span class="pre">i_op</span></code> field of the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="the-file-structure">
<h2>The file structure<a class="headerlink" href="#the-file-structure" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">file</span></code> structure corresponds to a file open by a process and exists only in memory, being associated with an inode.
It is the closest VFS entity to user-space; the structure fields contain familiar information of a user-space file (access mode, file position, etc.) and the operations with it are performed by known system calls (<code class="docutils literal"><span class="pre">read</span></code>, <code class="docutils literal"><span class="pre">write</span></code> , etc.).</p>
<p>The file operations are described by the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> structure.</p>
<p>The file operations for a file system are initialized using the <code class="docutils literal"><span class="pre">i_fop</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code> structure.
When opening a file, the VFS initializes the <code class="docutils literal"><span class="pre">f_op</span></code> field of the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> structure with address of <code class="docutils literal"><span class="pre">inode-&gt;i_fop</span></code>, such that subsequent system calls use the value stored in the <code class="docutils literal"><span class="pre">file-&gt;f_op</span></code>.</p>
</div>
<div class="section" id="regular-files-inodes">
<span id="fileinodes"></span><h2>Regular files inodes<a class="headerlink" href="#regular-files-inodes" title="Permalink to this headline">¶</a></h2>
<p>To work with the inode, the <code class="docutils literal"><span class="pre">i_op</span></code> and <code class="docutils literal"><span class="pre">i_fop</span></code> fields of the inode structure must be filled in.
The type of the inode determines the operations that it needs to implement.</p>
<div class="section" id="regular-files-inode-operations">
<span id="fileoperations"></span><h3>Regular files inode operations<a class="headerlink" href="#regular-files-inode-operations" title="Permalink to this headline">¶</a></h3>
<p>In the <code class="docutils literal"><span class="pre">minix</span></code> file system, the <code class="docutils literal"><span class="pre">minix_file_inode_operations</span></code> structure is defined for the operations on an inode and for the file operations the <code class="docutils literal"><span class="pre">minix_file_operations</span></code> structure is defined:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">minix_file_operations</span> <span class="o">=</span> <span class="p">{</span>
         <span class="p">.</span><span class="n">llseek</span>         <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
         <span class="p">.</span><span class="n">read_iter</span>      <span class="o">=</span> <span class="n">generic_file_read_iter</span><span class="p">,</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">write_iter</span>     <span class="o">=</span> <span class="n">generic_file_write_iter</span><span class="p">,</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">,</span>
         <span class="c1">//...</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">minix_file_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">setattr</span>        <span class="o">=</span> <span class="n">minix_setattr</span><span class="p">,</span>
        <span class="p">.</span><span class="n">getattr</span>        <span class="o">=</span> <span class="n">minix_getattr</span><span class="p">,</span>
<span class="p">};</span>

        <span class="c1">//...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">minix_file_inode_operations</span><span class="p">;</span>
                <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">minix_file_operations</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//...</span>
</pre></div>
</div>
<p>The functions <code class="xref c c-func docutils literal"><span class="pre">generic_file_llseek()</span></code> , <code class="xref c c-func docutils literal"><span class="pre">generic_file_mmap()</span></code> , <code class="xref c c-func docutils literal"><span class="pre">generic_file_read_iter()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">generic_file_write_iter()</span></code> are implemented in the kernel.</p>
<p>For simple file systems, only the truncation operation (<code class="docutils literal"><span class="pre">truncate</span></code> system call) must be implemented.
Although initially there was a dedicated operation, starting with 3.14 the operation was embedded in <code class="docutils literal"><span class="pre">setattr</span></code>: if the paste size is different from the current size of the inode, then a truncate operation must be performed.
An example of implementing this verification is in the <code class="xref c c-func docutils literal"><span class="pre">minix_setattr()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">minix_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">d_inode</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

        <span class="n">error</span> <span class="o">=</span> <span class="n">setattr_prepare</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">error</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
            <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>

                <span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
                <span class="n">minix_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
        <span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The truncate operation involves:</p>
<blockquote>
<div><ul class="simple">
<li>freeing blocks of data on the disk that are now extra (if the new dimension is smaller than the old one) or allocating new blocks (for cases where the new dimension is larger)</li>
<li>updating disk bit maps (if used);</li>
<li>updating the inode;</li>
<li>filling with zero the space that was left unused from the last block using the <code class="xref c c-func docutils literal"><span class="pre">block_truncate_page()</span></code> function.</li>
</ul>
</div></blockquote>
<p>An example of the implementation of the cropping operation is the <code class="xref c c-func docutils literal"><span class="pre">minix_truncate()</span></code> function in the <code class="docutils literal"><span class="pre">minix</span></code> file system.</p>
</div>
<div class="section" id="address-space-operations">
<span id="addressspaceoperations"></span><h3>Address space operations<a class="headerlink" href="#address-space-operations" title="Permalink to this headline">¶</a></h3>
<p>There is a close link between the address space of a process and files: the execution of the programs is done almost exclusively by mapping the file into the process address space.
Because this approach works very well and is quite general, it can also be used for regular system calls such as <code class="docutils literal"><span class="pre">read</span></code> and <code class="docutils literal"><span class="pre">write</span></code>.</p>
<p>The structure that describes the address space is <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">address_space</span></code>, and the operations with it are described by the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">address_space_operations</span></code>. To initialize the address space operations, fill <code class="docutils literal"><span class="pre">inode-&gt;i_mapping-&gt;a_ops</span></code> of the file type inode.</p>
<p>An example is the <code class="docutils literal"><span class="pre">minix_aops</span></code> structure in the minix file system:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">minix_aops</span> <span class="o">=</span> <span class="p">{</span>
       <span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">minix_readpage</span><span class="p">,</span>
       <span class="p">.</span><span class="n">writepage</span> <span class="o">=</span> <span class="n">minix_writepage</span><span class="p">,</span>
       <span class="p">.</span><span class="n">write_begin</span> <span class="o">=</span> <span class="n">minix_write_begin</span><span class="p">,</span>
       <span class="p">.</span><span class="n">write_end</span> <span class="o">=</span> <span class="n">generic_write_end</span><span class="p">,</span>
       <span class="p">.</span><span class="n">bmap</span> <span class="o">=</span> <span class="n">minix_bmap</span>
<span class="p">};</span>

<span class="c1">//...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">minix_aops</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal"><span class="pre">generic_write_end()</span></code> function is already implemented.
Most of the specific functions are very easy to implement, as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">minix_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
         <span class="k">return</span> <span class="n">block_write_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">minix_get_block</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">minix_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
         <span class="k">return</span> <span class="n">block_read_full_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">minix_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">minix_write_failed</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
                <span class="n">minix_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">minix_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
                        <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">block_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span>
                                <span class="n">minix_get_block</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
                <span class="n">minix_write_failed</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">minix_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
         <span class="k">return</span> <span class="n">generic_block_bmap</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">minix_get_block</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>All that needs to be done is to implement <code class="xref c c-type docutils literal"><span class="pre">minix_get_block</span></code>, which has to translate a block of a file into a block on the device.
If the flag <code class="docutils literal"><span class="pre">create</span></code> received as a parameter is set, a new block must be allocated.
In case a new block is created, the bit map must be updated accordingly.
To notify the kernel not to read the block from the disk, <code class="docutils literal"><span class="pre">bh</span></code> must be marked with <code class="xref c c-func docutils literal"><span class="pre">set_buffer_new()</span></code>. The buffer must be associated with the block through <code class="xref c c-func docutils literal"><span class="pre">map_bh()</span></code>.</p>
</div>
</div>
<div class="section" id="dentry-structure">
<h2>Dentry structure<a class="headerlink" href="#dentry-structure" title="Permalink to this headline">¶</a></h2>
<p>Directories operations use the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry</span></code> structure.
Its main task is to make links between inodes and filenames.
The important fields of this structure are presented below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">struct</span> <span class="n">inode</span>             <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>     <span class="cm">/* associated inode */</span>
        <span class="c1">//...</span>
        <span class="k">struct</span> <span class="n">dentry</span>            <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>    <span class="cm">/* dentry object of parent */</span>
        <span class="k">struct</span> <span class="n">qstr</span>              <span class="n">d_name</span><span class="p">;</span>       <span class="cm">/* dentry name */</span>
        <span class="c1">//...</span>

        <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">d_op</span><span class="p">;</span>        <span class="cm">/* dentry operations table */</span>
        <span class="k">struct</span> <span class="n">super_block</span>       <span class="o">*</span><span class="n">d_sb</span><span class="p">;</span>        <span class="cm">/* superblock of file */</span>
        <span class="kt">void</span>                     <span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span>    <span class="cm">/* filesystem-specific data */</span>
        <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Fields meaning:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">d_inode</span></code>: the inode referenced by this dentry;</li>
<li><code class="docutils literal"><span class="pre">d_parent</span></code>: the dentry associated with the parent directory;</li>
<li><code class="docutils literal"><span class="pre">d_name</span></code>: a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">qstr</span></code> structure that contains the fields <code class="docutils literal"><span class="pre">name</span></code> and <code class="docutils literal"><span class="pre">len</span></code> (the name and the length of the name).</li>
<li><code class="docutils literal"><span class="pre">d_op</span></code>: operations with dentries, represented by the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">dentry_operations</span></code> structure.
The kernel implements default operations so there is no need to (re)implement them. Some file systems can do optimizations based on the specific structure of the dentries.</li>
<li><code class="docutils literal"><span class="pre">d_fsdata</span></code>: field reserved for the file system that implements dentry operations;</li>
</ul>
</div></blockquote>
<div class="section" id="dentry-operations">
<h3>Dentry operations<a class="headerlink" href="#dentry-operations" title="Permalink to this headline">¶</a></h3>
<p>The most commonly operations applied to dentries are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">d_make_root</span></code>: allocates the root dentry. It is generally used in the function that is called to read the superblock (<code class="docutils literal"><span class="pre">fill_super</span></code>), which must initialize the root directory.
So the root inode is obtained from the superblock and is used as an argument to this function, to fill the <code class="docutils literal"><span class="pre">s_root</span></code> field from the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">super_block</span></code> structure.</li>
<li><code class="docutils literal"><span class="pre">d_add</span></code>: associates a dentry with an inode; the dentry received as a parameter in the calls discussed above signifies the entry (name, length) that needs to be created. This function will be used when creating/loading a new inode that does not have a dentry associated with it and has not yet been introduced to the hash table of inodes (at <code class="docutils literal"><span class="pre">lookup</span></code>);</li>
<li><code class="docutils literal"><span class="pre">d_instantiate</span></code>: The lighter version of the previous call, in which the dentry was previously added in the hash table.</li>
</ul>
</div></blockquote>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">d_instantiate</span></code> must be used to implement create calls (<code class="docutils literal"><span class="pre">mkdir</span></code>, <code class="docutils literal"><span class="pre">mknod</span></code>, <code class="docutils literal"><span class="pre">rename</span></code>, <code class="docutils literal"><span class="pre">symlink</span></code>) and  NOT <code class="docutils literal"><span class="pre">d_add</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="directory-inodes-operations">
<span id="directoryinodes"></span><h2>Directory inodes operations<a class="headerlink" href="#directory-inodes-operations" title="Permalink to this headline">¶</a></h2>
<p>The operations for directory type inodes have a higher complexity level than the ones for files.
The developer must define operations for inodes and operations for files.
In <code class="docutils literal"><span class="pre">minix</span></code>, these operations are defined in <code class="xref c c-type docutils literal"><span class="pre">minix_dir_inode_operations</span></code> and <code class="xref c c-type docutils literal"><span class="pre">minix_dir_operations</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">minix_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">minix_create</span><span class="p">,</span>
      <span class="p">.</span><span class="n">lookup</span> <span class="o">=</span> <span class="n">minix_lookup</span><span class="p">,</span>
      <span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">minix_link</span><span class="p">,</span>
      <span class="p">.</span><span class="n">unlink</span> <span class="o">=</span> <span class="n">minix_unlink</span><span class="p">,</span>
      <span class="p">.</span><span class="n">symlink</span> <span class="o">=</span> <span class="n">minix_symlink</span><span class="p">,</span>
      <span class="p">.</span><span class="n">mkdir</span> <span class="o">=</span> <span class="n">minix_mkdir</span><span class="p">,</span>
      <span class="p">.</span><span class="n">rmdir</span> <span class="o">=</span> <span class="n">minix_rmdir</span><span class="p">,</span>
      <span class="p">.</span><span class="n">mknod</span> <span class="o">=</span> <span class="n">minix_mknod</span><span class="p">,</span>
      <span class="c1">//...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="n">minix_dir_operations</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
      <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
      <span class="p">.</span><span class="n">iterate</span> <span class="o">=</span> <span class="n">minix_readdir</span><span class="p">,</span>
      <span class="c1">//...</span>
<span class="p">};</span>

        <span class="c1">//...</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
              <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">minix_dir_inode_operations</span><span class="p">;</span>
              <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">minix_dir_operations</span><span class="p">;</span>
              <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">minix_aops</span><span class="p">;</span>
      <span class="p">}</span>
       <span class="c1">//...</span>
</pre></div>
</div>
<p>The only function already implemented is <code class="xref c c-func docutils literal"><span class="pre">generic_read_dir()</span></code>.</p>
<p>The functions that implement the operations on directory inodes are the ones described below.</p>
<div class="section" id="creating-an-inode">
<h3>Creating an inode<a class="headerlink" href="#creating-an-inode" title="Permalink to this headline">¶</a></h3>
<p>The inode creation function is indicated by the field <code class="docutils literal"><span class="pre">create</span></code> in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="xref c c-func docutils literal"><span class="pre">minix_create()</span></code>.
This function is called by the <code class="docutils literal"><span class="pre">open</span></code> and <code class="docutils literal"><span class="pre">creat</span></code> system calls. Such a function performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Introduces a new entry into the physical structure on the disk; the update of the bit maps on the disk must not be forgotten.</li>
<li>Configures access rights to those received as a parameter.</li>
<li>Marks the inode as dirty with the <code class="xref c c-func docutils literal"><span class="pre">mark_inode_dirty()</span></code> function.</li>
<li>Instantiates the directory entry (<code class="docutils literal"><span class="pre">dentry</span></code>) with the <code class="docutils literal"><span class="pre">d_instantiate</span></code> function.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="creating-a-directory">
<h3>Creating a directory<a class="headerlink" href="#creating-a-directory" title="Permalink to this headline">¶</a></h3>
<p>The directory creation function is indicated by the <code class="docutils literal"><span class="pre">mkdir</span></code> field in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="xref c c-func docutils literal"><span class="pre">minix_mkdir()</span></code>.
This function is called by the <code class="docutils literal"><span class="pre">mkdir</span></code> system call. Such a function performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Calls <code class="xref c c-func docutils literal"><span class="pre">minix_create()</span></code>.</li>
<li>Allocates a data block for the directory.</li>
<li>Creates the <code class="docutils literal"><span class="pre">&quot;.&quot;</span></code> and <code class="docutils literal"><span class="pre">&quot;..&quot;</span></code> entries.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="creating-a-link">
<h3>Creating a link<a class="headerlink" href="#creating-a-link" title="Permalink to this headline">¶</a></h3>
<p>The link creation function (hard link) is indicated by the <code class="docutils literal"><span class="pre">symlink</span></code> field in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="xref c c-func docutils literal"><span class="pre">minix_link()</span></code>.
This function is called by the <code class="docutils literal"><span class="pre">link</span></code> system call. Such a function performs the following operations:</p>
<blockquote>
<div><ul class="simple">
<li>Binds the new dentry to the inode.</li>
<li>Increments the <code class="docutils literal"><span class="pre">i_nlink</span></code> field of the inode.</li>
<li>Marks the inode as dirty using the <code class="xref c c-func docutils literal"><span class="pre">mark_inode_dirty()</span></code> function.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="creating-a-symbolic-link">
<h3>Creating a symbolic link<a class="headerlink" href="#creating-a-symbolic-link" title="Permalink to this headline">¶</a></h3>
<p>The symbolic link creation function is indicated by the <code class="docutils literal"><span class="pre">symlink</span></code> field in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="xref c c-func docutils literal"><span class="pre">minix_symlink()</span></code>.
The operations to be performed are similar to <code class="docutils literal"><span class="pre">minix_link</span></code> with the differences being given by the fact that a symbolic link is created.</p>
</div>
<div class="section" id="deleting-a-link">
<h3>Deleting a link<a class="headerlink" href="#deleting-a-link" title="Permalink to this headline">¶</a></h3>
<p>The link delete function (hard link) is indicated by the <code class="docutils literal"><span class="pre">unlink</span></code> field in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="xref c c-func docutils literal"><span class="pre">minix_unlink()</span></code>.
This function is called by the <code class="docutils literal"><span class="pre">unlink</span></code> system call. Such a function performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Deletes the directory entry given as a parameter from the physical disk structure.</li>
<li>Decrements the <code class="docutils literal"><span class="pre">i_nlink</span></code> counter of the inode to which the entry points (otherwise the inode will never be deleted).</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="deleting-a-directory">
<h3>Deleting a directory<a class="headerlink" href="#deleting-a-directory" title="Permalink to this headline">¶</a></h3>
<p>The directory delete function is indicated by the <code class="docutils literal"><span class="pre">rmdir</span></code> field in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="xref c c-func docutils literal"><span class="pre">minix_rmdir()</span></code>.
This function is called by the <code class="docutils literal"><span class="pre">rmdir</span></code> system call.
Such a function performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Performs the operations done by <code class="docutils literal"><span class="pre">minix_unlink</span></code>.</li>
<li>Ensures that the directory is empty; otherwise, returns <code class="docutils literal"><span class="pre">ENOTEMPTY</span></code>.</li>
<li>Also deletes the data blocks.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="searching-for-an-inode-in-a-directory">
<h3>Searching for an inode in a directory<a class="headerlink" href="#searching-for-an-inode-in-a-directory" title="Permalink to this headline">¶</a></h3>
<p>The function that searches for an entry in a directory and extracts the inode is indicated by the <code class="docutils literal"><span class="pre">lookup</span></code> field in the <code class="docutils literal"><span class="pre">inode_operations</span></code> structure.
In the minix case, the function is <code class="docutils literal"><span class="pre">minix_lookup</span></code>.
This function is called indirectly when information about the inode associated with an entry in a directory is needed.
Such a function performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Searches in the directory indicated by <code class="docutils literal"><span class="pre">dir</span></code> the entry having the name <code class="docutils literal"><span class="pre">dentry-&gt;d_name.name</span></code>.</li>
<li>If the entry is found, it will return <code class="docutils literal"><span class="pre">NULL</span></code> and associate the inode with the name using the <code class="xref c c-func docutils literal"><span class="pre">d_add()</span></code> function.</li>
<li>Otherwise, returns <code class="docutils literal"><span class="pre">ERR_PTR</span></code>.</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="iterating-through-entries-in-a-directory">
<h3>Iterating through entries in a directory<a class="headerlink" href="#iterating-through-entries-in-a-directory" title="Permalink to this headline">¶</a></h3>
<p>The function which iterates through the entries in a directory (lists the directory contents) is indicated by the field <code class="docutils literal"><span class="pre">iterate</span></code> in the <code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> structure.
In the minix case, the function is <code class="docutils literal"><span class="pre">minix_readdir</span></code>.
This function is called by the <code class="docutils literal"><span class="pre">readdir</span></code> system call.</p>
<p>The function returns either all entries in the directory or just a part when the buffer allocated for it is not available.
A call of this function can return:</p>
<blockquote>
<div><ul class="simple">
<li>a number equal to the existing number of entries if there is enough space in the corresponding user space buffer;</li>
<li>a number smaller than the actual number of entries, as much as there was space in the corresponding user space buffer;</li>
<li><code class="docutils literal"><span class="pre">0</span></code>, where there are no more entries to read.</li>
</ul>
</div></blockquote>
<p>The function will be called consecutively until all available entries are read. The function is called at least twice.</p>
<blockquote>
<div><ul class="simple">
<li>It is only called twice if:<ul>
<li>the first call reads all entries and returns their number;</li>
<li>the second call returns 0, having no other entries to read.</li>
</ul>
</li>
<li>It is called more than twice if the first call does not return the total number of entries.</li>
</ul>
</div></blockquote>
<p>The function performs the following operations:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Iterates over the entries (the dentries) from the current directory.</li>
<li>For each dentry found, increments <code class="docutils literal"><span class="pre">ctx-&gt;pos</span></code>.</li>
<li>For each valid dentry (an inode other than <code class="docutils literal"><span class="pre">0</span></code>, for example), calls the <code class="xref c c-func docutils literal"><span class="pre">dir_emit()</span></code> function.</li>
<li>If the <code class="xref c c-func docutils literal"><span class="pre">dir_emit()</span></code> function returns a value other than zero, it means that the buffer in the user space is full and the function returns.</li>
</ol>
</div></blockquote>
<p>The arguments of the <code class="docutils literal"><span class="pre">dir_emit</span></code> function are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ctx</span></code> is the directory iteration context, passed as an argument to the <code class="docutils literal"><span class="pre">iterate</span></code> function;</li>
<li><code class="docutils literal"><span class="pre">name</span></code> is the name of the entry (a string of characters);</li>
<li><code class="docutils literal"><span class="pre">name_len</span></code> is the length of the entry name;</li>
<li><code class="docutils literal"><span class="pre">ino</span></code> is the inode number associated with the entry;</li>
<li><code class="docutils literal"><span class="pre">type</span></code> identifies the entry type: <code class="docutils literal"><span class="pre">DT_REG</span></code> (file), <code class="docutils literal"><span class="pre">DT_DIR</span></code> (directory), <code class="docutils literal"><span class="pre">DT_UNKNOWN</span></code> etc. <code class="docutils literal"><span class="pre">DT_UNKNOWN</span></code> can be used when the entry type is unknown.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="bitmap-operations">
<span id="bitmapoperations"></span><h2>Bitmap operations<a class="headerlink" href="#bitmap-operations" title="Permalink to this headline">¶</a></h2>
<p>When working with the file systems, management information (what block is free or busy, what inode is free or busy) is stored using bitmaps.
For this we often need to use bit operations. Such operations are:</p>
<blockquote>
<div><ul class="simple">
<li>searching the first 0 bit: representing a free block or inode</li>
<li>marking a bit as 1: marking a busy block or inode</li>
</ul>
</div></blockquote>
<p>The bitmap operations are found in headers from <code class="docutils literal"><span class="pre">include/asm-generic/bitops</span></code>, especially in <code class="docutils literal"><span class="pre">find.h</span></code> and <code class="docutils literal"><span class="pre">atomic.h</span></code>. Usual functions, with names indicating their role, are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">find_first_zero_bit()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">find_first_bit()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">set_bit()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">clear_bit()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_set_bit()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">test_and_clear_bit()</span></code></li>
</ul>
</div></blockquote>
<p>These functions usually receive the address of the bitmap, possibly its size (in bytes) and, if necessary, the index of the bit that needs to be activated (set) or deactivated (clear).</p>
<p>Some usage examples are listed below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">map</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">array_map</span><span class="p">[</span><span class="n">NUM_BYTES</span><span class="p">];</span>
<span class="kt">size_t</span> <span class="n">idx</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">changed</span><span class="p">;</span>

<span class="cm">/* Find first zero bit in 32 bit integer. */</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">find_first_zero_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;The %zu-th bit is the first zero bit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

<span class="cm">/* Find first one bit in NUM_BYTES bytes array. */</span>
<span class="n">idx</span> <span class="o">=</span> <span class="n">find_first_bit</span><span class="p">(</span><span class="n">array_map</span><span class="p">,</span> <span class="n">NUM_BYTES</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;The %zu-th bit is the first one bit.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Clear the idx-th bit in integer.</span>
<span class="cm"> * It is assumed idx is less the number of bits in integer.</span>
<span class="cm"> */</span>
<span class="n">clear_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Test and set the idx-th bit in array.</span>
<span class="cm"> * It is assumed idx is less the number of bits in array.</span>
<span class="cm"> */</span>
<span class="n">changed</span> <span class="o">=</span> <span class="n">__test_and_set_bit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">imap</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">changed</span><span class="p">)</span>
      <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;%zu-th bit changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>Robert Love -- Linux Kernel Development, Second Edition -- Chapter
12. The Virtual Filesystem</li>
<li>Understanding the Linux Kernel, 3rd edition - Chapter 12. The Virtual
Filesystem</li>
<li><a class="reference external" href="http://www.coda.cs.cmu.edu/doc/talks/linuxvfs/">Linux Virtual File System (presentation)</a></li>
<li><a class="reference external" href="http://www.cyberciti.biz/tips/understanding-unixlinux-file-system-part-i.html">Understanding Unix/Linux Filesystem</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/57369/">Creating Linux virtual filesystems</a></li>
<li><a class="reference external" href="http://www.tldp.org/LDP/tlk/fs/filesystem.html">The Linux Documentation Project - VFS</a></li>
<li><a class="reference external" href="http://www.linux.it/~rubini/docs/vfs/vfs.html">The &quot;Virtual File System&quot; in Linux</a></li>
<li><a class="reference external" href="http://inglorion.net/documents/tutorials/tutorfs/">A Linux Filesystem Tutorial</a></li>
<li><a class="reference external" href="http://www.win.tue.nl/~aeb/linux/lk/lk-8.html">The Linux Virtual File System</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/Documentation/filesystems/vfs.txt">Documentation/filesystems/vfs.txt</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/fs/">File systems sources</a></li>
</ol>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 filesystems。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/filesystems/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a href="#system-message-1"><span class="problematic" id="problematic-1">`练习`_</span></a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>In this lab, we will continue the implementation of the file systems started in the previous one.
For this, we will generate the laboratory skeleton using the following command:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">TODO=5 LABS=filesystems make skels</span>
</pre></div>
</div>
<p class="last">After this, we will start the implementation from <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">5</span></code>.</p>
</div>
<div class="section" id="myfs">
<h3>myfs<a class="headerlink" href="#myfs" title="Permalink to this headline">¶</a></h3>
<p>For the exercises below, we will use the <code class="docutils literal"><span class="pre">myfs</span></code> file system whose implementation we started with the previous lab.
We stopped after mounting the file system and now we will continue with the operations for regular files and directories.
At the end of these exercises, we will be able to create, modify and delete regular directories and files.</p>
<p>We will mostly use the <code class="docutils literal"><span class="pre">inode</span></code> and <code class="docutils literal"><span class="pre">dentry</span></code> VFS structures.
The <code class="docutils literal"><span class="pre">inode</span></code> structure defines a file (of any type: regular, directory, link), while the <code class="docutils literal"><span class="pre">dentry</span></code> structure defines a name, which is an entry in a directory.</p>
<p>For this we will access the <code class="docutils literal"><span class="pre">myfs</span></code> directory in the lab skeleton.
The previously generated skeleton contains the solution for the previous lab; we will start from this. As in the previous lab, we will use the <code class="docutils literal"><span class="pre">ramfs</span></code> file system as a starting point.</p>
<div class="section" id="directory-operations">
<h4>1. Directory operations<a class="headerlink" href="#directory-operations" title="Permalink to this headline">¶</a></h4>
<p>To begin with, we will implement the operations for working with directories.
The operations of creating a file or deleting a file are also directory operations; these operations result in adding or deleting a directory entry (<em>dentry</em>).</p>
<p>At the end of this exercise we will be able to create and delete entries in the file system. We will not be able to read and write to regular files; we will do so in the next exercise.</p>
<p>Follow directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">5</span></code> which will guide you through the steps you need to take.</p>
<p>You will need to specify the following directory operations:</p>
<blockquote>
<div><ul class="simple">
<li>create a file (<code class="docutils literal"><span class="pre">create</span></code> function)</li>
<li>search (<code class="docutils literal"><span class="pre">lookup</span></code> function)</li>
<li>link (<code class="docutils literal"><span class="pre">link</span></code> function)</li>
<li>create directory (<code class="docutils literal"><span class="pre">mkdir</span></code> function)</li>
<li>deletion (<code class="docutils literal"><span class="pre">rmdir</span></code> and <code class="docutils literal"><span class="pre">unlink</span></code> functions)</li>
<li>create node (<code class="docutils literal"><span class="pre">mknod</span></code>)</li>
<li>rename (<code class="docutils literal"><span class="pre">rename</span></code> function)</li>
</ul>
</div></blockquote>
<p>For this, define the <code class="docutils literal"><span class="pre">myfs_dir_inode_operations</span></code> structure in the code, where marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">5</span></code>.
To begin, just define the structure <code class="docutils literal"><span class="pre">myfs_dir_inode_operations</span></code>; you will define the structures <code class="docutils literal"><span class="pre">myfs_file_operations</span></code>, <code class="docutils literal"><span class="pre">myfs_file_inode_operations</span></code> , and <code class="docutils literal"><span class="pre">myfs_aops</span></code> in the next exercise.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Read the section <a class="reference internal" href="#directoryinodes"><span class="std std-ref">Directory inodes operations</span></a></p>
<p class="last">As a model, you are following the <code class="docutils literal"><span class="pre">ramfs_dir_inode_operations</span></code> structure.</p>
</div>
<p>Implement the <code class="docutils literal"><span class="pre">mkdir</span></code>, <code class="docutils literal"><span class="pre">mknod</span></code> and <code class="docutils literal"><span class="pre">create</span></code> operations inside <code class="docutils literal"><span class="pre">myfs_mkdir</span></code>, <code class="docutils literal"><span class="pre">myfs_mknod</span></code> and <code class="docutils literal"><span class="pre">myfs_create</span></code>.
These operations will allow you to create directories and files in the file system.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>We recommend making the code modular using a <code class="docutils literal"><span class="pre">mknod</span></code> function, which you can also use for the next exercise.
For inode reading and allocation, use <code class="docutils literal"><span class="pre">myfs_get_inode</span></code>, which is already implemented.</p>
<p>As a model, follow the next functions implemented in the <code class="docutils literal"><span class="pre">ramfs</span></code> file system:</p>
<blockquote class="last">
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">ramfs_mknod()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">ramfs_mkdir()</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">ramfs_create()</span></code></li>
</ul>
</div></blockquote>
</div>
<p>For the other functions, use generic calls (<code class="docutils literal"><span class="pre">simple_*</span></code>) already defined in VFS.</p>
<p>In the <code class="docutils literal"><span class="pre">myfs_get_inode</span></code> function, initialize the operations fields of the directory inodes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">i_op</span></code> must be initialized to the address of the structure <code class="docutils literal"><span class="pre">myfs_dir_inode_operations</span></code>;</li>
<li><code class="docutils literal"><span class="pre">i_fop</span></code> must be initialized to the address of the structure <code class="docutils literal"><span class="pre">simple_dir_operations</span></code>, defined in VFS.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><code class="docutils literal"><span class="pre">i_op</span></code> is a pointer to a structure of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode_operations</span></code> containing operations that have to do with the inode, which are, for a directory, creating a new entry, listing entries, deleting entries, etc.</p>
<p class="last"><code class="docutils literal"><span class="pre">i_fop</span></code> is a pointer to a structure of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> containing operations that have to do with the <code class="docutils literal"><span class="pre">file</span></code> structure associated with the inode, such as <code class="docutils literal"><span class="pre">read</span></code>, <code class="docutils literal"><span class="pre">write</span></code>, and <code class="docutils literal"><span class="pre">lseek</span></code>.</p>
</div>
<div class="section" id="testing">
<h5>Testing<a class="headerlink" href="#testing" title="Permalink to this headline">¶</a></h5>
<p>Once the module is done, we can test the creation of files and directories.
To do this, we compile the kernel module (using <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code>) and copy the resulting file (<code class="docutils literal"><span class="pre">myfs.ko</span></code>) and the test scripts (<code class="docutils literal"><span class="pre">test-myfs-{1,2}.sh</span></code>) in the virtual machine directory (using <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The test scripts are copied to the virtual machine using <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> only if they are executable:</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="gp">student@workstation:~/linux/tools/labs$</span> chmod +x skels/filesystems/myfs/test-myfs-*.sh
</pre></div>
</div>
</div>
<p>After starting the virtual machine, insert the module, create the mount point and mount the file system:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> insmod myfs.ko
<span class="gp">#</span> mkdir -p /mnt/myfs
<span class="gp">#</span> mount -t myfs none /mnt/myfs
</pre></div>
</div>
<p>Now we can create file hierarchies and subdirectories in the mounted directory (<code class="docutils literal"><span class="pre">/mnt/myfs</span></code>).
We use commands like the ones below:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> touch /mnt/myfs/peanuts.txt
<span class="gp">#</span> mkdir -p /mnt/myfs/mountain/forest
<span class="gp">#</span> touch /mnt/myfs/mountain/forest/tree.txt
<span class="gp">#</span> rm /mnt/myfs/mountain/forest/tree.txt
<span class="gp">#</span> rmdir /mnt/myfs/mountain/forest
</pre></div>
</div>
<p>At this time we can not read or write files. When running commands such as the following ones we will get errors.</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;chocolate&quot;</span> &gt; /mnt/myfs/peanuts.txt
<span class="gp">#</span> cat /mnt/myfs/peanuts.txt
</pre></div>
</div>
<p>This happens because we have not implemented the operations for working with files; we will do so further.</p>
<p>To unload the kernel module, use the command</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">umount /mnt/myfs</span>
<span class="go">rmmod myfs</span>
</pre></div>
</div>
<p>To test the functionality provided by the kernel module, we can use the dedicated script <code class="docutils literal"><span class="pre">test-myfs-1.sh</span></code>.
If the implementation is correct, no error messages will be displayed.</p>
</div>
</div>
<div class="section" id="file-operations">
<h4>2. File operations<a class="headerlink" href="#file-operations" title="Permalink to this headline">¶</a></h4>
<p>We want to implement the operations for working with files, which are used for accessing a file's content: read, write, truncate, etc.
For this you will specify the operations described in the structures <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">inode_operations</span></code>, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> and <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">address_space_operations</span></code>.</p>
<p>Follow the locations marked with <code class="docutils literal"><span class="pre">TODO</span></code> 6 which will guide you through the steps you need to take.</p>
<p>Start by defining <code class="docutils literal"><span class="pre">myfs_file_inode_operations</span></code> and <code class="docutils literal"><span class="pre">myfs_file_operations</span></code>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Read the section <a class="reference internal" href="#fileoperations"><span class="std std-ref">Regular files inode operations</span></a>.</p>
<p>Use the generic function provided by VFS.</p>
<p class="last">An example of implementation is the <code class="docutils literal"><span class="pre">ramfs</span></code> file system.
Follow the implementation of <code class="docutils literal"><span class="pre">ramfs_file_inode_operations</span></code> and <code class="docutils literal"><span class="pre">ramfs_file_operations</span></code>.</p>
</div>
<p>Inside the function <code class="docutils literal"><span class="pre">myfs_get_inode</span></code>, initialize the operations fields for the regular file inodes:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">i_op</span></code> must be initialized to <code class="docutils literal"><span class="pre">myfs_file_inode_operations</span></code>;</li>
<li><code class="docutils literal"><span class="pre">i_fop</span></code> msust be initialized to <code class="docutils literal"><span class="pre">myfs_file_operations</span></code>.</li>
</ul>
</div></blockquote>
<p>Continue with defining the structure <code class="docutils literal"><span class="pre">myfs_aops</span></code>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Read the section <a class="reference internal" href="#addressspaceoperations"><span class="std std-ref">Address space operations</span></a>.</p>
<p>Use the generic functions provided by VFS.</p>
<p>An implementation example is the <code class="docutils literal"><span class="pre">ramfs</span></code> file system: the <code class="docutils literal"><span class="pre">ramfs_aops</span></code> structure.</p>
<p class="last">You do not need to define the function of type <code class="docutils literal"><span class="pre">set_page_dirty</span></code>.</p>
</div>
<p>Initialize the <code class="docutils literal"><span class="pre">i_mapping-&gt;a_ops</span></code> field of the inode structure to <code class="docutils literal"><span class="pre">myfs_aops</span></code>.</p>
<div class="section" id="testing-1">
<h5>Testing<a class="headerlink" href="#testing-1" title="Permalink to this headline">¶</a></h5>
<p>For testing, we use the steps described in the previous exercise.
In addition to those steps, we will now be able to read, write and modify a file using commands like the ones below:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> <span class="nb">echo</span> <span class="s2">&quot;chocolate&quot;</span> &gt; /mnt/myfs/peanuts.txt
<span class="gp">#</span> cat /mnt/myfs/peanuts.txt
</pre></div>
</div>
<p>To test the functionality provided by the module, we can use the dedicated script:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-myfs-2.sh
</pre></div>
</div>
<p>If the implementation is correct, no error messages will be displayed when running the above script.</p>
</div>
</div>
</div>
<div class="section" id="minfs">
<h3>minfs<a class="headerlink" href="#minfs" title="Permalink to this headline">¶</a></h3>
<p>For the exercises below, we will use the minfs file system whose development started in the previous lab.
This is a file system with disk support.
We stopped after mounting the file system and now we will continue with the operations on regular files and directories.
At the end of these exercises we will be able to create and delete entries in the file system.</p>
<p>We will mainly use the <code class="xref c c-type docutils literal"><span class="pre">inode</span></code> and <code class="xref c c-type docutils literal"><span class="pre">dentry</span></code> VFS structures.
The inode structure defines a file (of any type: regular, directory, link), while the dentry structure defines a name, which is a directory entry.</p>
<p>For this we will access the <code class="docutils literal"><span class="pre">minfs/kernel</span></code> directory from the laboratory skeleton.
The generated skeleton contains the solution from the previous lab; we will start from this.
As in the previous lab, we will use the <code class="docutils literal"><span class="pre">minix</span></code> file system as a starting point.</p>
<p>We will use the formatting tool <code class="docutils literal"><span class="pre">mkfs.minfs</span></code> in the <code class="docutils literal"><span class="pre">minfs/user</span></code> directory which is automatically compiled when running <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code> and copied to the virtual machine at <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code>.</p>
<p>The formatting tool prepares a virtual machine disk using a command like</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./mkfs.minfs /dev/vdb
</pre></div>
</div>
<p>After formatting, the disk has a structure like the one in the diagram below:</p>
<img alt="../_images/minfs_arch1.png" src="../_images/minfs_arch1.png" />
<p>As shown in the diagram, <code class="docutils literal"><span class="pre">minfs</span></code> is a minimalist file system.
<code class="docutils literal"><span class="pre">minfs</span></code> contains a maximum of 32 inodes, each inode having a single data block (the file size is limited to block size).
The super block contains a 32-bit map (<code class="docutils literal"><span class="pre">imap</span></code>), each bit indicating the use of an inode.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Before you start working, go through the <code class="docutils literal"><span class="pre">minfs/kernel/minfs.h</span></code> header file.
This file contains the structures and macros that will be used in these exercises.
These structures and macros define the file system as described in the diagram above.</p>
</div>
<div class="section" id="iterate-operation">
<h4>1. Iterate operation<a class="headerlink" href="#iterate-operation" title="Permalink to this headline">¶</a></h4>
<p>At first we want to be able to list the contents of the root directory.
For this we must be able to read the entries in the root directory, which means implementing the <code class="docutils literal"><span class="pre">iterate</span></code> operation.
The <code class="docutils literal"><span class="pre">iterate</span></code> operation is a field within the <code class="docutils literal"><span class="pre">minfs_dir_operations</span></code> structure (of type <code class="docutils literal"><span class="pre">file_operations</span></code>) and is implemented by the function <code class="docutils literal"><span class="pre">minfs_readdir</span></code>. We need to implement this function.</p>
<p>Follow directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">5</span></code> which will guide you through the steps you need to take.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Read the section <a class="reference internal" href="#directoryinodes"><span class="std std-ref">Directory inodes operations</span></a></p>
<p>As a starting point, follow the <code class="xref c c-func docutils literal"><span class="pre">minix_readdir()</span></code> function.
The function is rather complicated, but it gives you an insight into the steps you have to do.</p>
<p class="last">Follow, in <code class="docutils literal"><span class="pre">minfs.c</span></code> and <code class="docutils literal"><span class="pre">minfs.h</span></code>, the definitions of structures <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code>, <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode</span></code> and <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code>.
You will use them in the <code class="docutils literal"><span class="pre">minfs_readdir</span></code> implementation.</p>
</div>
<p>Obtain the inode and the structure <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> associated with the directory.
The structure <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> is useful to find out the directory's data block.
From this structure you get the <code class="docutils literal"><span class="pre">data_block</span></code> field, representing the data block index on the disk.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">To get the structure <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> structure, use <code class="xref c c-func docutils literal"><span class="pre">list_entry()</span></code> or <code class="xref c c-func docutils literal"><span class="pre">container_of()</span></code>.</p>
</div>
<p>Use <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> to read the directory data block.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>The data block of the directory is indicated by the <code class="docutils literal"><span class="pre">data_block</span></code> field of the structure <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> corresponding to the directory.</p>
<p class="last">The data in the block is referenced by the <code class="docutils literal"><span class="pre">b_data</span></code> field of the <code class="docutils literal"><span class="pre">buffer_head</span></code> structure (the usual code will be <code class="docutils literal"><span class="pre">bh-&gt;b_data</span></code>).
This block (being the data block of a directory) contains an array of at most <code class="docutils literal"><span class="pre">MINFS_NUM_ENTRIES</span></code> entries of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code> (directory entries specific to <code class="docutils literal"><span class="pre">minfs</span></code>).
Use casting to <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span> <span class="pre">*</span></code> to work with the data in the block.</p>
</div>
<p>Iterate over all the entries in the data block and fill the user space buffer inside the <code class="docutils literal"><span class="pre">for</span></code> loop.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>For each index, get the corresponding entry of the <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code> by using pointer arithmetics on the <code class="docutils literal"><span class="pre">bh-&gt;b_data</span></code> field.
Ignore dentries that have an <code class="docutils literal"><span class="pre">ino</span></code> field equal to 0. Such a dentry is a free slot in the director's dentry list.</p>
<p>For each valid entry, there is an existing call <code class="xref c c-func docutils literal"><span class="pre">dir_emit()</span></code> with the appropriate parameters. This is the call that sends the dentries to the caller (and then to user space).</p>
<p class="last">Check the call examples in <code class="xref c c-func docutils literal"><span class="pre">qnx6_readdir()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">minix_readdir()</span></code>.</p>
</div>
<div class="section" id="testing-2">
<h5>Testing<a class="headerlink" href="#testing-2" title="Permalink to this headline">¶</a></h5>
<p>Once the module is done, we can test the listing of the root directory contents.
To do this, we compile the kernel module (<code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code>) and copy the result to the virtual machine together with the test scripts (<code class="docutils literal"><span class="pre">minfs/user/test-minfs-{0,1}.sh</span></code>) and the formatting utility (<code class="docutils literal"><span class="pre">minfs/user/mkfs.minfs</span></code>) using <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code>, then start the machine.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The test scripts are copied to the virtual machine only if they are executable:</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="gp">student@eg106:~/src/linux/tools/labs$</span> chmod +x skels/filesystems/minfs/user/test-minfs*.sh
</pre></div>
</div>
</div>
<p>After we start the virtual machine, we format the <code class="docutils literal"><span class="pre">/dev/vdb</span></code> disk, create the mount point and mount the file system:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./mkfs.minfs /dev/vdb
<span class="gp">#</span> mkdir -p /mnt/minfs
<span class="gp">#</span> mount -t minfs /dev/vdb /mnt/minfs
</pre></div>
</div>
<p>Now we can list the contents of the root directory:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ls -l /mnt/minfs
</pre></div>
</div>
<p>We notice that there is already a file (<code class="docutils literal"><span class="pre">a.txt</span></code>); it is created by the formatting utility.</p>
<p>We also notice that we are not allowed to display information for a file using the <code class="docutils literal"><span class="pre">ls</span></code> command.
This is because we have not implemented the <code class="docutils literal"><span class="pre">lookup</span></code> function. We will implement it in the next exercise.</p>
<p>To test the functionality provided by the module, we can use the dedicated script:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-minfs-0.sh
<span class="gp">#</span> ./test-minfs-1.sh
</pre></div>
</div>
</div>
</div>
<div class="section" id="lookup-operation">
<h4>2. Lookup operation<a class="headerlink" href="#lookup-operation" title="Permalink to this headline">¶</a></h4>
<p>To properly list the contents of a directory, we need to implement the search functionality, ie the <code class="docutils literal"><span class="pre">lookup</span></code> operation.
The <code class="docutils literal"><span class="pre">lookup</span></code> operation is a field within the <code class="docutils literal"><span class="pre">minfs_dir_inode_operations</span></code> structure (of type <code class="docutils literal"><span class="pre">inode_operations</span></code>) and is implemented by the <code class="docutils literal"><span class="pre">minfs_lookup</span></code> function.
This function (<code class="docutils literal"><span class="pre">minfs_lookup</span></code>) needs to be implemented.
We will actually implement the <code class="docutils literal"><span class="pre">minfs_find_entry</span></code> function called by <code class="docutils literal"><span class="pre">minfs_lookup</span></code> .</p>
<p>Follow directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">6</span></code> which will tell you the steps you need to take.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Read the section <a class="reference internal" href="#directoryinodes"><span class="std std-ref">Directory inodes operations</span></a></p>
<p class="last">As a starting point, read the functions <code class="xref c c-func docutils literal"><span class="pre">qnx6_find_entry()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">minix_find_entry()</span></code>.</p>
</div>
<p>In the <code class="docutils literal"><span class="pre">minfs_find_entry</span></code> function, iterate over the directory where the dentry is: <code class="docutils literal"><span class="pre">dentry-&gt;d_parent-&gt;d_inode</span></code>.
Iterating means going through the entries in the directory's data block (of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code>) and locate, if it exists, the requested entry.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>From the structure of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> corresponding to the directory, find out the data block index and read it (<code class="docutils literal"><span class="pre">sb_read</span></code>).
You will access the block contents using <code class="docutils literal"><span class="pre">bh-&gt;b_data</span></code>.
The directory data block contains an array of at most <code class="docutils literal"><span class="pre">MINFS_NUM_ENTRIES</span></code> entries of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code>.
Use pointer arithmetics to get entries of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code> from the data block (<code class="docutils literal"><span class="pre">bh-&gt;b_data</span></code>).</p>
<p>Check the presence of the name (stored in the local variable <code class="docutils literal"><span class="pre">name</span></code>) in the directory (if there is an entry in the data block whose name is a string equal to the given name). Use <code class="xref c c-func docutils literal"><span class="pre">strcmp()</span></code> to verify.</p>
<p>Ignore dentries that have an <code class="docutils literal"><span class="pre">ino</span></code> field equal to <code class="docutils literal"><span class="pre">0</span></code>. Those dentries are free slots in the directory dentry list.</p>
<p class="last">Store in the <code class="docutils literal"><span class="pre">final_de</span></code> variable the dentry found.
If you do not find any dentry, then the <code class="docutils literal"><span class="pre">final_de</span></code> variable will have the value <code class="docutils literal"><span class="pre">NULL</span></code>, the value with which it was initialized.</p>
</div>
<p>Comment the <code class="docutils literal"><span class="pre">simple_lookup</span></code> call in the <code class="docutils literal"><span class="pre">minfs_lookup</span></code> function to invoke the implementation of <code class="docutils literal"><span class="pre">minfs_readdir</span></code>.</p>
<div class="section" id="testing-3">
<h5>Testing<a class="headerlink" href="#testing-3" title="Permalink to this headline">¶</a></h5>
<p>For testing, we use the steps described in the previous exercise.
The long file listing (<code class="docutils literal"><span class="pre">ls</span> <span class="pre">-l</span></code>) of the contents of a directory (root directory) will display permissions and other file-specific information:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ls -l /mnt/minfs
</pre></div>
</div>
<p>To test the functionality provided by the module, we can use the dedicated scripts:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-minfs-0.sh
<span class="gp">#</span> ./test-minfs-1.sh
</pre></div>
</div>
<p>If the implementation is correct, no error messages will be displayed when running the scripts above.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>After mounting the file system using the command</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> mount -t minfs /dev/vdb /mnt/minfs
</pre></div>
</div>
<p>we try to create a file using the command</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> touch /mnt/minfs/peanuts.txt
</pre></div>
</div>
<p class="last">We notice that we get an error because we did not implement the directory operations that allow us to create a file.
We will do this for the next exercise.</p>
</div>
</div>
</div>
<div class="section" id="create-operation">
<h4>3. Create operation<a class="headerlink" href="#create-operation" title="Permalink to this headline">¶</a></h4>
<p>In order to allow the creation of a file in a directory, we must implement the <code class="docutils literal"><span class="pre">create</span></code> operation.
The <code class="docutils literal"><span class="pre">create</span></code> operation is a field in the <code class="docutils literal"><span class="pre">minfs_dir_inode_operations</span></code> structure (of type <code class="xref c c-type docutils literal"><span class="pre">inode_operations</span></code>) and is implemented by the <code class="docutils literal"><span class="pre">minfs_create</span></code> function. We need to implement this function.
In fact, we will implement the <code class="docutils literal"><span class="pre">minfs_new_inode</span></code> (which creates and initializes an inode) and <code class="docutils literal"><span class="pre">minfs_add_link</span></code> which adds a link (or name or <em>dentry</em>) for the created inode.</p>
<p>Follow directions marked with <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">7</span></code> which will guide you through the steps you need to take.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Read the section <a class="reference internal" href="#directoryinodes"><span class="std std-ref">Directory inodes operations</span></a></p>
<p class="last">Inspect the code in the <code class="docutils literal"><span class="pre">minfs_create</span></code> and the skeleton of functions <code class="docutils literal"><span class="pre">minfs_new_inode</span></code> and <code class="docutils literal"><span class="pre">minfs_add_link</span></code>.</p>
</div>
<p>Implement the function <code class="docutils literal"><span class="pre">minfs_new_inode</span></code>. Inside this function you will create (using <code class="xref c c-func docutils literal"><span class="pre">new_inode()</span></code>) and initialize an inode. The initialization is done using the data from disk.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>Use the <code class="xref c c-func docutils literal"><span class="pre">minix_new_inode()</span></code> function as a model.
Find the first free inode in imap (<code class="docutils literal"><span class="pre">sbi-&gt;imap</span></code>).
Use bitwise operations (<code class="docutils literal"><span class="pre">find_first_zero_bit</span></code> and <code class="docutils literal"><span class="pre">set_bit</span></code>).
Read the <a class="reference internal" href="#bitmapoperations"><span class="std std-ref">Bitmap operations</span></a> section.</p>
<p>The buffer for the superblock (<code class="docutils literal"><span class="pre">sbi-&gt;sbh</span></code>) must be marked as dirty .</p>
<p class="last">You must initialize the usual fields as it is done for the <code class="docutils literal"><span class="pre">myfs</span></code> file system.
Initialize the <code class="docutils literal"><span class="pre">i_mode</span></code> field to <code class="docutils literal"><span class="pre">0</span></code> in the call to <code class="docutils literal"><span class="pre">inode_init_owner</span></code>. It will be initialized in the caller later.</p>
</div>
<p>Implement the <code class="docutils literal"><span class="pre">minfs_add_link</span></code> function. The function adds a new dentry (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code>) to the parent directory data block (<code class="docutils literal"><span class="pre">dentry-&gt;d_parent-&gt;d_inode</span></code>).</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p class="last">Use the function <code class="docutils literal"><span class="pre">minix_add_link</span></code> function as a model.</p>
</div>
<p>In <code class="docutils literal"><span class="pre">minfs_add_link</span></code> we want to find the first free place for the dentry.
For this, you will iterate over the directory data block and you will find the first free entry. A free dentry has the <code class="docutils literal"><span class="pre">ino</span></code> field equal to <code class="docutils literal"><span class="pre">0</span></code>.</p>
<div class="admonition tip">
<p class="first admonition-title">Tip</p>
<p>In order to work with the directory, get the inode of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> corresponding to the parent directory (the <strong>dir</strong> inode).
Do not use the variable <code class="docutils literal"><span class="pre">inode</span></code> to get <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code>; that inode belongs to the file, not to the parent directory inside which you want to add the link/dentry.
To get the <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> structure, use <code class="xref c c-func docutils literal"><span class="pre">container_of()</span></code>.</p>
<p>The structure <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_inode_info</span></code> is useful for finding the directory data block (the one indicated by the <code class="docutils literal"><span class="pre">dentry-&gt;d_parent-&gt;d_inode</span></code>, which is the <code class="docutils literal"><span class="pre">dir</span></code> variable).
From this structure, get the <code class="docutils literal"><span class="pre">data_block</span></code> field, representing index of the data block on the disk.
This block contains the entries in the directory. Use <code class="xref c c-func docutils literal"><span class="pre">sb_bread()</span></code> to read the block and then <code class="docutils literal"><span class="pre">bh-&gt;b_data</span></code> to refer to the data.
The block contains at most <code class="docutils literal"><span class="pre">MINFS_NUM_ENTRIES</span></code> entries of type <code class="docutils literal"><span class="pre">struct</span> <span class="pre">minfs_dir_entry</span></code>.</p>
<p>If all entries are occupied, return <code class="docutils literal"><span class="pre">-ENOSPC</span></code>.</p>
<p>Iterate over the entries in the data block using the variable <code class="docutils literal"><span class="pre">de</span></code> and extract the first free entry (for which the <code class="docutils literal"><span class="pre">ino</span></code> field is <code class="docutils literal"><span class="pre">0</span></code>).</p>
<p>When you have found a free place, fill in the corresponding entry:</p>
<blockquote>
<div><ul class="simple">
<li>the <code class="docutils literal"><span class="pre">inode-&gt;i_ino</span></code> field in <code class="docutils literal"><span class="pre">de-&gt;ino</span></code></li>
<li>the <code class="docutils literal"><span class="pre">dentry-&gt;d_name.name</span></code> field in <code class="docutils literal"><span class="pre">de-&gt;name</span></code></li>
</ul>
</div></blockquote>
<p class="last">Then mark the buffer dirty.</p>
</div>
<div class="section" id="testing-4">
<h5>Testing<a class="headerlink" href="#testing-4" title="Permalink to this headline">¶</a></h5>
<p>For testing, we use the steps described in the previous exercise.
Now we can create files within the file system:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> touch /mnt/minfs/peanuts.txt
</pre></div>
</div>
<p>To test the functionality provided by the module, we can use the dedicated script:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-minfs-2.sh
</pre></div>
</div>
<p>If the deployment is valid, no error messages will be displayed following the above script run.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The current implementation of the <code class="docutils literal"><span class="pre">minfs</span></code> file system is not definitive.
To be complete, the implementations needs function to delete files, create and delete directories, rename entries, and modify the contents of a file.</p>
</div>
</div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lab8-filesystems-part1.html" class="btn btn-neutral float-left" title="SO2 Lab 08 - File system drivers (Part 1)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab10-networking.html" class="btn btn-neutral float-right" title="SO2 Lab 10 - Networking" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>