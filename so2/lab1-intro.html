<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 01 - Introduction &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 02 - Kernel API" href="lab2-kernel-api.html" />
    <link rel="prev" title="SO2 Lecture 12 - Virtualization" href="lec12-virtualization.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 01 - Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#about-this-laboratory">About this laboratory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
<li class="toctree-l3"><a class="reference internal" href="#documentation">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-modules-overview">Kernel Modules Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#an-example-of-a-kernel-module">An example of a kernel module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compiling-kernel-modules">Compiling kernel modules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-unloading-a-kernel-module">Loading/unloading a kernel module</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-module-debugging">Kernel Module Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objdump">objdump</a></li>
<li class="toctree-l4"><a class="reference internal" href="#addr2line">addr2line</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minicom">minicom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#netconsole">netconsole</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printk-debugging">Printk debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dynamic-debugging">Dynamic debugging</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdb-kernel-debugger">KDB: Kernel debugger</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#remarks">Remarks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#booting-the-virtual-machine">Booting the virtual machine</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-module">1. Kernel module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printk">2. Printk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#error">3. Error</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sub-modules">4. Sub-modules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-oops-1">5. Kernel oops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-parameters">6. Module parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#proc-info-1">7. Proc info</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#good-to-know-1">Good to know</a></li>
<li class="toctree-l3"><a class="reference internal" href="#source-code-navigation">Source code navigation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cscope">cscope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clangd">clangd</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kscope">Kscope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lxr-cross-reference">LXR Cross-Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sourceweb">SourceWeb</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kernel-debugging">Kernel Debugging</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gdb-linux">gdb (Linux)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#getting-a-stack-trace">Getting a stack trace</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机设置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机设置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">Contributing to linux-kernel-labs</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 01 - Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab1-intro.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-01-introduction">
<h1>SO2 Lab 01 - Introduction<a class="headerlink" href="#so2-lab-01-introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>presenting the rules and objectives of the Operating Systems 2 lab</li>
<li>introducing the lab documentation</li>
<li>introducing the Linux kernel and related resources</li>
<li>creating simple modules</li>
<li>describing the process of kernel module compilation</li>
<li>presenting how a module can be used with a kernel</li>
<li>simple kernel debugging methods</li>
</ul>
</div>
<div class="section" id="about-this-laboratory">
<h2>About this laboratory<a class="headerlink" href="#about-this-laboratory" title="Permalink to this headline">¶</a></h2>
<p>The Operating Systems 2 lab is a kernel programming and driver development lab.
The objectives of the laboratory are:</p>
<ul class="simple">
<li>deepening the notions presented in the course</li>
<li>presentation of kernel programming interfaces (kernel API)</li>
<li>gaining documenting, development and debugging skills on a freestanding
environment</li>
<li>acquiring knowledge and skills for drivers development</li>
</ul>
<p>A laboratory will present a set of concepts, applications and commands
specific to a given problem. The lab will start with a presentation
(each lab will have a set of slides) (15 minutes) and the remaining
time will be allocated to the lab exercises (80 minutes).</p>
<p>For best laboratory performance, we recommend that you read the related slides.
To fully understand a laboratory, we recommend going through the lab support. For
in-depth study, use the supporting documentation.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Linux<ul>
<li><a class="reference external" href="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468/">Linux Kernel Development, 3rd
Edition</a></li>
<li><a class="reference external" href="http://free-electrons.com/doc/books/ldd3.pdf">Linux Device Drivers, 3rd
Edition</a></li>
<li><a class="reference external" href="http://www.amazon.com/Essential-Device-Drivers-Sreekrishnan-Venkateswaran/dp/0132396556">Essential Linux Device
Drivers</a></li>
</ul>
</li>
<li>General<ul>
<li><a class="reference external" href="http://cursuri.cs.pub.ro/cgi-bin/mailman/listinfo/pso">mailing list</a>
(<a class="reference external" href="http://blog.gmane.org/gmane.education.region.romania.operating-systems-design">searching the mailing list</a>)</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="documentation">
<h2>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline">¶</a></h2>
<p>Kernel development is a difficult process, compared to user space
programming. The API is different and the complexity of the subsystems
in kernel requires additional preparation. The associated documentation
is heterogeneous, sometimes requiring the inspection of multiple sources
to have a more complete understanding of a certain aspect.</p>
<p>The main advantages of the Linux kernel are the access to sources and
the open development system. Because of this, the Internet offers a
larger number of documentation for the kernel.</p>
<p>A few links related to the Linux kernel are shown bellow:</p>
<ul class="simple">
<li><a class="reference external" href="http://kernelnewbies.org">KernelNewbies</a></li>
<li><a class="reference external" href="http://kernelnewbies.org/KernelHacking">KernelNewbies - Kernel Hacking</a></li>
<li><a class="reference external" href="http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html">Kernel Analysis - HOWTO</a></li>
<li><a class="reference external" href="http://web.archive.org/web/20090228191439/http://www.linuxhq.com/lkprogram.html">Linux Kernel Programming</a></li>
<li><a class="reference external" href="http://en.wikibooks.org/wiki/Linux_kernel">Linux kernel - Wikibooks</a></li>
</ul>
<p>The links are not comprehensive. Using  <a class="reference external" href="http://www.google.com">The Internet</a> and
<a class="reference external" href="http://lxr.free-electrons.com/">kernel source code</a> is essential.</p>
</div>
<div class="section" id="kernel-modules-overview">
<h2>Kernel Modules Overview<a class="headerlink" href="#kernel-modules-overview" title="Permalink to this headline">¶</a></h2>
<p>A monolithic kernel, though faster than a microkernel, has the disadvantage of
lack of modularity and extensibility. On modern monolithic kernels, this has
been solved by using kernel modules. A kernel module (or loadable kernel mode)
is an object file that contains code that can extend the kernel functionality
at runtime (it is loaded as needed); When a kernel module is no longer needed,
it can be unloaded. Most of the device drivers are used in the form of kernel
modules.</p>
<p>For the development of Linux device drivers, it is recommended to download the
kernel sources, configure and compile them and then install the compiled version
on the test /development tool machine.</p>
</div>
<div class="section" id="an-example-of-a-kernel-module">
<h2>An example of a kernel module<a class="headerlink" href="#an-example-of-a-kernel-module" title="Permalink to this headline">¶</a></h2>
<p>Below is a very simple example of a kernel module. When loading into the kernel,
it will generate the message <code class="code docutils literal"><span class="pre">&quot;Hi&quot;</span></code>. When unloading the kernel module, the
<code class="code docutils literal"><span class="pre">&quot;Bye&quot;</span></code> message will be generated.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;My kernel module&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Me&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Hi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dummy_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Bye</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dummy_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dummy_exit</span><span class="p">);</span>
</pre></div>
</div>
<p>The generated messages will not be displayed on the console but will be saved
in a specially reserved memory area for this, from where they will be extracted
by the logging daemon (syslog). To display kernel messages, you can use the
<strong class="command">dmesg</strong> command or inspect the logs:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># cat /var/log/syslog | tail -2</span>
Feb <span class="m">20</span> <span class="m">13</span>:57:38 asgard kernel: Hi
Feb <span class="m">20</span> <span class="m">13</span>:57:43 asgard kernel: Bye

<span class="c1"># dmesg | tail -2</span>
Hi
Bye
</pre></div>
</div>
</div>
<div class="section" id="compiling-kernel-modules">
<h2>Compiling kernel modules<a class="headerlink" href="#compiling-kernel-modules" title="Permalink to this headline">¶</a></h2>
<p>Compiling a kernel module differs from compiling an user program. First, other
headers should be used. Also, the module should not be linked to libraries.
And, last but not least, the module must be compiled with the same options as
the kernel in which we load the module. For these reasons, there is a standard
compilation method (<code class="code docutils literal"><span class="pre">kbuild</span></code>). This method requires the use of two files:
a <code class="file docutils literal"><span class="pre">Makefile</span></code> and a <code class="file docutils literal"><span class="pre">Kbuild</span></code> file.</p>
<p>Below is an example of a <code class="file docutils literal"><span class="pre">Makefile</span></code>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">KDIR</span> <span class="o">=</span> /lib/modules/<span class="sb">`</span>uname -r<span class="sb">`</span>/build

kbuild:
        make -C <span class="k">$(</span>KDIR<span class="k">)</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>

clean:
        make -C <span class="k">$(</span>KDIR<span class="k">)</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> clean
</pre></div>
</div>
<p>And the example of a <code class="file docutils literal"><span class="pre">Kbuild</span></code> file used to compile a module:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">EXTRA_CFLAGS</span> <span class="o">=</span> -Wall -g

obj-m        <span class="o">=</span> modul.o
</pre></div>
</div>
<p>As you can see, calling <strong class="command">make</strong> on the <code class="file docutils literal"><span class="pre">Makefile</span></code> file in the
example shown will result in the <strong class="command">make</strong> invocation in the kernel
source directory (<code class="docutils literal"><span class="pre">/lib/modules/`uname</span> <span class="pre">-r`/build</span></code>) and referring to the
current directory (<code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">`pwd`</span></code>). This process ultimately leads to reading
the <code class="file docutils literal"><span class="pre">Kbuild</span></code> file from the current directory and compiling the module
as instructed in this file.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>For labs we will configure different <strong class="command">KDIR</strong>, according to
the virtual machine specifications:</p>
<div class="last highlight-bash"><div class="highlight"><pre><span></span><span class="nv">KDIR</span> <span class="o">=</span> /home/student/src/linux
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
</div>
<p>A <code class="file docutils literal"><span class="pre">Kbuild</span></code> file contains one or more directives for compiling a kernel
module.  The easiest example of such a directive is <code class="docutils literal"><span class="pre">obj-m</span> <span class="pre">=</span>
<span class="pre">module.o</span></code>. Following this directive, a kernel module (<code class="code docutils literal"><span class="pre">ko</span></code> - kernel
object) will be created, starting from the <code class="docutils literal"><span class="pre">module.o</span></code> file. <code class="docutils literal"><span class="pre">module.o</span></code> will
be created starting from <code class="docutils literal"><span class="pre">module.c</span></code> or <code class="docutils literal"><span class="pre">module.S</span></code>. All of these files can
be found in the <code class="file docutils literal"><span class="pre">Kbuild</span></code>'s directory.</p>
<p>An example of a <code class="file docutils literal"><span class="pre">Kbuild</span></code> file that uses several sub-modules is shown
below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">EXTRA_CFLAGS</span> <span class="o">=</span> -Wall -g

obj-m        <span class="o">=</span> supermodule.o
supermodule-y <span class="o">=</span> module-a.o module-b.o
</pre></div>
</div>
<p>For the example above, the steps to compile are:</p>
<blockquote>
<div><ul class="simple">
<li>compile the <code class="file docutils literal"><span class="pre">module-a.c</span></code> and <code class="file docutils literal"><span class="pre">module-b.c</span></code> sources,
resulting in module-a.o and module-b.o objects</li>
<li><code class="file docutils literal"><span class="pre">module-a.o</span></code> and <code class="file docutils literal"><span class="pre">module-b.o</span></code> will then be linked
in <code class="file docutils literal"><span class="pre">supermodule.o</span></code></li>
<li>from <code class="file docutils literal"><span class="pre">supermodule.o</span></code> will be created <code class="file docutils literal"><span class="pre">supermodule.ko</span></code>
module</li>
</ul>
</div></blockquote>
<p>The suffix of targets in <code class="file docutils literal"><span class="pre">Kbuild</span></code> determines how they are used, as
follows:</p>
<blockquote>
<div><ul class="simple">
<li>M (modules) is a target for loadable kernel modules</li>
<li>Y (yes) represents a target for object files to be compiled and then
linked to a module (<code class="docutils literal"><span class="pre">$(mode_name)-y</span></code>) or within the kernel (<code class="docutils literal"><span class="pre">obj-y</span></code>)</li>
<li>any other target suffix will be ignored by <code class="file docutils literal"><span class="pre">Kbuild</span></code> and will not be
compiled</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These suffixes are used to easily configure the kernel by running the
<strong class="command">make menuconfig</strong> command or directly editing the
<code class="file docutils literal"><span class="pre">.config</span></code> file. This file sets a series of variables that are
used to determine which features are added to the kernel at build
time. For example, when adding BTRFS support with <strong class="command">make
menuconfig</strong>, add the line <code class="code docutils literal"><span class="pre">CONFIG_BTRFS_FS</span> <span class="pre">=</span> <span class="pre">y</span></code> to the
<code class="file docutils literal"><span class="pre">.config</span></code> file.  The BTRFS kbuild contains the line
<code class="docutils literal"><span class="pre">obj-$(CONFIG_BTRFS_FS):=</span> <span class="pre">btrfs.o</span></code>, which becomes <code class="docutils literal"><span class="pre">obj-y:=</span>
<span class="pre">btrfs.o</span></code>. This will compile the <code class="file docutils literal"><span class="pre">btrfs.o</span></code> object and will be
linked to the kernel. Before the variable was set, the line became
<code class="docutils literal"><span class="pre">obj:=btrfs.o</span></code> and so it was ignored, and the kernel was build
without BTRFS support.</p>
</div>
<p>For more details, see the <code class="file docutils literal"><span class="pre">Documentation/kbuild/makefiles.txt</span></code> and
<code class="file docutils literal"><span class="pre">Documentation/kbuild/modules.txt</span></code> files within the kernel sources.</p>
</div>
<div class="section" id="loading-unloading-a-kernel-module">
<h2>Loading/unloading a kernel module<a class="headerlink" href="#loading-unloading-a-kernel-module" title="Permalink to this headline">¶</a></h2>
<p>To load a kernel module, use the <strong class="command">insmod</strong> utility. This utility
receives as a parameter the path to the <code class="file docutils literal"><span class="pre">*.ko</span></code> file in which the module
was compiled and linked.  Unloading the module from the kernel is done using
the <strong class="command">rmmod</strong> command, which receives the module name as a parameter.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ insmod module.ko
$ rmmod module.ko
</pre></div>
</div>
<p>When loading the kernel module, the routine specified as a parameter of the
<code class="docutils literal"><span class="pre">module_init</span></code> macro will be executed. Similarly, when the module is unloaded
the routine specified as a parameter of the <code class="docutils literal"><span class="pre">module_exit</span></code> will be executed.</p>
<p>A complete example of compiling and loading/unloading a kernel module is
presented below:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-lin# ls
Kbuild  Makefile  modul.c

faust:~/lab-01/modul-lin# make
make -C /lib/modules/<span class="sb">`</span>uname -r<span class="sb">`</span>/build <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
make<span class="o">[</span><span class="m">1</span><span class="o">]</span>: Entering directory <span class="sb">`</span>/usr/src/linux-2.6.28.4<span class="s1">&#39;</span>
<span class="s1">  LD      /root/lab-01/modul-lin/built-in.o</span>
<span class="s1">  CC [M]  /root/lab-01/modul-lin/modul.o</span>
<span class="s1">  Building modules, stage 2.</span>
<span class="s1">  MODPOST 1 modules</span>
<span class="s1">  CC      /root/lab-01/modul-lin/modul.mod.o</span>
<span class="s1">  LD [M]  /root/lab-01/modul-lin/modul.ko</span>
<span class="s1">make[1]: Leaving directory `/usr/src/linux-2.6.28.4&#39;</span>

faust:~/lab-01/modul-lin# ls
built-in.o  Kbuild  Makefile  modul.c  Module.markers
modules.order  Module.symvers  modul.ko  modul.mod.c
modul.mod.o  modul.o

faust:~/lab-01/modul-lin# insmod modul.ko

faust:~/lab-01/modul-lin# dmesg <span class="p">|</span> tail -1
Hi

faust:~/lab-01/modul-lin# rmmod modul

faust:~/lab-01/modul-lin# dmesg <span class="p">|</span> tail -2
Hi
Bye
</pre></div>
</div>
<p>Information about modules loaded into the kernel can be found using the
<strong class="command">lsmod</strong> command or by inspecting the <code class="file docutils literal"><span class="pre">/proc/modules</span></code>,
<code class="file docutils literal"><span class="pre">/sys/module</span></code> directories.</p>
</div>
<div class="section" id="kernel-module-debugging">
<h2>Kernel Module Debugging<a class="headerlink" href="#kernel-module-debugging" title="Permalink to this headline">¶</a></h2>
<p>Troubleshooting a kernel module is much more complicated than debugging a
regular program. First, a mistake in a kernel module can lead to blocking the
entire system. Troubleshooting is therefore much slowed down. To avoid reboot,
it is recommended to use a virtual machine (qemu, virtualbox, vmware).</p>
<p>When a module containing bugs is inserted into the kernel, it will eventually
generate a <a class="reference external" href="https://en.wikipedia.org/wiki/Linux_kernel_oops">kernel oops</a>.
A kernel oops is an invalid operation detected by the kernel and can only
be generated by the kernel. For a stable kernel version, it almost certainly
means that the module contains a bug. After the oops appears, the kernel will
continue to work.</p>
<p>Very important to the appearance of a kernel oops is saving the generated
message. As noted above, messages generated by the kernel are saved in logs and
can be displayed with the <strong class="command">dmesg</strong> command. To make sure that no kernel
message is lost, it is recommended to insert/test the kernel directly from the
console, or periodically check the kernel messages. Noteworthy is that an oops
can occur because of a programming error, but also a because of hardware error.</p>
<p>If a fatal error occurs, after which the system can not return to a stable
state, a <a class="reference external" href="https://en.wikipedia.org/wiki/Linux_kernel_panic">kernel panic</a> is
generated.</p>
<p>Look at the kernel module below that contains a bug that generates an oops:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Oops generating kernel module</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>

<span class="n">MODULE_DESCRIPTION</span> <span class="p">(</span><span class="s">&quot;Oops&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span> <span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span> <span class="p">(</span><span class="s">&quot;PSO&quot;</span><span class="p">);</span>

<span class="cp">#define OP_READ         0</span>
<span class="cp">#define OP_WRITE        1</span>
<span class="cp">#define OP_OOPS         OP_WRITE</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_oops_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x00001234</span><span class="p">;</span>
<span class="cp">#if OP_OOPS == OP_WRITE</span>
        <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="cp">#elif OP_OOPS == OP_READ</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;Unknown op for oops!&quot;</span>
<span class="cp">#endif</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_oops_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">module_init</span> <span class="p">(</span><span class="n">my_oops_init</span><span class="p">);</span>
<span class="n">module_exit</span> <span class="p">(</span><span class="n">my_oops_exit</span><span class="p">);</span>
</pre></div>
</div>
<p>Inserting this module into the kernel will generate an oops:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# insmod oops.ko
<span class="o">[</span>...<span class="o">]</span>

faust:~/lab-01/modul-oops# dmesg <span class="p">|</span> tail -32
BUG: unable to handle kernel paging request at <span class="m">00001234</span>
IP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span>
  *de <span class="o">=</span> <span class="m">00000000</span>
Oops: <span class="m">0002</span> <span class="o">[</span><span class="c1">#1] PREEMPT DEBUG_PAGEALLOC</span>
last sysfs file: /sys/devices/virtual/net/lo/operstate
Modules linked in: oops<span class="o">(</span>+<span class="o">)</span> netconsole ide_cd_mod pcnet32 crc32 cdrom <span class="o">[</span>last unloaded: modul<span class="o">]</span>

Pid: <span class="m">4157</span>, comm: insmod Not tainted <span class="o">(</span><span class="m">2</span>.6.28.4 <span class="c1">#2) VMware Virtual Platform</span>
EIP: <span class="m">0060</span>:<span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> EFLAGS: <span class="m">00010246</span> CPU: <span class="m">0</span>
EIP is at my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span>
EAX: <span class="m">00000000</span> EBX: fffffffc ECX: c89d4300 EDX: <span class="m">00000001</span>
ESI: c89d4000 EDI: <span class="m">00000000</span> EBP: c5799e24 ESP: c5799e24
 DS: 007b ES: 007b FS: <span class="m">0000</span> GS: <span class="m">0033</span> SS: <span class="m">0068</span>
Process insmod <span class="o">(</span>pid: <span class="m">4157</span>, <span class="nv">ti</span><span class="o">=</span>c5799000 <span class="nv">task</span><span class="o">=</span>c665c780 task.ti<span class="o">=</span>c5799000<span class="o">)</span>
Stack:
 c5799f8c c010102d c72b51d8 0000000c c5799e58 c01708e4 <span class="m">00000124</span> <span class="m">00000000</span>
 c89d4300 c5799e58 c724f448 <span class="m">00000001</span> c89d4300 c5799e60 c0170981 c5799f8c
 c014b698 <span class="m">00000000</span> <span class="m">00000000</span> c5799f78 c5799f20 <span class="m">00000500</span> c665cb00 c89d4300
Call Trace:
 <span class="o">[</span>&lt;c010102d&gt;<span class="o">]</span> ? _stext+0x2d/0x170
 <span class="o">[</span>&lt;c01708e4&gt;<span class="o">]</span> ? __vunmap+0xa4/0xf0
 <span class="o">[</span>&lt;c0170981&gt;<span class="o">]</span> ? vfree+0x21/0x30
 <span class="o">[</span>&lt;c014b698&gt;<span class="o">]</span> ? load_module+0x19b8/0x1a40
 <span class="o">[</span>&lt;c035e965&gt;<span class="o">]</span> ? __mutex_unlock_slowpath+0xd5/0x140
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c014b7aa&gt;<span class="o">]</span> ? sys_init_module+0x8a/0x1b0
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c0240a08&gt;<span class="o">]</span> ? trace_hardirqs_on_thunk+0xc/0x10
 <span class="o">[</span>&lt;c0103407&gt;<span class="o">]</span> ? sysenter_do_call+0x12/0x43
Code: &lt;c7&gt; <span class="m">05</span> <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> <span class="m">03</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 5d c3 eb 0d <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span>
EIP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span> SS:ESP <span class="m">0068</span>:c5799e24
---<span class="o">[</span> end trace 2981ce73ae801363 <span class="o">]</span>---
</pre></div>
</div>
<p>Although relatively cryptic, the message provided by the kernel to the
appearance of an oops provides valuable information about the error. First line:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>BUG: unable to handle kernel paging request at <span class="m">00001234</span>
EIP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init + 0x5 / 0x20 <span class="o">[</span>oops<span class="o">]</span>
</pre></div>
</div>
<p>Tells us the cause and the address of the instruction that generated the error.
In our case this is an invalid access to memory.</p>
<p>Next line</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">Oops:</span> <span class="pre">0002</span> <span class="pre">[#</span> <span class="pre">1]</span> <span class="pre">PREEMPT</span> <span class="pre">DEBUG_PAGEALLOC</span></code></div></blockquote>
<p>Tells us that it's the first oops (#1). This is important in the context that
an oops can lead to other oopses. Usually only the first oops is relevant.
Furthermore, the oops code (<code class="docutils literal"><span class="pre">0002</span></code>) provides information about the error type
(see <code class="file docutils literal"><span class="pre">arch/x86/include/asm/trap_pf.h</span></code>):</p>
<blockquote>
<div><ul class="simple">
<li>Bit 0 == 0 means no page found, 1 means protection fault</li>
<li>Bit 1 == 0 means read, 1 means write</li>
<li>Bit 2 == 0 means kernel, 1 means user mode</li>
</ul>
</div></blockquote>
<p>In this case, we have a write access that generated the oops (bit 1 is 1).</p>
<p>Below is a dump of the registers. It decodes the instruction pointer (<code class="docutils literal"><span class="pre">EIP</span></code>)
value and notes that the bug appeared in the <code class="code docutils literal"><span class="pre">my_oops_init</span></code> function with
a 5-byte offset (<code class="docutils literal"><span class="pre">EIP:</span> <span class="pre">[&lt;c89d4005&gt;]</span> <span class="pre">my_oops_init+0x5</span></code>). The message also
shows the stack content and a backtrace of calls until then.</p>
<p>If an invalid read call is generated (<code class="docutils literal"><span class="pre">#define</span> <span class="pre">OP_OOPS</span> <span class="pre">OP_READ</span></code>), the message
will be the same, but the oops code will differ, which would now be <code class="docutils literal"><span class="pre">0000</span></code>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# dmesg <span class="p">|</span> tail -33
BUG: unable to handle kernel paging request at <span class="m">00001234</span>
IP: <span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span>
  *de <span class="o">=</span> <span class="m">00000000</span>
Oops: <span class="m">0000</span> <span class="o">[</span><span class="c1">#1] PREEMPT DEBUG_PAGEALLOC</span>
last sysfs file: /sys/devices/virtual/net/lo/operstate
Modules linked in: oops<span class="o">(</span>+<span class="o">)</span> netconsole pcnet32 crc32 ide_cd_mod cdrom

Pid: <span class="m">2754</span>, comm: insmod Not tainted <span class="o">(</span><span class="m">2</span>.6.28.4 <span class="c1">#2) VMware Virtual Platform</span>
EIP: <span class="m">0060</span>:<span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> EFLAGS: <span class="m">00010292</span> CPU: <span class="m">0</span>
EIP is at my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span>
EAX: <span class="m">00000000</span> EBX: fffffffc ECX: c89c3380 EDX: <span class="m">00000001</span>
ESI: c89c3010 EDI: <span class="m">00000000</span> EBP: c57cbe24 ESP: c57cbe1c
 DS: 007b ES: 007b FS: <span class="m">0000</span> GS: <span class="m">0033</span> SS: <span class="m">0068</span>
Process insmod <span class="o">(</span>pid: <span class="m">2754</span>, <span class="nv">ti</span><span class="o">=</span>c57cb000 <span class="nv">task</span><span class="o">=</span>c66ec780 task.ti<span class="o">=</span>c57cb000<span class="o">)</span>
Stack:
 c57cbe34 <span class="m">00000282</span> c57cbf8c c010102d c57b9280 0000000c c57cbe58 c01708e4
 <span class="m">00000124</span> <span class="m">00000000</span> c89c3380 c57cbe58 c5db1d38 <span class="m">00000001</span> c89c3380 c57cbe60
 c0170981 c57cbf8c c014b698 <span class="m">00000000</span> <span class="m">00000000</span> c57cbf78 c57cbf20 <span class="m">00000580</span>
Call Trace:
 <span class="o">[</span>&lt;c010102d&gt;<span class="o">]</span> ? _stext+0x2d/0x170
 <span class="o">[</span>&lt;c01708e4&gt;<span class="o">]</span> ? __vunmap+0xa4/0xf0
 <span class="o">[</span>&lt;c0170981&gt;<span class="o">]</span> ? vfree+0x21/0x30
 <span class="o">[</span>&lt;c014b698&gt;<span class="o">]</span> ? load_module+0x19b8/0x1a40
 <span class="o">[</span>&lt;c035d083&gt;<span class="o">]</span> ? printk+0x0/0x1a
 <span class="o">[</span>&lt;c035e965&gt;<span class="o">]</span> ? __mutex_unlock_slowpath+0xd5/0x140
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c014b7aa&gt;<span class="o">]</span> ? sys_init_module+0x8a/0x1b0
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c0240a08&gt;<span class="o">]</span> ? trace_hardirqs_on_thunk+0xc/0x10
 <span class="o">[</span>&lt;c0103407&gt;<span class="o">]</span> ? sysenter_do_call+0x12/0x43
Code: &lt;a1&gt; <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> c7 <span class="m">04</span> <span class="m">24</span> <span class="m">54</span> <span class="m">30</span> 9c c8 <span class="m">89</span> <span class="m">44</span> <span class="m">24</span> <span class="m">04</span> e8 <span class="m">58</span> a0 <span class="m">99</span> f7 <span class="m">31</span>
EIP: <span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span> SS:ESP <span class="m">0068</span>:c57cbe1c
---<span class="o">[</span> end trace 45eeb3d6ea8ff1ed <span class="o">]</span>---
</pre></div>
</div>
<div class="section" id="objdump">
<h3>objdump<a class="headerlink" href="#objdump" title="Permalink to this headline">¶</a></h3>
<p>Detailed information about the instruction that generated the oops can be found
using the <strong class="command">objdump</strong> utility. Useful options to use are <strong class="command">-d</strong>
to disassemble the code and <strong class="command">-S</strong> for interleaving C code in assembly
language code.  For efficient decoding, however, we need the address where the
kernel module was loaded. This can be found in <code class="file docutils literal"><span class="pre">/proc/modules</span></code>.</p>
<p>Here's an example of using <strong class="command">objdump</strong> on the above module to identify
the instruction that generated the oops:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# cat /proc/modules
oops <span class="m">1280</span> <span class="m">1</span> - Loading 0xc89d4000
netconsole <span class="m">8352</span> <span class="m">0</span> - Live 0xc89ad000
pcnet32 <span class="m">33412</span> <span class="m">0</span> - Live 0xc895a000
ide_cd_mod <span class="m">34952</span> <span class="m">0</span> - Live 0xc8903000
crc32 <span class="m">4224</span> <span class="m">1</span> pcnet32, Live 0xc888a000
cdrom <span class="m">34848</span> <span class="m">1</span> ide_cd_mod, Live 0xc886d000

faust:~/lab-01/modul-oops# objdump -dS --adjust-vma<span class="o">=</span>0xc89d4000 oops.ko

oops.ko:     file format elf32-i386


Disassembly of section .text:

c89d4000 &lt;init_module&gt;:
<span class="c1">#define OP_READ         0</span>
<span class="c1">#define OP_WRITE        1</span>
<span class="c1">#define OP_OOPS         OP_WRITE</span>

static int my_oops_init <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4000:       <span class="m">55</span>                      push   %ebp
<span class="c1">#else</span>
<span class="c1">#error &quot;Unknown op for oops!&quot;</span>
<span class="c1">#endif</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
c89d4001:       <span class="m">31</span> c0                   xor    %eax,%eax
<span class="c1">#define OP_READ         0</span>
<span class="c1">#define OP_WRITE        1</span>
<span class="c1">#define OP_OOPS         OP_WRITE</span>

static int my_oops_init <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4003:       <span class="m">89</span> e5                   mov    %esp,%ebp
        int *a<span class="p">;</span>

        <span class="nv">a</span> <span class="o">=</span> <span class="o">(</span>int *<span class="o">)</span> 0x00001234<span class="p">;</span>
<span class="c1">#if OP_OOPS == OP_WRITE</span>
        *a <span class="o">=</span> <span class="m">3</span><span class="p">;</span>
c89d4005:       c7 <span class="m">05</span> <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> <span class="m">03</span>    movl   <span class="nv">$0</span>x3,0x1234
c89d400c:       <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
<span class="c1">#else</span>
<span class="c1">#error &quot;Unknown op for oops!&quot;</span>
<span class="c1">#endif</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
c89d400f:       5d                      pop    %ebp
c89d4010:       c3                      ret
c89d4011:       eb 0d                   jmp    c89c3020 &lt;cleanup_module&gt;
c89d4013:       <span class="m">90</span>                      nop
c89d4014:       <span class="m">90</span>                      nop
c89d4015:       <span class="m">90</span>                      nop
c89d4016:       <span class="m">90</span>                      nop
c89d4017:       <span class="m">90</span>                      nop
c89d4018:       <span class="m">90</span>                      nop
c89d4019:       <span class="m">90</span>                      nop
c89d401a:       <span class="m">90</span>                      nop
c89d401b:       <span class="m">90</span>                      nop
c89d401c:       <span class="m">90</span>                      nop
c89d401d:       <span class="m">90</span>                      nop
c89d401e:       <span class="m">90</span>                      nop
c89d401f:       <span class="m">90</span>                      nop

c89d4020 &lt;cleanup_module&gt;:

static void my_oops_exit <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4020:       <span class="m">55</span>                      push   %ebp
c89d4021:       <span class="m">89</span> e5                   mov    %esp,%ebp
<span class="o">}</span>
c89d4023:       5d                      pop    %ebp
c89d4024:       c3                      ret
c89d4025:       <span class="m">90</span>                      nop
c89d4026:       <span class="m">90</span>                      nop
c89d4027:       <span class="m">90</span>                      nop
</pre></div>
</div>
<p>Note that the instruction that generated the oops (<code class="docutils literal"><span class="pre">c89d4005</span></code> identified
earlier) is:</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">C89d4005:</span> <span class="pre">c7</span> <span class="pre">05</span> <span class="pre">34</span> <span class="pre">12</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">03</span> <span class="pre">movl</span> <span class="pre">$</span> <span class="pre">0x3,0x1234</span></code></div></blockquote>
<p>That is exactly what was expected - storing value 3 at 0x0001234.</p>
<p>The <code class="file docutils literal"><span class="pre">/proc/modules</span></code> is used to find the address where a kernel module is
loaded.  The <strong class="command">--adjust-vma</strong> option allows you to display instructions
relative to <code class="docutils literal"><span class="pre">0xc89d4000</span></code>. The <strong class="command">-l</strong> option displays the number of
each line in the source code interleaved with the assembly language code.</p>
</div>
<div class="section" id="addr2line">
<h3>addr2line<a class="headerlink" href="#addr2line" title="Permalink to this headline">¶</a></h3>
<p>A more simplistic way to find the code that generated an oops is to use the
<strong class="command">addr2line</strong> utility:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# addr2line -e oops.o 0x5
/root/lab-01/modul-oops/oops.c:23
</pre></div>
</div>
<p>Where <code class="docutils literal"><span class="pre">0x5</span></code> is the value of the program counter (<code class="docutils literal"><span class="pre">EIP</span> <span class="pre">=</span> <span class="pre">c89d4005</span></code>) that
generated the oops, minus the base address of the module (<code class="docutils literal"><span class="pre">0xc89d4000</span></code>)
according to <code class="file docutils literal"><span class="pre">/proc/modules</span></code></p>
</div>
<div class="section" id="minicom">
<h3>minicom<a class="headerlink" href="#minicom" title="Permalink to this headline">¶</a></h3>
<p><strong class="command">Minicom</strong> (or other equivalent utilities, eg <strong class="command">picocom</strong>,
<strong class="command">screen</strong>) is a utility that can be used to connect and interact with a
serial port. The serial port is the basic method for analyzing kernel messages
or interacting with an embedded system in the development phase. There are two
more common ways to connect:</p>
<ul class="simple">
<li>a serial port where the device we are going to use is <code class="file docutils literal"><span class="pre">/dev/ttyS0</span></code></li>
<li>a serial USB port (FTDI) in which case the device we are going to use is
<code class="file docutils literal"><span class="pre">/dev/ttyUSB</span></code>.</li>
</ul>
<p>For the virtual machine used in the lab, the device that we need to use is
displayed after the virtual machine starts:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>char device redirected to /dev/pts/20 <span class="o">(</span>label virtiocon0<span class="o">)</span>
</pre></div>
</div>
<p>Minicom use:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1">#for connecting via COM1 and using a speed of 115,200 characters per second</span>
minicom -b <span class="m">115200</span> -D /dev/ttyS0

<span class="c1">#For USB serial port connection</span>
minicom -D /dev/ttyUSB0

<span class="c1">#To connect to the serial port of the virtual machine</span>
minicom -D /dev/pts/20
</pre></div>
</div>
</div>
<div class="section" id="netconsole">
<h3>netconsole<a class="headerlink" href="#netconsole" title="Permalink to this headline">¶</a></h3>
<p><strong class="command">Netconsole</strong> is a utility that allows logging of kernel debugging
messages over the network. This is useful when the disk logging system does not
work or when serial ports are not available or when the terminal does not
respond to commands. <strong class="command">Netconsole</strong> comes in the form of a kernel
module.</p>
<p>To work, it needs the following parameters:</p>
<blockquote>
<div><ul class="simple">
<li>port, IP address, and the source interface name of the debug station</li>
<li>port, MAC address, and IP address of the machine to which the debug
messages will be sent</li>
</ul>
</div></blockquote>
<p>These parameters can be configured when the module is inserted into the kernel,
or even while the module is inserted if it has been compiled with the
<code class="docutils literal"><span class="pre">CONFIG_NETCONSOLE_DYNAMIC</span></code> option.</p>
<p>An example configuration when inserting <strong class="command">netconsole</strong> kernel module is
as follows:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>alice:~# modprobe netconsole <span class="nv">netconsole</span><span class="o">=</span><span class="m">6666</span>@192.168.191.130/eth0,6000@192.168.191.1/00:50:56:c0:00:08
</pre></div>
</div>
<p>Thus, the debug messages on the station that has the address
<code class="docutils literal"><span class="pre">192.168.191.130</span></code> will be sent to the <code class="docutils literal"><span class="pre">eth0</span></code> interface, having source port
<code class="docutils literal"><span class="pre">6666</span></code>. The messages will be sent to <code class="docutils literal"><span class="pre">192.168.191.1</span></code> with the MAC address
<code class="docutils literal"><span class="pre">00:50:56:c0:00:08</span></code>, on port <code class="docutils literal"><span class="pre">6000</span></code>.</p>
<p>Messages can be played on the destination station using <strong class="command">netcat</strong>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>bob:~ <span class="c1"># nc -l -p 6000 -u</span>
</pre></div>
</div>
<p>Alternatively, the destination station can configure <strong class="command">syslogd</strong> to
intercept these messages. More information can be found in
<code class="file docutils literal"><span class="pre">Documentation/networking/netconsole.txt</span></code>.</p>
</div>
<div class="section" id="printk-debugging">
<h3>Printk debugging<a class="headerlink" href="#printk-debugging" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">The</span> <span class="pre">two</span> <span class="pre">oldest</span> <span class="pre">and</span> <span class="pre">most</span> <span class="pre">useful</span> <span class="pre">debugging</span> <span class="pre">aids</span> <span class="pre">are</span> <span class="pre">Your</span> <span class="pre">Brain</span> <span class="pre">and</span> <span class="pre">Printf</span></code>.</p>
<p>For debugging, a primitive way is often used, but it is quite effective:
<code class="code docutils literal"><span class="pre">printk</span></code> debugging. Although a debugger can also be used, it is generally
not very useful: simple bugs (uninitialized variables, memory management
problems, etc.)  can be easily localized by control messages and the
kernel-decoded oop message.</p>
<p>For more complex bugs, even a debugger can not help us too much unless the
operating system structure is very well understood. When debugging a kernel
module, there are a lot of unknowns in the equation: multiple contexts (we have
multiple processes and threads running at a time), interruptions, virtual
memory, etc.</p>
<p>You can use <code class="code docutils literal"><span class="pre">printk</span></code> to display kernel messages to user space. It is
similar to <code class="code docutils literal"><span class="pre">printf</span></code>'s functionality; the only difference is that the
transmitted message can be prefixed with a string of <code class="code docutils literal"><span class="pre">&quot;&lt;n&gt;&quot;</span></code>, where
<code class="code docutils literal"><span class="pre">n</span></code> indicates the error level (loglevel) and has values between <code class="docutils literal"><span class="pre">0</span></code> and
<code class="docutils literal"><span class="pre">7</span></code>. Instead of <code class="code docutils literal"><span class="pre">&quot;&lt;n&gt;&quot;</span></code>, the levels can also be coded by symbolic
constants:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">KERN_EMERG</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">KERN_ALERT</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">KERN_CRIT</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">KERN_ERR</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">KERN_WARNING</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">KERN_NOTICE</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">KERN_INFO</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">KERN_DEBUG</span> <span class="o">-</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
<p>The definitions of all log levels are found in <code class="file docutils literal"><span class="pre">linux/kern_levels.h</span></code>.
Basically, these log levels are used by the system to route messages sent to
various outputs: console, log files in <code class="file docutils literal"><span class="pre">/var/log</span></code> etc.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To display <code class="code docutils literal"><span class="pre">printk</span></code> messages in user space, the <code class="code docutils literal"><span class="pre">printk</span></code>
log level must be of higher priority than <cite>console_loglevel</cite>
variable. The default console log level can be configured from
<code class="file docutils literal"><span class="pre">/proc/sys/kernel/printk</span></code>.</p>
<p>For instance, the command:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="m">8</span> &gt; /proc/sys/kernel/printk
</pre></div>
</div>
<p class="last">will enable all the kernel log messages to be displayed in the
console. That is, the logging level has to be strictly less than the
<code class="code docutils literal"><span class="pre">console_loglevel</span></code> variable. For example, if the
<code class="code docutils literal"><span class="pre">console_loglevel</span></code> has a value of <code class="docutils literal"><span class="pre">5</span></code> (specific to
<code class="code docutils literal"><span class="pre">KERN_NOTICE</span></code>), only messages with loglevel stricter than <code class="docutils literal"><span class="pre">5</span></code>
(i.e <code class="code docutils literal"><span class="pre">KERN_EMERG</span></code>, <code class="code docutils literal"><span class="pre">KERN_ALERT</span></code>, <code class="code docutils literal"><span class="pre">KERN_CRIT</span></code>,
<code class="code docutils literal"><span class="pre">KERN_ERR</span></code>, <code class="code docutils literal"><span class="pre">KERN_WARNING</span></code>) will be shown.</p>
</div>
<p>Console-redirected messages can be useful for quickly viewing the effect of
executing the kernel code, but they are no longer so useful if the kernel
encounters an irreparable error and the system freezes. In this case, the logs
of the system must be consulted, as they keep the information between system
restarts. These are found in <code class="file docutils literal"><span class="pre">/var/log</span></code> and are text files, populated by
<code class="code docutils literal"><span class="pre">syslogd</span></code> and <code class="code docutils literal"><span class="pre">klogd</span></code> during the kernel run. <code class="code docutils literal"><span class="pre">syslogd</span></code> and
<code class="code docutils literal"><span class="pre">klogd</span></code> take the information from the virtual file system mounted in
<code class="file docutils literal"><span class="pre">/proc</span></code>. In principle, with <code class="code docutils literal"><span class="pre">syslogd</span></code> and <code class="code docutils literal"><span class="pre">klogd</span></code> turned on,
all messages coming from the kernel will go to <code class="file docutils literal"><span class="pre">/var/log/kern.log</span></code>.</p>
<p>A simpler version for debugging is using the <code class="file docutils literal"><span class="pre">/var/log/debug</span></code> file.  It
is populated only with the <code class="code docutils literal"><span class="pre">printk</span></code> messages from the kernel with the
<code class="code docutils literal"><span class="pre">KERN_DEBUG</span></code> log level.</p>
<p>Given that a production kernel (similar to the one we're probably running with)
contains only release code, our module is among the few that send messages
prefixed with KERN_DEBUG . In this way, we can easily navigate through the
<code class="file docutils literal"><span class="pre">/var/log/debug</span></code> information by finding the messages corresponding to a
debugging session for our module.</p>
<p>Such an example would be the following:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># Clear the debug file of previous information (or possibly a backup)</span>
$ <span class="nb">echo</span> <span class="s2">&quot;New debug session&quot;</span> &gt; /var/log/debug
<span class="c1"># Run the tests</span>
<span class="c1"># If there is no critical error causing a panic kernel, check the output</span>
<span class="c1"># if a critical error occurs and the machine only responds to a restart,</span>
  restart the system and check /var/log/debug.
</pre></div>
</div>
<p>The format of the messages must obviously contain all the information of
interest in order to detect the error, but inserting in the code <code class="code docutils literal"><span class="pre">printk</span></code>
to provide detailed information can be as time-consuming as writing the code to
solve the problem. This is usually a trade-off between the completeness of the
debugging messages displayed using <code class="code docutils literal"><span class="pre">printk</span></code> and the time it takes to
insert these messages into the text.</p>
<p>A very simple way, less time-consuming for inserting <code class="code docutils literal"><span class="pre">printk</span></code> and
providing the possibility to analyze the flow of instructions for tests is the
use of the predefined constants <code class="code docutils literal"><span class="pre">__FILE__</span></code>, <code class="code docutils literal"><span class="pre">__LINE__</span></code> and
<code class="code docutils literal"><span class="pre">__func__</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">__FILE__</span></code> is replaced by the compiler with the name of the source file
it is currently being compiled.</li>
<li><code class="docutils literal"><span class="pre">__LINE__</span></code> is replaced by the compiler with the line number on which the
current instruction is found in the current source file.</li>
<li><code class="docutils literal"><span class="pre">__func__</span></code> /<code class="docutils literal"><span class="pre">__FUNCTION__</span></code> is replaced by the compiler with the name
of the function in which the current instruction is found.</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="code docutils literal"><span class="pre">__FILE__</span></code> and <code class="code docutils literal"><span class="pre">__LINE__</span></code> are part of the ANSI C specifications:
<code class="code docutils literal"><span class="pre">__func__</span></code> is part of specification C99; <code class="code docutils literal"><span class="pre">__FUNCTION__</span></code> is a GNU
<code class="code docutils literal"><span class="pre">C</span></code> extension and is not portable; However, since we write code for the
<code class="code docutils literal"><span class="pre">Linux</span></code> kernel, we can use it without any problems.</p>
</div>
<p>The following macro definition can be used in this case:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define PRINT_DEBUG \</span>
<span class="cp">       printk (KERN_DEBUG &quot;[% s]: FUNC:% s: LINE:% d \ n&quot;, __FILE__,</span>
               <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, at each point where we want to see if it is &quot;reached&quot; in execution,
insert PRINT_DEBUG; This is a simple and quick way, and can yield by carefully
analyzing the output.</p>
<p>The <strong class="command">dmesg</strong> command is used to view the messages printed with
<code class="code docutils literal"><span class="pre">printk</span></code> but not appearing on the console.</p>
<p>To delete all previous messages from a log file, run:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>cat /dev/null &gt; /var/log/debug
</pre></div>
</div>
<p>To delete messages displayed by the <strong class="command">dmesg</strong> command, run:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>dmesg -c
</pre></div>
</div>
</div>
<div class="section" id="dynamic-debugging">
<h3>Dynamic debugging<a class="headerlink" href="#dynamic-debugging" title="Permalink to this headline">¶</a></h3>
<p>Dynamic <a class="reference external" href="https://www.kernel.org/doc/html/v4.15/admin-guide/dynamic-debug-howto.html">dyndbg</a>
debugging enables dynamic debugging activation/deactivation.
Unlike <code class="code docutils literal"><span class="pre">printk</span></code>, it offers more advanced <code class="code docutils literal"><span class="pre">printk</span></code> options for the
messages we want to display; it is very useful for complex modules or
troubleshooting subsystems.
This significantly reduces the amount of messages displayed, leaving only
those relevant for the debug context. To enable <code class="docutils literal"><span class="pre">dyndbg</span></code>, the kernel must be
compiled with the <code class="docutils literal"><span class="pre">CONFIG_DYNAMIC_DEBUG</span></code> option. Once configured,
<code class="code docutils literal"><span class="pre">pr_debug()</span></code>, <code class="code docutils literal"><span class="pre">dev_dbg()</span></code> and <code class="code docutils literal"><span class="pre">print_hex_dump_debug()</span></code>,
<code class="code docutils literal"><span class="pre">print_hex_dump_bytes()</span></code> can be dynamically enabled per call.</p>
<p>The <code class="file docutils literal"><span class="pre">/sys/kernel/debug/dynamic_debug/control</span></code> file from the debugfs (where
<code class="file docutils literal"><span class="pre">/sys/kernel/debug</span></code> is the path to which debugfs was mounted) is used to
filter messages or to view existing filters.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">-</span><span class="n">t</span> <span class="n">debugfs</span> <span class="n">none</span> <span class="o">/</span><span class="n">debug</span>
</pre></div>
</div>
<p><a class="reference external" href="http://opensourceforu.com/2010/10/debugging-linux-kernel-with-debugfs/">Debugfs</a>
is a simple file system, used as a kernel-space interface and
user-space interface to configure different debug options. Any debug utility
can create and use its own files /folders in debugfs.</p>
<p>For example, to display existing filters in <code class="docutils literal"><span class="pre">dyndbg</span></code>, you will use:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>cat /debug/dynamic_debug/control
</pre></div>
</div>
<p>And to enable the debug message from line <code class="docutils literal"><span class="pre">1603</span></code> in the <code class="file docutils literal"><span class="pre">svcsock.c</span></code> file:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line 1603 +p&#39;</span> &gt; /debug/dynamic_debug/control
</pre></div>
</div>
<p>The <code class="file docutils literal"><span class="pre">/debug/dynamic_debug/control</span></code> file is not a regular file. It shows
the <code class="docutils literal"><span class="pre">dyndbg</span></code> settings on the filters. Writing in it with an echo will change
these settings (it will not actually make a write). Be aware that the file
contains settings for <code class="docutils literal"><span class="pre">dyndbg</span></code> debugging messages. Do not log in this file.</p>
<div class="section" id="dyndbg-options">
<h4>Dyndbg Options<a class="headerlink" href="#dyndbg-options" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">func</span></code> - just the debug messages from the functions that have the same
name as the one defined in the filter.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s1">&#39;func svc_tcp_accept +p&#39;</span> &gt; /debug/dynamic_debug/control
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">file</span></code> - the name of the file(s) for which we want to display the debug
messages. It can be just the source name, but also the absolute path or
kernel-tree path.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>file svcsock.c
file kernel/freezer.c
file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">module</span></code> - module name.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>module sunrpc
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">format</span></code> - only messages whose display format contains the specified string.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>format <span class="s2">&quot;nfsd: SETATTR&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">line</span></code> - the line or lines for which we want to enable debug calls.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># Triggers debug messages between lines 1603 and 1605 in the svcsock.c file</span>
$ <span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line 1603-1605 +p&#39;</span> &gt; /sys/kernel/debug/dynamic_debug/control
<span class="c1"># Enables debug messages from the beginning of the file to line 1605</span>
$ <span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line -1605 +p&#39;</span> &gt; /sys/kernel/debug/dynamic_debug/control
</pre></div>
</div>
</li>
</ul>
<p>In addition to the above options, a series of flags can be added, removed, or set
with operators <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">-</span></code> or <code class="docutils literal"><span class="pre">=</span></code>:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">p</span></code> activates the pr_debug() .</li>
<li><code class="docutils literal"><span class="pre">f</span></code> includes the name of the function in the printed message.</li>
<li><code class="docutils literal"><span class="pre">l</span></code> includes the line number in the printed message.</li>
<li><code class="docutils literal"><span class="pre">m</span></code> includes the module name in the printed message.</li>
<li><code class="docutils literal"><span class="pre">t</span></code> includes the thread id if it is not called from interrupt context</li>
<li><code class="docutils literal"><span class="pre">_</span></code> no flag is set.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="kdb-kernel-debugger">
<h3>KDB: Kernel debugger<a class="headerlink" href="#kdb-kernel-debugger" title="Permalink to this headline">¶</a></h3>
<p>The kernel debugger has proven to be very useful to facilitate the development and
debugging process. One of its main advantages is the possibility to perform live debugging.
This allows us to monitor, in real time, the accesses to memory or even modify the memory
while debugging.
The debugger has been integrated in the mainline kernel starting with version 2.6.26-rci.
KDB is not a <em>source debugger</em>, but for a complete analysis it can be used in parallel with
gdb and symbol files -- see <a class="reference internal" href="#gdb-intro"><span class="std std-ref">the GDB debugging section</span></a></p>
<p>To use KDB, you have the following options:</p>
<blockquote>
<div><ul class="simple">
<li>non-usb keyboard + VGA text console</li>
<li>serial port console</li>
<li>USB EHCI debug port</li>
</ul>
</div></blockquote>
<p>For the lab, we will use a serial interface connected to the host.
The following command will activate GDB over the serial port:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc
</pre></div>
</div>
<p>KDB is a <em>stop mode debugger</em>, which means that, while it is active, all the other processes
are stopped. The kernel can be <em>forced</em> to enter KDB during execution using the following
<a class="reference external" href="http://en.wikipedia.org/wiki/Magic_SysRq_key">SysRq</a> command</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> g &gt; /proc/sysrq-trigger
</pre></div>
</div>
<p>or by using the key combination <code class="docutils literal"><span class="pre">Ctrl+O</span> <span class="pre">g</span></code> in a terminal connected to the serial port
(for example using <strong class="command">minicom</strong>).</p>
<p>KDB has various commands to control and define the context of the debugged system:</p>
<blockquote>
<div><ul class="simple">
<li>lsmod, ps, kill, dmesg, env, bt (backtrace)</li>
<li>dump trace logs</li>
<li>hardware breakpoints</li>
<li>modifying memory</li>
</ul>
</div></blockquote>
<p>For a better description of the available commands you can use the <code class="docutils literal"><span class="pre">help</span></code> command in
the KDB shell.
In the next example, you can notice a simple KDB usage example which sets a hardware
breakpoint to monitor the changes of the <code class="docutils literal"><span class="pre">mVar</span></code> variable.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># trigger KDB</span>
<span class="nb">echo</span> g &gt; /proc/sysrq-trigger
<span class="c1"># or if we are connected to the serial port issue</span>
Ctrl-O g
<span class="c1"># breakpoint on write access to the mVar variable</span>
kdb&gt; bph mVar dataw
<span class="c1"># return from KDB</span>
kdb&gt; go
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want to learn how to easily browse through the Linux source code
and how to debug kernel code, read the <a class="reference external" href="#good-to-know">Good to know</a>
section.</p>
</div>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="section" id="remarks">
<h3>Remarks<a class="headerlink" href="#remarks" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Usually, the steps used to develop a kernel module are the
following:<ul>
<li>editing the module source code (on the physical machine);</li>
<li>module compilation (on the physical machine);</li>
<li>generation of the minimal image for the virtual machine;
this image contains the kernel, your module, busybox and
eventually test programs;</li>
<li>starting the virtual machine using QEMU;</li>
<li>running the tests in the virtual machine.</li>
</ul>
</li>
<li>When using cscope, use <code class="file docutils literal"><span class="pre">~/src/linux</span></code>.
If there is no <code class="file docutils literal"><span class="pre">cscope.out</span></code> file, you can generate it using
the command <strong class="command">make ARCH=x86 cscope</strong>.</li>
<li>You can find more details about the virtual machine at
<a class="reference internal" href="../info/vm.html#vm-link"><span class="std std-ref">虚拟机设置</span></a>.</li>
</ul>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">Before solving an exercice, <strong>carefully</strong> read all its bullets.</p>
</div>
<div class="admonition important" id="exercises-summary">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is kernel_modules. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/kernel_modules/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
</div>
<div class="section" id="booting-the-virtual-machine">
<h3>Booting the virtual machine<a class="headerlink" href="#booting-the-virtual-machine" title="Permalink to this headline">¶</a></h3>
<p>A summary of the virtual machine infrastructure:</p>
<ul class="simple">
<li><code class="file docutils literal"><span class="pre">~/src/linux</span></code> - Linux kernel sources, needed to
compile modules. The directory contains the file <code class="file docutils literal"><span class="pre">cscope.out</span></code>,
used for navigation in the source tree.</li>
<li><code class="file docutils literal"><span class="pre">~/src/linux/tools/labs/qemu</span></code>- scripts and auxiliary
files used to generate and run the QEMU VM.</li>
</ul>
<p>To start the VM, run <strong class="command">make boot</strong> in the directory <code class="file docutils literal"><span class="pre">~/src/linux/tools/labs</span></code>:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>student@eg106:~$ <span class="nb">cd</span> ~/src/linux/tools/labs
student@eg106:~/src/linux/tools/labs$ make boot
</pre></div>
</div>
<p>By default, you will not get a prompt or any graphical interface, but you can connect to
a console exposed by the virtual machine using <strong class="command">minicom</strong> or <strong class="command">screen</strong>.</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>student@eg106:~/src/linux/tools/labs$ minicom -D serial.pts

&lt;press enter&gt;

qemux86 login:
Poky <span class="o">(</span>Yocto Project Reference Distro<span class="o">)</span> <span class="m">2</span>.3 qemux86 /dev/hvc0
</pre></div>
</div>
<p>Alternatively, you can start the virtual machine with graphical interface support, using
the <strong class="command">QEMU_DISPLAY=gtk make boot</strong>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To access the virtual machine, at the login prompt, enter the
username <code class="code docutils literal"><span class="pre">root</span></code>; there is no need to enter a password.
The virtual machine will start with the permissions of the
root account.</p>
</div>
</div>
<div class="section" id="kernel-module">
<h3>1. Kernel module<a class="headerlink" href="#kernel-module" title="Permalink to this headline">¶</a></h3>
<p>To work with the kernel modules, we will follow the steps described
<a class="reference internal" href="#exercises-summary"><span class="std std-ref">above</span></a>.</p>
<p>Generate the skeleton for the task named <strong>1-2-test-mod</strong> then build and
copy the module to the VM, by running the following commands in
<code class="file docutils literal"><span class="pre">tools/labs</span></code>.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nv">LABS</span><span class="o">=</span>kernel_modules make skels
$ make build
$ make copy
</pre></div>
</div>
<p>These commands will build and copy all the modules in the current
lab skeleton.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Until after solving exercise 3, you will get a compilation error for
<code class="docutils literal"><span class="pre">3-error-mod</span></code>. To avoid this issue, remove the directory
<code class="file docutils literal"><span class="pre">skels/kernel_modules/3-error-mod/</span></code> and remove the corresponding
line from <code class="docutils literal"><span class="pre">skels/Kbuild</span></code>.</p>
</div>
<p>Start the VM using <strong class="command">make boot</strong>, connect to the serial console
using <cite>minicom -D serial.pts</cite> and perform the following tasks:</p>
<ul class="simple">
<li>load the kernel module.</li>
<li>list the kernel modules and check if current module is present</li>
<li>unload the kernel module</li>
<li>view the messages displayed at loading/unloading the kernel module using
<strong class="command">dmesg</strong> command</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Read <a class="reference internal" href="#loading-unloading-a-kernel-module">Loading/unloading a kernel module</a> section. When unloading
a kernel module, you can specify only the module name
(without extension).</p>
</div>
</div>
<div class="section" id="printk">
<h3>2. Printk<a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p>Watch the virtual machine console. Why were the messages displayed directly
to the virtual machine console?</p>
<p>Configure the system such that the messages are not displayed directly
on the serial console, and they can only be inspected using <code class="docutils literal"><span class="pre">dmesg</span></code>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">One option is to set the console log level by writting
the desired level to <code class="docutils literal"><span class="pre">/proc/sys/kernel/printk</span></code>.
Use a value smaller than the level used for the prints in
the source code of the module.</p>
</div>
<p>Load/unload the module again.
The messages should not be printed to the virtual machine console,
but they should be visible when running <code class="docutils literal"><span class="pre">dmesg</span></code>.</p>
</div>
<div class="section" id="error">
<h3>3. Error<a class="headerlink" href="#error" title="Permalink to this headline">¶</a></h3>
<p>Generate the skeleton for the task named <strong>3-error-mod</strong>. Compile the
sources and get the corresponding kernel module.</p>
<p>Why have compilation
errors occurred? <strong>Hint:</strong> How does this module differ from the previous module?</p>
<p>Modify the module to solve the cause of those errors, then compile and test
the module.</p>
</div>
<div class="section" id="sub-modules">
<h3>4. Sub-modules<a class="headerlink" href="#sub-modules" title="Permalink to this headline">¶</a></h3>
<p>Inspect the C source files <code class="docutils literal"><span class="pre">mod1.c</span></code> and <code class="docutils literal"><span class="pre">mod2.c</span></code> in <code class="file docutils literal"><span class="pre">4-multi-mod/</span></code>.
Module 2 contains only the definition of a function used by module 1.</p>
<p>Change the <code class="file docutils literal"><span class="pre">Kbuild</span></code> file to create the <code class="docutils literal"><span class="pre">multi_mod.ko</span></code> module from the
two C source files.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Read the <a class="reference internal" href="#compiling-kernel-modules">Compiling kernel modules</a> section of the lab.</p>
</div>
<p>Compile, copy, boot the VM, load and unload the kernel module. Make sure messages
are properly displayed on the console.</p>
</div>
<div class="section" id="kernel-oops-1">
<h3>5. Kernel oops<a class="headerlink" href="#kernel-oops-1" title="Permalink to this headline">¶</a></h3>
<p>Enter the directory for the task <strong>5-oops-mod</strong> and inspect the
C source file. Notice where the problem will occur. Add the compilation flag
<code class="docutils literal"><span class="pre">-g</span></code> in the Kbuild file.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Read <a class="reference internal" href="#compiling-kernel-modules">Compiling kernel modules</a>  section of the lab.</p>
</div>
<p>Compile the corresponding module and load it into the kernel. Identify the memory
address at which the oops appeared.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Read <a href="#system-message-1"><span class="problematic" id="problematic-1">`Debugging`_</span></a> section of the lab.  To identify the
address, follow the oops message and extract the value of
the instructions pointer (<code class="docutils literal"><span class="pre">EIP</span></code>) register.</p>
</div>
<p>Determine which instruction has triggered the oops.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use the <code class="file docutils literal"><span class="pre">proc/modules</span></code> information to get the load address of
the kernel module.  Use, on the physical machine, objdump
and/or addr2line . Objdump needs debugging support for
compilation!  Read the lab's <a class="reference internal" href="#objdump">objdump</a> and <a class="reference internal" href="#addr2line">addr2line</a>
sections.</p>
</div>
<p>Try to unload the kernel module. Notice that the operation does not
work because there are references from the kernel module within the
kernel since the oops; Until the release of those references (which is
almost impossible in the case of an oops), the module can not be
unloaded.</p>
</div>
<div class="section" id="module-parameters">
<h3>6. Module parameters<a class="headerlink" href="#module-parameters" title="Permalink to this headline">¶</a></h3>
<p>Enter the directory for the task <strong>6-cmd-mod</strong> and inspect the C
<code class="docutils literal"><span class="pre">cmd_mod.c</span></code> source file. Compile and copy the associated module and
load the kernel module to see the printk message. Then unload the
module from the kernel.</p>
<p>Without modifying the sources, load the kernel module so that the
message shown is <code class="docutils literal"><span class="pre">Early</span> <span class="pre">bird</span> <span class="pre">gets</span> <span class="pre">tired</span></code>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The str variable can be changed by passing a parameter to
the module. Find more information <a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x323.html">here</a>.</p>
</div>
<span class="target" id="proc-info"></span></div>
<div class="section" id="proc-info-1">
<h3>7. Proc info<a class="headerlink" href="#proc-info-1" title="Permalink to this headline">¶</a></h3>
<p>Check the skeleton for the task named <strong>7-list-proc</strong>. Add code to
display the Process ID (<code class="docutils literal"><span class="pre">PID</span></code>) and the executable name for the current
process.</p>
<p>Follow the commands marked with <code class="docutils literal"><span class="pre">TODO</span></code>.
The information must be displayed both when loading and unloading the
module.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>In the Linux kernel, a process is described by the
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>.  Use <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> or <code class="docutils literal"><span class="pre">cscope</span></code> to find the
definition of <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>.</li>
<li>To find the structure field that contains the name of the
executable, look for the &quot;executable&quot; comment.</li>
<li>The pointer to the structure of the current process
running at a given time in the kernel is given by the
<code class="xref c c-macro docutils literal"><span class="pre">current</span></code> variable (of the type
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct*</span></code>).</li>
</ul>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">To use <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> you'll need to include the header
in which the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> is defined, i.e
<code class="docutils literal"><span class="pre">linux/sched.h</span></code>.</p>
</div>
<p>Compile, copy, boot the VM and load the module. Unload the kernel module.</p>
<p>Repeat the loading/unloading operation. Note that the PIDs of the
displayed processes differ. This is because a process is created
from the executable <code class="file docutils literal"><span class="pre">/sbin/insmod</span></code> when the module is loaded and
when the module is unloaded a process is created from the executable
<code class="file docutils literal"><span class="pre">/sbin/rmmod</span></code>.</p>
</div>
</div>
<div class="section" id="good-to-know-1">
<span id="good-to-know"></span><h2>Good to know<a class="headerlink" href="#good-to-know-1" title="Permalink to this headline">¶</a></h2>
<p>The following sections contain useful information for getitng used to the Linux
kernel code and debugging techniques.</p>
</div>
<div class="section" id="source-code-navigation">
<h2>Source code navigation<a class="headerlink" href="#source-code-navigation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cscope">
<span id="cscope-intro"></span><h3>cscope<a class="headerlink" href="#cscope" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://cscope.sourceforge.net/">Cscope</a> is a tool for
efficient navigation of C sources. To use it, a cscope database must
be generated from the existing sources. In a Linux tree, the command
<strong class="command">make ARCH=x86 cscope</strong> is sufficient. Specification of the
architecture through the ARCH variable is optional but recommended;
otherwise, some architecture dependent functions will appear multiple
times in the database.</p>
<p>You can build the cscope database with the command <strong class="command">make
ARCH=x86 COMPILED_SOURCE=1 cscope</strong>. This way, the cscope database will
only contain symbols that have already been used in the compile
process before, thus resulting in better performance when searching
for symbols.</p>
<p>Cscope can also be used as stand-alone, but it is more useful when
combined with an editor. To use cscope with <strong class="command">vim</strong>, it is necessary to
install both packages and add the following lines to the file
<code class="file docutils literal"><span class="pre">.vimrc</span></code> (the machine in the lab already has the settings):</p>
<div class="highlight-vim"><div class="highlight"><pre><span></span><span class="k">if</span> has<span class="p">(</span><span class="s2">&quot;cscope&quot;</span><span class="p">)</span>
<span class="c">        &quot; Look for a &#39;cscope.out&#39; file starting from the current directory,</span>
<span class="c">        &quot; going up to the root directory.</span>
        <span class="k">let</span> s:dirs <span class="p">=</span> split<span class="p">(</span>getcwd<span class="p">(),</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="k">while</span> s:dirs <span class="p">!=</span> []
                <span class="k">let</span> s:<span class="nb">path</span> <span class="p">=</span> <span class="s2">&quot;/&quot;</span> . <span class="k">join</span><span class="p">(</span>s:dirs<span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>filereadable<span class="p">(</span>s:<span class="nb">path</span> . <span class="s2">&quot;/cscope.out&quot;</span><span class="p">))</span>
                        execute <span class="s2">&quot;cs add &quot;</span> . s:<span class="nb">path</span> . <span class="s2">&quot;/cscope.out &quot;</span> . s:<span class="nb">path</span> . <span class="s2">&quot; -v&quot;</span>
                        <span class="k">break</span>
                <span class="k">endif</span>
                <span class="k">let</span> s:dirs <span class="p">=</span> s:dirs[:<span class="m">-2</span>]
        <span class="k">endwhile</span>

        <span class="k">set</span> <span class="nb">csto</span><span class="p">=</span><span class="m">0</span>  <span class="c">&quot; Use cscope first, then ctags</span>
        <span class="k">set</span> <span class="nb">cst</span>     <span class="c">&quot; Only search cscope</span>
        <span class="k">set</span> <span class="nb">csverb</span>  <span class="c">&quot; Make cs verbose</span>

        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`s :<span class="k">cs</span> find s `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">g</span> :<span class="k">cs</span> find <span class="k">g</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">c</span> :<span class="k">cs</span> find <span class="k">c</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">t</span> :<span class="k">cs</span> find <span class="k">t</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">e</span> :<span class="k">cs</span> find <span class="k">e</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">f</span> :<span class="k">cs</span> find <span class="k">f</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cfile&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">i</span> :<span class="k">cs</span> find <span class="k">i</span> ^`<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cfile&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>`$`<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">d</span> :<span class="k">cs</span> find <span class="k">d</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap <span class="p">&lt;</span>F6<span class="p">&gt;</span> :cnext <span class="p">&lt;</span>CR<span class="p">&gt;</span>
        nmap <span class="p">&lt;</span>F5<span class="p">&gt;</span> :cprev <span class="p">&lt;</span>CR<span class="p">&gt;</span>

<span class="c">        &quot; Open a quickfix window for the following queries.</span>
        <span class="k">set</span> <span class="nb">cscopequickfix</span><span class="p">=</span>s<span class="p">-,</span><span class="k">c</span><span class="p">-,</span><span class="k">d</span><span class="p">-,</span><span class="k">i</span><span class="p">-,</span><span class="k">t</span><span class="p">-,</span><span class="k">e</span><span class="p">-,</span><span class="k">g</span><span class="p">-</span>
<span class="k">endif</span>
</pre></div>
</div>
<p>The script searches for a file called <code class="file docutils literal"><span class="pre">cscope.out</span></code> in the current directory, or
in parent directories. If <strong class="command">vim</strong> finds this file, you can use the shortcut <code class="code docutils literal"><span class="pre">Ctrl</span> <span class="pre">+]</span></code>
or <code class="code docutils literal"><span class="pre">Ctrl+\</span> <span class="pre">g</span></code> (the combination control-\ followed by g) to jump directly to
the definition of the word under the cursor (function, variable, structure, etc.).
Similarly, you can use <code class="code docutils literal"><span class="pre">Ctrl+\</span> <span class="pre">s</span></code> to go where the word under the cursor is used.</p>
<p>You can take a cscope-enabled <code class="file docutils literal"><span class="pre">.vimrc</span></code> file (also contains other goodies) from
<a class="reference external" href="https://github.com/ddvlad/cfg/blob/master/_vimrc">https://github.com/ddvlad/cfg/blob/master/_vimrc</a>.
The following guidelines are based on this file, but also show basic <strong class="command">vim</strong> commands
that have the same effect.</p>
<p>If there are more than one results (usually there are) you can move between them
using <code class="code docutils literal"><span class="pre">F6</span></code> and <code class="code docutils literal"><span class="pre">F5</span></code> (<code class="code docutils literal"><span class="pre">:ccnext</span></code>  and <code class="code docutils literal"><span class="pre">:cprev</span></code>).
You can also open a new panel showing the results using <code class="code docutils literal"><span class="pre">:copen</span></code>. To close
the panel, use the <code class="code docutils literal"><span class="pre">:cclose</span></code> command.</p>
<p>To return to the previous location, use <code class="code docutils literal"><span class="pre">Ctrl+o</span></code> (o, not zero).
The command can be used multiple times and works even if cscope changed the
file you are currently editing.</p>
<p>To go to a symbol definition directly when <strong class="command">vim</strong> starts, use <code class="code docutils literal"><span class="pre">vim</span> <span class="pre">-t</span> <span class="pre">&lt;symbol_name&gt;</span></code>
(for example <code class="code docutils literal"><span class="pre">vim</span> <span class="pre">-t</span> <span class="pre">task_struct</span></code>). Otherwise, if you started <strong class="command">vim</strong> and want
to search for a symbol by name, use <code class="code docutils literal"><span class="pre">cs</span> <span class="pre">find</span> <span class="pre">g</span> <span class="pre">&lt;symbol_name&gt;</span></code> (for example
<code class="code docutils literal"><span class="pre">cs</span> <span class="pre">find</span> <span class="pre">g</span> <span class="pre">task_struct</span></code>).</p>
<p>If you found more than one results and opened a panel showing all the matches
(using <code class="code docutils literal"><span class="pre">:copen</span></code>) and you want to find a symbol of type structure,
it is recommended to search in the results panel (using <code class="code docutils literal"><span class="pre">/</span></code> -- slash)
the character <code class="code docutils literal"><span class="pre">{</span></code> (opening brace).</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>You can get a summary of all the <strong class="command">cscope</strong> commands using <strong class="command">:cs help</strong>.</p>
<p class="last">For more info, use the <strong class="command">vim</strong> built-in help command: <strong class="command">:h cscope</strong> or <strong class="command">:h copen</strong>.</p>
</div>
<p>If you use <strong class="command">emacs</strong>, install the <code class="code docutils literal"><span class="pre">xcscope-el</span></code> package and
add the following lines in <code class="file docutils literal"><span class="pre">~/.emacs</span></code>.</p>
<div class="highlight-vim"><div class="highlight"><pre><span></span><span class="p">(</span>require ‘xcscope<span class="p">)</span>
<span class="p">(</span><span class="k">cscope</span><span class="p">-</span>setup<span class="p">)</span>
</pre></div>
</div>
<p>These commands will activate cscope for the C and C++ modes automatically.
<code class="code docutils literal"><span class="pre">C-s</span> <span class="pre">s</span></code> is the key bindings prefix and <code class="code docutils literal"><span class="pre">C-s</span> <span class="pre">s</span> <span class="pre">s</span></code> is used to
search for a symbol (if you call it when the cursor is over a word,
it will use that). For more details, check <cite>https://github.com/dkogan/xcscope.el</cite></p>
</div>
<div class="section" id="clangd">
<h3>clangd<a class="headerlink" href="#clangd" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://clangd.llvm.org/">Clangd</a> is a language server that provides tools
for navigating C and C++ code.
<a class="reference external" href="https://microsoft.github.io/language-server-protocol/">Language Server Protocol</a>
facilitates features like go-to-definition, find-references, hover, completion, etc.,
using semantic whole project analysis.</p>
<p>Clangd requires a compilation database to understand the kernel source code.
It can be generated with:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>make defconfig
make
scripts/clang-tools/gen_compile_commands.py
</pre></div>
</div>
<p>LSP clients:</p>
<ul class="simple">
<li>Vim/Neovim (<a class="reference external" href="https://github.com/neoclide/coc.nvim">coc.nvim</a>, <a class="reference external" href="https://github.com/neovim/nvim-lspconfig">nvim-lsp</a>, <a class="reference external" href="https://github.com/natebosch/vim-lsc">vim-lsc</a>, <a class="reference external" href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a>)</li>
<li>Emacs (<a class="reference external" href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a>)</li>
<li>VSCode (<a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd extension</a>)</li>
</ul>
</div>
<div class="section" id="kscope">
<h3>Kscope<a class="headerlink" href="#kscope" title="Permalink to this headline">¶</a></h3>
<p>For a simpler interface, <a class="reference external" href="http://sourceforge.net/projects/kscope/">Kscope</a>
is a cscope frontend which uses QT. It is lightweight, very fast and very
easy to use. It allows searching using regular expressions, call graphs, etc.
Kscope is no longer mantained.</p>
<p>There is also a <a class="reference external" href="https///opendesktop.org/content/show.php/Kscope4?content=156987">port</a>
of version 1.6 for Qt4 and KDE 4 which keeps the integration of the text
editor Kate and is easier to use than the last version on SourceForge.</p>
</div>
<div class="section" id="lxr-cross-reference">
<h3>LXR Cross-Reference<a class="headerlink" href="#lxr-cross-reference" title="Permalink to this headline">¶</a></h3>
<p>LXR (LXR Cross-Reference) is a tool that allows indexing and
referencing the symbols in the source code of a program using
a web interface. The web interface shows links to
locations in files where a symbol is defined or used. Development website
for LXR is <a class="reference external" href="http://sourceforge.net/projects/lxr">http://sourceforge.net/projects/lxr</a>. Similar tools
are <a class="reference external" href="http://oracle.github.io/opengrok/">OpenGrok</a> and
<a class="reference external" href="http://en.wikipedia.org/wiki/Gonzui">Gonzui</a>.</p>
<p>Although LXR was originally intended for the Linux kernel sources, it is
also used in the sources of <a class="reference external" href="http://lxr.mozilla.org/">Mozilla</a>,
<a class="reference external" href="http://apache.wirebrain.de/lxr/">Apache HTTP Server</a> and
<a class="reference external" href="http://lxr.linux.no/freebsd/source">FreeBSD</a>.</p>
<p>There are a number of sites that use LXR for cross-referencing the
the sources of the Linux kernel, the main site being <a class="reference external" href="http://lxr.linux.no/linux/">the original site of
development</a> which does not work anymore. You can
use <a class="reference external" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a>.</p>
<p>LXR allows searching for an identifier (symbol), after a free text
or after a file name. The main feature and, at the same
time, the main advantage provided is the ease of finding the declaration
of any global identifier. This way, it facilitates quick access to function
declarations, variables, macro definitions and the code can be easily
navigated. Also, the fact that it can detect what code areas are affected
when a variable or function is changed is a real advantage in the development
and debugging phase.</p>
</div>
<div class="section" id="sourceweb">
<h3>SourceWeb<a class="headerlink" href="#sourceweb" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://rprichard.github.io/sourceweb/">SourceWeb</a> is a source code indexer
for C and C++. It uses the
<a class="reference external" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">framework</a>
provided by the Clang compiler to index the code.</p>
<p>The main difference between cscope and SourceWeb is the fact that SourceWeb
is, in a way, a compiler pass. SourceWeb doesn't index all the code, but
only the code that was efectively compiled by the compiler. This way, some
problems are eliminated, such as ambiguities about which variant of a function
defined in multiple places is used. This also means that the indexing takes
more time, because the compiled files must pass one more time through
the indexer to generate the references.</p>
<p>Usage example:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>make oldconfig
sw-btrace make -j4
sw-btrace-to-compile-db
sw-clang-indexer --index-project
sourceweb index
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">sw-btrace</span></code> is a script that adds the <code class="file docutils literal"><span class="pre">libsw-btrace.so</span></code>
library to <code class="code docutils literal"><span class="pre">LD_PRELOAD</span></code>. This way, the library is loaded by
every process started by <code class="code docutils literal"><span class="pre">make</span></code> (basically, the compiler),
registers the commands used to start the processes and generates
a filed called <code class="file docutils literal"><span class="pre">btrace.log</span></code>. This file is then used by
<code class="code docutils literal"><span class="pre">sw-btrace-to-compile-db</span></code> which converts it to a format defined
by clang: <a class="reference external" href="http://clang.llvm.org/docs/JSONCompilationDatabase.html">JSON Compilation Database</a>.
This JSON Compilation Database resulted from the above steps is then
used by the indexer, which makes one more pass through the compiled
source files and generates the index used by the GUI.</p>
<p>Word of advice: don't index the sources you are working with, but use
a copy, because SourceWeb doesn't have, at this moment, the capability
to regenerate the index for a single file and you will have to regenerate
the complete index.</p>
</div>
</div>
<div class="section" id="kernel-debugging">
<h2>Kernel Debugging<a class="headerlink" href="#kernel-debugging" title="Permalink to this headline">¶</a></h2>
<p>Debugging a kernel is a much more difficult process than the debugging
of a program, because there is no support from the operating system.
This is why this process is usually done using two computers, connected
on serial interfaces.</p>
<div class="section" id="gdb-linux">
<span id="gdb-intro"></span><h3>gdb (Linux)<a class="headerlink" href="#gdb-linux" title="Permalink to this headline">¶</a></h3>
<p>A simpler debug method on Linux, but with many disadvantages,
is local debugging, using <a class="reference external" href="http://www.gnu.org/software/gdb/">gdb</a>,
the uncompressed kernel image (<code class="file docutils literal"><span class="pre">vmlinux</span></code>) and <code class="file docutils literal"><span class="pre">/proc/kcore</span></code>
(the real-time kernel image). This method is usually used to inspect
the kernel and detect certain inconsistencies while it runs. The
method is useful especially if the kernel was compiled using the
<code class="code docutils literal"><span class="pre">-g</span></code> option, which keeps debug information. Some well-known
debug techniques can't be used by this method, such as breakpoints
of data modification.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Because <code class="file docutils literal"><span class="pre">/proc</span></code> is a virtual filesystem, <code class="file docutils literal"><span class="pre">/proc/kcore</span></code>
does not physically exist on the disk. It is generated on-the-fly
by the kernel when a program tries to access <code class="file docutils literal"><span class="pre">proc/kcore</span></code>.</p>
<p>It is used for debugging purposes.</p>
<p>From <strong class="command">man proc</strong>, we have:</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>/proc/kcore
This file represents the physical memory of the system and is stored in the ELF core file format.  With this pseudo-file, and
an unstripped kernel (/usr/src/linux/vmlinux) binary, GDB can be used to examine the current state of any kernel data struc‐
tures.
</pre></div>
</div>
</div>
<p>The uncompressed kernel image offers information about the data structures
and symbols it contains.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ <span class="nb">cd</span> ~/src/linux
student@eg106$ file vmlinux
vmlinux: ELF <span class="m">32</span>-bit LSB executable, Intel <span class="m">80386</span>, ...
student@eg106$ nm vmlinux <span class="p">|</span> grep sys_call_table
c02e535c R sys_call_table
student@eg106$ cat System.map <span class="p">|</span> grep sys_call_table
c02e535c R sys_call_table
</pre></div>
</div>
<p>The <strong class="command">nm</strong> utility is used to show the symbols in an object or
executable file. In our case, <code class="file docutils literal"><span class="pre">vmlinux</span></code> is an ELF file. Alternately,
we can use the file <code class="file docutils literal"><span class="pre">System.map</span></code> to view information about the
symbols in kernel.</p>
<p>Then we use <strong class="command">gdb</strong> to inspect the symbols using the uncompressed
kernel image. A simple <strong class="command">gdb</strong> session is the following:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ <span class="nb">cd</span> ~/src/linux
stduent@eg106$ gdb --quiet vmlinux
Using host libthread_db library <span class="s2">&quot;/lib/tls/libthread_db.so.1&quot;</span>.
<span class="o">(</span>gdb<span class="o">)</span> x/x 0xc02e535c
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58
<span class="o">(</span>gdb<span class="o">)</span> x/16 0xc02e535c
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sb">`</span>&lt;sys_call_table+16&gt;<span class="sb">`</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sb">`</span>&lt;sys_call_table+32&gt;<span class="sb">`</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sb">`</span>&lt;sys_call_table+48&gt;<span class="sb">`</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="o">(</span>gdb<span class="o">)</span> x/x sys_call_table
0xc011bc58 <span class="sb">`</span>&lt;sys_restart_syscall&gt;<span class="sb">`</span>:       0xffe000ba
<span class="o">(</span>gdb<span class="o">)</span> x/x <span class="p">&amp;</span>sys_call_table
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58
<span class="o">(</span>gdb<span class="o">)</span> x/16 <span class="p">&amp;</span>sys_call_table
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sb">`</span>&lt;sys_call_table+16&gt;<span class="sb">`</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sb">`</span>&lt;sys_call_table+32&gt;<span class="sb">`</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sb">`</span>&lt;sys_call_table+48&gt;<span class="sb">`</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="o">(</span>gdb<span class="o">)</span> x/x sys_fork
0xc01013d3 <span class="sb">`</span>&lt;sys_fork&gt;<span class="sb">`</span>:  0x3824548b
<span class="o">(</span>gdb<span class="o">)</span> disass sys_fork
Dump of assembler code <span class="k">for</span> <span class="k">function</span> sys_fork:
0xc01013d3 <span class="sb">`</span>&lt;sys_fork+0&gt;<span class="sb">`</span>:        mov    0x38<span class="o">(</span>%esp<span class="o">)</span>,%edx
0xc01013d7 <span class="sb">`</span>&lt;sys_fork+4&gt;<span class="sb">`</span>:        mov    <span class="nv">$0</span>x11,%eax
0xc01013dc <span class="sb">`</span>&lt;sys_fork+9&gt;<span class="sb">`</span>:        push   <span class="nv">$0</span>x0
0xc01013de <span class="sb">`</span>&lt;sys_fork+11&gt;<span class="sb">`</span>:       push   <span class="nv">$0</span>x0
0xc01013e0 <span class="sb">`</span>&lt;sys_fork+13&gt;<span class="sb">`</span>:       push   <span class="nv">$0</span>x0
0xc01013e2 <span class="sb">`</span>&lt;sys_fork+15&gt;<span class="sb">`</span>:       lea    0x10<span class="o">(</span>%esp<span class="o">)</span>,%ecx
0xc01013e6 <span class="sb">`</span>&lt;sys_fork+19&gt;<span class="sb">`</span>:       call   0xc0111aab <span class="sb">`</span>&lt;do_fork&gt;<span class="sb">`</span>
0xc01013eb <span class="sb">`</span>&lt;sys_fork+24&gt;<span class="sb">`</span>:       add    <span class="nv">$0</span>xc,%esp
0xc01013ee <span class="sb">`</span>&lt;sys_fork+27&gt;<span class="sb">`</span>:       ret
End of assembler dump.
</pre></div>
</div>
<p>It can be noticed that the uncompressed kernel image was used as an argument
for <strong class="command">gdb</strong>. The image can be found in the root of the kernel sources
after compilation.</p>
<p>A few commands used for debugging using <strong class="command">gdb</strong> are:</p>
<ul class="simple">
<li><strong class="command">x</strong> (examine) - Used to show the contents of the memory area
whose address is specified as an argument to the command (this address
can be the value of a physical address, a symbol or the address of a
symbol). It can take as arguments (preceded by <code class="code docutils literal"><span class="pre">/</span></code>): the format
to display the data in (<code class="code docutils literal"><span class="pre">x</span></code> for hexadecimal, <code class="code docutils literal"><span class="pre">d</span></code> for
decimal, etc.), how many memory units to display and the size of a
memory unit.</li>
<li><strong class="command">disassemble</strong> - Used to disassemble a function.</li>
<li><strong class="command">p</strong> (print) - Used to evaluate and show the value of an
expression. The format to show the data in can be specified as
an argument (<code class="code docutils literal"><span class="pre">/x</span></code> for hexadecimal, <code class="code docutils literal"><span class="pre">/d</span></code> for decimal, etc.).</li>
</ul>
<p>The analysis of the kernel image is a method of static analysis. If we
want to perform dynamic analysis (analyzing how the kernel runs, not
only its static image) we can use <code class="file docutils literal"><span class="pre">/proc/kcore</span></code>; this is a dynamic
image (in memory) of the kernel.</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ gdb ~/src/linux/vmlinux /proc/kcore
Core was generated by `root=/dev/hda3 ro&#39;.
#0  0x00000000 in ?? ()
(gdb) p sys_call_table
$1 = -1072579496
(gdb) p /x sys_call_table
$2 = 0xc011bc58
(gdb) p /x &amp;sys_call_table
$3 = 0xc02e535c
(gdb) x/16 &amp;sys_call_table
0xc02e535c `&lt;sys_call_table&gt;`:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c `&lt;sys_call_table+16&gt;`: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c `&lt;sys_call_table+32&gt;`: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c `&lt;sys_call_table+48&gt;`: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
</pre></div>
</div>
<p>Using the dynamic image of the kernel is useful for detecting <a class="reference external" href="http://en.wikipedia.org/wiki/Rootkit">rootkits</a>.</p>
<ul class="simple">
<li><a class="reference external" href="http://linuxdriver.co.il/ldd3/linuxdrive3-CHP-4-SECT-6.html">Linux Device Drivers 3rd Edition - Debuggers and Related Tools</a></li>
<li><a class="reference external" href="http://www.securityfocus.com/infocus/1811">Detecting Rootkits and Kernel-level Compromises in Linux</a></li>
<li><a class="reference external" href="http://user-mode-linux.sf.net/">User-Mode Linux</a></li>
</ul>
</div>
<div class="section" id="getting-a-stack-trace">
<h3>Getting a stack trace<a class="headerlink" href="#getting-a-stack-trace" title="Permalink to this headline">¶</a></h3>
<p>Sometimes, you will want information about the trace the execution
reaches a certain point. You can determine this information using
<strong class="command">cscope</strong> or LXR, but some function are called from many
execution paths, which makes this method difficult.</p>
<p>In these situations, it is useful to get a stack trace, which can be
simply done using the function <code class="code docutils literal"><span class="pre">dump_stack()</span></code>.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lec12-virtualization.html" class="btn btn-neutral float-left" title="SO2 Lecture 12 - Virtualization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab2-kernel-api.html" class="btn btn-neutral float-right" title="SO2 Lab 02 - Kernel API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>