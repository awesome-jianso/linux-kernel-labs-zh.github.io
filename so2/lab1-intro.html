<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SO2 Lab 01 - Introduction &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="SO2 Lab 02 - Kernel API" href="lab2-kernel-api.html" />
    <link rel="prev" title="SO2 Lecture 12 - Virtualization" href="lec12-virtualization.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Operating Systems 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lec1-intro.html">SO2 课程 01 - 课程概要以及 Linux 内核介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec2-syscalls.html">SO2 Lecture 02 - System calls</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec3-processes.html">SO2 Lecture 03 - Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec4-interrupts.html">SO2 Lecture 04 - Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec5-smp.html">SO2 Lecture 05 - Symmetric Multi-Processing</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec6-address-space.html">SO2 Lecture 06 - Address Space</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec7-memory-management.html">SO2 Lecture 07 - Memory Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec8-filesystems.html">SO2 Lecture 08 - Filesystem Management</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec9-debugging.html">SO2 Lecture 09 - Kernel debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec10-networking.html">SO2 Lecture 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec11-arch.html">SO2 Lecture 11 - Architecture Layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="lec12-virtualization.html">SO2 Lecture 12 - Virtualization</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">SO2 Lab 01 - Introduction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#lab-objectives">Lab objectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-1">关于本实验</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">参考资料</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-3">文档</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-4">内核模块概述</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-5">内核模块示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-6">编译内核模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-7">加载/卸载内核模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-8">内核模块调试</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#objdump">objdump</a></li>
<li class="toctree-l4"><a class="reference internal" href="#addr2line">addr2line</a></li>
<li class="toctree-l4"><a class="reference internal" href="#minicom">minicom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#netconsole">netconsole</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printk">Printk 调试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-9">动态调试</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdb">KDB：内核调试器</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#section-10">备注</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-11">启动虚拟机</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-12">1. 内核模块</a></li>
<li class="toctree-l4"><a class="reference internal" href="#printk-1">2. Printk</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-13">3. 错误</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-14">4. 子模块</a></li>
<li class="toctree-l4"><a class="reference internal" href="#oops-1">5. 内核 oops</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-15">6. 模块参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-16">7. 进程信息</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#good-to-know-1">Good to know</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-17">源代码导航</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cscope">cscope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#clangd">clangd</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kscope">Kscope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lxr-cross-reference">LXR Cross-Reference</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sourceweb">SourceWeb</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#section-18">内核调试</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gdb-linux">gdb（Linux）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#section-19">获取堆栈跟踪</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lab2-kernel-api.html">SO2 Lab 02 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab3-device-drivers.html">SO2 Lab 03 - Character device drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab4-interrupts.html">SO2 Lab 04 - I/O access and Interrupts</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab5-deferred-work.html">SO2 Lab 05 - Deferred work</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab6-memory-mapping.html">SO2 Lab 06 - Memory Mapping</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab7-block-device-drivers.html">SO2 Lab 07 - Block Device Drivers</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab8-filesystems-part1.html">SO2 Lab 08 - File system drivers (Part 1)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab9-filesystems-part2.html">SO2 Lab 09 - File system drivers (Part 2)</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab10-networking.html">SO2 Lab 10 - Networking</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab11-arm-kernel-development.html">SO2 Lab 11 - Kernel Development on ARM</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab12-kernel-profiling.html">SO2 Lab 12 - Kernel Profiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign-collaboration.html">Collaboration</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign0-kernel-api.html">Assignment 0 - Kernel API</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign1-kprobe-based-tracer.html">Assignment 1 - Kprobe based tracer</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign2-driver-uart.html">Assignment 2 - Driver UART</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign3-software-raid.html">Assignment 3 - Software RAID</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign4-transport-protocol.html">Assignment 4 - SO2 Transport Protocol</a></li>
<li class="toctree-l2"><a class="reference internal" href="assign7-kvm-vmm.html">Assignment 7 - SO2 Virtual Machine Manager with KVM</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../labs/infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../labs/kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Operating Systems 2</a></li>
      <li class="breadcrumb-item active">SO2 Lab 01 - Introduction</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/so2/lab1-intro.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="so2-lab-01-introduction">
<h1>SO2 Lab 01 - Introduction<a class="headerlink" href="#so2-lab-01-introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="lab-objectives">
<h2>Lab objectives<a class="headerlink" href="#lab-objectives" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>presenting the rules and objectives of the Operating Systems 2 lab</li>
<li>introducing the lab documentation</li>
<li>introducing the Linux kernel and related resources</li>
<li>creating simple modules</li>
<li>describing the process of kernel module compilation</li>
<li>presenting how a module can be used with a kernel</li>
<li>simple kernel debugging methods</li>
</ul>
</div>
<div class="section" id="section-1">
<h2>关于本实验<a class="headerlink" href="#section-1" title="Permalink to this headline">¶</a></h2>
<p>操作系统 2 实验是一个内核编程和驱动程序开发实验。本实验的目标是：</p>
<ul class="simple">
<li>加深课程中介绍的概念</li>
<li>展示内核编程接口（内核 API）</li>
<li>获取在一个独立的环境中记录、开发和调试的技能</li>
<li>获取驱动程序开发的知识和技能</li>
</ul>
<p>每个实验将呈现一组特定问题的概念、应用和命令。实验将以演示开始（每个实验都会有一组幻灯片）（15分钟），其余时间将用于实验室练习（80分钟）。</p>
<p>为了获得最佳的实验效果，我们建议你阅读相关幻灯片。要完全理解一个实验，我们建议你查阅实验技术支持材料。如果需要深入学习，可以使用辅助文档。</p>
</div>
<div class="section" id="section-2">
<h2>参考资料<a class="headerlink" href="#section-2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Linux<ul>
<li><a class="reference external" href="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468/">Linux 内核开发（第 3 版）</a></li>
<li><a class="reference external" href="http://free-electrons.com/doc/books/ldd3.pdf">Linux设备驱动（第 3 版）</a></li>
<li><a class="reference external" href="http://www.amazon.com/Essential-Device-Drivers-Sreekrishnan-Venkateswaran/dp/0132396556">精通 Linux 设备驱动程序</a></li>
</ul>
</li>
<li>通用<ul>
<li><a class="reference external" href="http://cursuri.cs.pub.ro/cgi-bin/mailman/listinfo/pso">邮件列表</a>
（<a class="reference external" href="http://blog.gmane.org/gmane.education.region.romania.operating-systems-design">搜索邮件列表</a> ）</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="section-3">
<h2>文档<a class="headerlink" href="#section-3" title="Permalink to this headline">¶</a></h2>
<p>与用户空间编程相比，内核开发是一个困难的过程。内核的 API 和用户空间不同，内核子系统的复杂性也更高，因此需要额外的准备工作。相关的文档比较零散，有时候需要查阅多个来源才能对某个方面有较全面的了解。</p>
<p>Linux 内核的主要优势是可以访问源代码和其开放式开发系统。因此，互联网上提供了大量的内核文档。</p>
<p>以下是与 Linux 内核相关的一些链接：</p>
<ul class="simple">
<li><a class="reference external" href="http://kernelnewbies.org">KernelNewbies</a></li>
<li><a class="reference external" href="http://kernelnewbies.org/KernelHacking">KernelNewbies——内核编程</a></li>
<li><a class="reference external" href="http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html">内核分析——HOWTO</a></li>
<li><a class="reference external" href="http://web.archive.org/web/20090228191439/http://www.linuxhq.com/lkprogram.html">Linux 内核编程</a></li>
<li><a class="reference external" href="http://en.wikibooks.org/wiki/Linux_kernel">Linux 内核——Wikibooks</a></li>
</ul>
<p>这些链接并不全面。使用 <a class="reference external" href="http://www.google.com">互联网</a> 和 <a class="reference external" href="http://lxr.free-electrons.com/">内核源代码</a> 是必不可少的。</p>
</div>
<div class="section" id="section-4">
<h2>内核模块概述<a class="headerlink" href="#section-4" title="Permalink to this headline">¶</a></h2>
<p>虽然单体内核比微内核更快，但缺乏模块化和可扩展性。在现代单体内核中，这个问题已经通过使用内核模块来解决。内核模块（或可加载内核模式）是一个包含代码的目标文件（object file），它可以在运行时扩展内核的功能（根据需要加载）；当不需要内核模块时，可以卸载它。大多数设备驱动程序以内核模块的形式使用。</p>
<p>为了开发 Linux 设备驱动程序，建议下载内核源代码，配置和编译它们，然后将编译后的版本安装在测试/开发工具机上。</p>
</div>
<div class="section" id="section-5">
<h2>内核模块示例<a class="headerlink" href="#section-5" title="Permalink to this headline">¶</a></h2>
<p>以下是一个非常简单的内核模块示例。当加载到内核中时，它会生成消息 <code class="code docutils literal"><span class="pre">&quot;Hi&quot;</span></code>。当卸载内核模块时，将生成消息 <code class="code docutils literal"><span class="pre">&quot;Bye&quot;</span></code>。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;My kernel module&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Me&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Hi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dummy_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Bye</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dummy_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dummy_exit</span><span class="p">);</span>
</pre></div>
</div>
<p>生成的消息不会显示在控制台上，而是保存在专门预留的内存区域中，由日志守护程序（syslog）负责将其提取出来。要显示内核消息，你可以使用 <cite>dmesg</cite> 命令或检查日志文件。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># cat /var/log/syslog | tail -2</span>
Feb <span class="m">20</span> <span class="m">13</span>:57:38 asgard kernel: Hi
Feb <span class="m">20</span> <span class="m">13</span>:57:43 asgard kernel: Bye

<span class="c1"># dmesg | tail -2</span>
Hi
Bye
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h2>编译内核模块<a class="headerlink" href="#section-6" title="Permalink to this headline">¶</a></h2>
<p>编译内核模块与编译用户程序不同。首先，需要使用另外的头文件。此外，模块不应链接到库。最重要的是，模块必须使用与加载模块的内核相同的选项进行编译。出于这些原因，有一种标准的编译方法（kbuild）。该方法需要使用两个文件： <code class="file docutils literal"><span class="pre">Makefile</span></code> 文件和 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件。</p>
<p>以下是 <code class="file docutils literal"><span class="pre">Makefile</span></code> 文件的示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">KDIR</span> <span class="o">=</span> /lib/modules/<span class="sb">`</span>uname -r<span class="sb">`</span>/build

kbuild:
        make -C <span class="k">$(</span>KDIR<span class="k">)</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>

clean:
        make -C <span class="k">$(</span>KDIR<span class="k">)</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> clean
</pre></div>
</div>
<p>以下是用于编译模块的 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">EXTRA_CFLAGS</span> <span class="o">=</span> -Wall -g

obj-m        <span class="o">=</span> modul.o
</pre></div>
</div>
<p>正如你所见，在示例中调用 <strong class="command">make</strong> 命令对 <code class="file docutils literal"><span class="pre">Makefile</span></code> 文件进行编译将导致在内核源代码目录（<code class="docutils literal"><span class="pre">/lib/modules/`uname</span> <span class="pre">-r`/build</span></code>）中调用 <strong class="command">make</strong> 并引用当前目录（<code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">`pwd</span></code>）。该过程最终会读取当前目录中的 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件，并按照该文件中的指示编译模块。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>对于实验，我们将根据虚拟机的规格配置不同的 <strong class="command">KDIR</strong>：</p>
<div class="last highlight-bash"><div class="highlight"><pre><span></span><span class="nv">KDIR</span> <span class="o">=</span> /home/student/src/linux
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
</div>
<p><code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件包含一个或多个指令，用于编译内核模块。其中一个最简单的指令示例是 <code class="docutils literal"><span class="pre">obj-m</span> <span class="pre">=</span> <span class="pre">module.o</span></code>。根据该指令，将从 <code class="docutils literal"><span class="pre">module.o</span></code> 文件开始创建一个内核模块（ <code class="code docutils literal"><span class="pre">ko</span></code> ，即 <code class="code docutils literal"><span class="pre">kernel</span> <span class="pre">object</span></code>，也就是内核对象）。<code class="docutils literal"><span class="pre">module.o</span></code> 将基于 <code class="docutils literal"><span class="pre">module.c</span></code> 或 <code class="docutils literal"><span class="pre">module.S</span></code> 创建。所有这些文件都可以在 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 所在的目录中找到。</p>
<p>下面是一个使用多个子模块的 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">EXTRA_CFLAGS</span> <span class="o">=</span> -Wall -g

obj-m        <span class="o">=</span> supermodule.o
supermodule-y <span class="o">=</span> module-a.o module-b.o
</pre></div>
</div>
<p>对于上面的示例，编译步骤如下：</p>
<blockquote>
<div><ul class="simple">
<li>编译 <code class="file docutils literal"><span class="pre">module-a.c</span></code> 和 <code class="file docutils literal"><span class="pre">module-b.c</span></code> 源文件，生成 module-a.o 和 module-b.o 对象文件（object）</li>
<li>然后将 <code class="file docutils literal"><span class="pre">module-a.o</span></code> 和 <code class="file docutils literal"><span class="pre">module-b.o</span></code> 链接到 <code class="file docutils literal"><span class="pre">supermodule.o</span></code></li>
<li>基于 <code class="file docutils literal"><span class="pre">supermodule.o</span></code> 创建 <code class="file docutils literal"><span class="pre">supermodule.ko</span></code> 模块</li>
</ul>
</div></blockquote>
<p><code class="file docutils literal"><span class="pre">Kbuild</span></code> 中目标（target）的后缀决定了它们的用途，如下所示：</p>
<blockquote>
<div><ul class="simple">
<li>M（modules） 标示目标为可加载内核模块</li>
<li>Y（yes） 表示目标是用于编译并链接到模块（<code class="docutils literal"><span class="pre">$(模块名称)-y</span></code>）或内核（<code class="docutils literal"><span class="pre">obj-y</span></code>）的对象文件</li>
<li>其他任何目标后缀都将被 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 忽略，不会被编译</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">这些后缀使得可以通过运行 <strong class="command">make menuconfig</strong> 命令或直接编辑 <code class="file docutils literal"><span class="pre">.config</span></code> 文件来轻松配置内核。该文件设置了一系列变量，用于确定在构建时向内核添加哪些特性。例如，使用 <strong class="command">make menuconfig</strong> 命令添加 BTRFS 支持时，在 <code class="file docutils literal"><span class="pre">.config</span></code> 文件中添加行 <code class="code docutils literal"><span class="pre">CONFIG_BTRFS_FS</span> <span class="pre">=</span> <span class="pre">y</span></code>。BTRFS kbuild 包含了一行 <code class="docutils literal"><span class="pre">obj-$(CONFIG_BTRFS_FS):=</span> <span class="pre">btrfs.o</span></code>，它会转变成 <code class="docutils literal"><span class="pre">obj-y:=</span> <span class="pre">btrfs.o</span></code>。这将编译 <code class="file docutils literal"><span class="pre">btrfs.o</span></code> 对象，并将其链接到内核。如果没有设置变量，该行会转变成 <code class="docutils literal"><span class="pre">obj:=btrfs.o</span></code>，然后被忽略，进而内核构建时不会包含 BTRFS 支持。</p>
</div>
<p>要了解更多详细信息，请参阅内核源代码中的 <code class="file docutils literal"><span class="pre">Documentation/kbuild/makefiles.txt</span></code> 和 <code class="file docutils literal"><span class="pre">Documentation/kbuild/modules.txt</span></code> 文件。</p>
</div>
<div class="section" id="section-7">
<h2>加载/卸载内核模块<a class="headerlink" href="#section-7" title="Permalink to this headline">¶</a></h2>
<p>要加载内核模块，请使用 <strong class="command">insmod</strong> 程序。该程序接收用于编译和链接模块的 <code class="file docutils literal"><span class="pre">*.ko</span></code> 文件的路径作为参数。要从内核中卸载模块请使用 <strong class="command">rmmod</strong> 命令，该命令接收模块名称作为参数。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ insmod module.ko
$ rmmod module.ko
</pre></div>
</div>
<p>加载内核模块时，将执行 <code class="docutils literal"><span class="pre">module_init</span></code> 宏（macro）参数指定的函数。同样，当卸载模块时，将执行 <code class="docutils literal"><span class="pre">module_exit</span></code> 宏参数指定的函数。</p>
<p>下面是一个完整的编译、加载和卸载内核模块的示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-lin# ls
Kbuild  Makefile  modul.c

faust:~/lab-01/modul-lin# make
make -C /lib/modules/<span class="sb">`</span>uname -r<span class="sb">`</span>/build <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
make<span class="o">[</span><span class="m">1</span><span class="o">]</span>: Entering directory <span class="sb">`</span>/usr/src/linux-2.6.28.4<span class="s1">&#39;</span>
<span class="s1">  LD      /root/lab-01/modul-lin/built-in.o</span>
<span class="s1">  CC [M]  /root/lab-01/modul-lin/modul.o</span>
<span class="s1">  Building modules, stage 2.</span>
<span class="s1">  MODPOST 1 modules</span>
<span class="s1">  CC      /root/lab-01/modul-lin/modul.mod.o</span>
<span class="s1">  LD [M]  /root/lab-01/modul-lin/modul.ko</span>
<span class="s1">make[1]: Leaving directory `/usr/src/linux-2.6.28.4&#39;</span>

faust:~/lab-01/modul-lin# ls
built-in.o  Kbuild  Makefile  modul.c  Module.markers
modules.order  Module.symvers  modul.ko  modul.mod.c
modul.mod.o  modul.o

faust:~/lab-01/modul-lin# insmod modul.ko

faust:~/lab-01/modul-lin# dmesg <span class="p">|</span> tail -1
Hi

faust:~/lab-01/modul-lin# rmmod modul

faust:~/lab-01/modul-lin# dmesg <span class="p">|</span> tail -2
Hi
Bye
</pre></div>
</div>
<p>可以使用 <strong class="command">lsmod</strong> 命令或查看 <code class="file docutils literal"><span class="pre">/proc/modules</span></code> 、 <code class="file docutils literal"><span class="pre">/sys/module</span></code> 目录来获取有关加载到内核中的模块的信息。</p>
</div>
<div class="section" id="section-8">
<h2>内核模块调试<a class="headerlink" href="#section-8" title="Permalink to this headline">¶</a></h2>
<p>与调试常规程序相比，调试内核模块要复杂得多。首先，内核模块中的错误可能导致整个系统阻塞。因此，故障排除的速度会大大降低。为了避免重新启动，建议使用虚拟机（qemu、virtualbox 或者 vmware）。</p>
<p>当插入包含错误的模块到内核中时，它最终会生成一个 <a class="reference external" href="https://zh.wikipedia.org/wiki/Oops_(Linux内核)">内核 oops</a> 。内核 oops 是内核检测到的无效操作，只可能由内核生成。对于稳定的内核版本，这几乎可以肯定意味着模块含有错误。在 oops 出现后，内核仍将继续工作。</p>
<p>出现内核 oops 时，保存生成的消息非常重要。如上所述，内核生成的消息保存在日志中，并可使用 <strong class="command">dmesg</strong> 命令显示。为了确保不丢失任何内核消息，建议直接从控制台插入/测试内核，或定期检查内核消息。值得注意的是，oops 不止可能是由于编程错误，也有可能是硬件错误引起的。</p>
<p>如果发生致命错误，系统无法恢复到稳定状态，将造成 <a class="reference external" href="https://zh.wikipedia.org/wiki/内核错误">内核错误（kernel panic）</a> 。</p>
<p>以下是一个包含错误并会造成 oops 的内核模块示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * 造成 oops 的内核模块</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>

<span class="n">MODULE_DESCRIPTION</span> <span class="p">(</span><span class="s">&quot;Oops&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span> <span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span> <span class="p">(</span><span class="s">&quot;PSO&quot;</span><span class="p">);</span>

<span class="cp">#define OP_READ         0</span>
<span class="cp">#define OP_WRITE        1</span>
<span class="cp">#define OP_OOPS         OP_WRITE</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_oops_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x00001234</span><span class="p">;</span>
<span class="cp">#if OP_OOPS == OP_WRITE</span>
        <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="cp">#elif OP_OOPS == OP_READ</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;Unknown op for oops!&quot;</span>
<span class="cp">#endif</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_oops_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">module_init</span> <span class="p">(</span><span class="n">my_oops_init</span><span class="p">);</span>
<span class="n">module_exit</span> <span class="p">(</span><span class="n">my_oops_exit</span><span class="p">);</span>
</pre></div>
</div>
<p>将此模块插入内核将造成 oops：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# insmod oops.ko
<span class="o">[</span>...<span class="o">]</span>

faust:~/lab-01/modul-oops# dmesg <span class="p">|</span> tail -32
BUG: unable to handle kernel paging request at <span class="m">00001234</span>
IP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span>
  *de <span class="o">=</span> <span class="m">00000000</span>
Oops: <span class="m">0002</span> <span class="o">[</span><span class="c1">#1] PREEMPT DEBUG_PAGEALLOC</span>
last sysfs file: /sys/devices/virtual/net/lo/operstate
Modules linked in: oops<span class="o">(</span>+<span class="o">)</span> netconsole ide_cd_mod pcnet32 crc32 cdrom <span class="o">[</span>last unloaded: modul<span class="o">]</span>

Pid: <span class="m">4157</span>, comm: insmod Not tainted <span class="o">(</span><span class="m">2</span>.6.28.4 <span class="c1">#2) VMware Virtual Platform</span>
EIP: <span class="m">0060</span>:<span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> EFLAGS: <span class="m">00010246</span> CPU: <span class="m">0</span>
EIP is at my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span>
EAX: <span class="m">00000000</span> EBX: fffffffc ECX: c89d4300 EDX: <span class="m">00000001</span>
ESI: c89d4000 EDI: <span class="m">00000000</span> EBP: c5799e24 ESP: c5799e24
 DS: 007b ES: 007b FS: <span class="m">0000</span> GS: <span class="m">0033</span> SS: <span class="m">0068</span>
Process insmod <span class="o">(</span>pid: <span class="m">4157</span>, <span class="nv">ti</span><span class="o">=</span>c5799000 <span class="nv">task</span><span class="o">=</span>c665c780 task.ti<span class="o">=</span>c5799000<span class="o">)</span>
Stack:
 c5799f8c c010102d c72b51d8 0000000c c5799e58 c01708e4 <span class="m">00000124</span> <span class="m">00000000</span>
 c89d4300 c5799e58 c724f448 <span class="m">00000001</span> c89d4300 c5799e60 c0170981 c5799f8c
 c014b698 <span class="m">00000000</span> <span class="m">00000000</span> c5799f78 c5799f20 <span class="m">00000500</span> c665cb00 c89d4300
Call Trace:
 <span class="o">[</span>&lt;c010102d&gt;<span class="o">]</span> ? _stext+0x2d/0x170
 <span class="o">[</span>&lt;c01708e4&gt;<span class="o">]</span> ? __vunmap+0xa4/0xf0
 <span class="o">[</span>&lt;c0170981&gt;<span class="o">]</span> ? vfree+0x21/0x30
 <span class="o">[</span>&lt;c014b698&gt;<span class="o">]</span> ? load_module+0x19b8/0x1a40
 <span class="o">[</span>&lt;c035e965&gt;<span class="o">]</span> ? __mutex_unlock_slowpath+0xd5/0x140
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c014b7aa&gt;<span class="o">]</span> ? sys_init_module+0x8a/0x1b0
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c0240a08&gt;<span class="o">]</span> ? trace_hardirqs_on_thunk+0xc/0x10
 <span class="o">[</span>&lt;c0103407&gt;<span class="o">]</span> ? sysenter_do_call+0x12/0x43
Code: &lt;c7&gt; <span class="m">05</span> <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> <span class="m">03</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 5d c3 eb 0d <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span>
EIP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span> SS:ESP <span class="m">0068</span>:c5799e24
---<span class="o">[</span> end trace 2981ce73ae801363 <span class="o">]</span>---
</pre></div>
</div>
<p>虽然相对晦涩，但内核在出现 oops 时提供了有关错误的宝贵信息。第一行：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>BUG: unable to handle kernel paging request at <span class="m">00001234</span>
EIP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init + 0x5 / 0x20 <span class="o">[</span>oops<span class="o">]</span>
</pre></div>
</div>
<p>告诉我们错误的原因和生成错误的指令的地址。在我们的例子中，这是对内存的无效访问。</p>
<p>接下来的一行是：</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">Oops:</span> <span class="pre">0002</span> <span class="pre">[#</span> <span class="pre">1]</span> <span class="pre">PREEMPT</span> <span class="pre">DEBUG_PAGEALLOC</span></code></div></blockquote>
<p>告诉我们这是第一个 oops（#1）。在这个上下文中，这很重要，因为一个 oops 可能会导致其他 oops。通常只有第一个 oops 是相关的。此外，oops 代码（ <code class="docutils literal"><span class="pre">0002</span></code> ）提供了有关错误类型的信息（参见 <code class="file docutils literal"><span class="pre">arch/x86/include/asm/trap_pf.h</span></code> ）：</p>
<blockquote>
<div><ul class="simple">
<li>Bit 0 == 0 表示找不到页面，1 表示保护故障</li>
<li>Bit 1 == 0 表示读取，1 表示写入</li>
<li>Bit 2 == 0 表示内核模式，1 表示用户模式</li>
</ul>
</div></blockquote>
<p>在这种情况下，我们有一个写入访问导致了 oops（bit 1 为 1）。</p>
<p>下面是寄存器的转储（dump）。它解码了指令指针 (<code class="docutils literal"><span class="pre">EIP</span></code>) 的值，并指出错误出现在 <code class="code docutils literal"><span class="pre">my_oops_init</span></code> 函数中，偏移为 5 个字节（<code class="docutils literal"><span class="pre">EIP:</span> <span class="pre">[&lt;c89d4005&gt;]</span> <span class="pre">my_oops_init+0x5</span></code>）。该消息还显示了堆栈内容和到目前为止的调用回溯。</p>
<p>如果发生了无效的读取调用 (<code class="docutils literal"><span class="pre">#define</span> <span class="pre">OP_OOPS</span> <span class="pre">OP_READ</span></code>)，消息将是相同的，但是 oops 代码将不同，现在将是 <code class="docutils literal"><span class="pre">0000</span></code>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# dmesg <span class="p">|</span> tail -33
BUG: unable to handle kernel paging request at <span class="m">00001234</span>
IP: <span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span>
  *de <span class="o">=</span> <span class="m">00000000</span>
Oops: <span class="m">0000</span> <span class="o">[</span><span class="c1">#1] PREEMPT DEBUG_PAGEALLOC</span>
last sysfs file: /sys/devices/virtual/net/lo/operstate
Modules linked in: oops<span class="o">(</span>+<span class="o">)</span> netconsole pcnet32 crc32 ide_cd_mod cdrom

Pid: <span class="m">2754</span>, comm: insmod Not tainted <span class="o">(</span><span class="m">2</span>.6.28.4 <span class="c1">#2) VMware Virtual Platform</span>
EIP: <span class="m">0060</span>:<span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> EFLAGS: <span class="m">00010292</span> CPU: <span class="m">0</span>
EIP is at my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span>
EAX: <span class="m">00000000</span> EBX: fffffffc ECX: c89c3380 EDX: <span class="m">00000001</span>
ESI: c89c3010 EDI: <span class="m">00000000</span> EBP: c57cbe24 ESP: c57cbe1c
 DS: 007b ES: 007b FS: <span class="m">0000</span> GS: <span class="m">0033</span> SS: <span class="m">0068</span>
Process insmod <span class="o">(</span>pid: <span class="m">2754</span>, <span class="nv">ti</span><span class="o">=</span>c57cb000 <span class="nv">task</span><span class="o">=</span>c66ec780 task.ti<span class="o">=</span>c57cb000<span class="o">)</span>
Stack:
 c57cbe34 <span class="m">00000282</span> c57cbf8c c010102d c57b9280 0000000c c57cbe58 c01708e4
 <span class="m">00000124</span> <span class="m">00000000</span> c89c3380 c57cbe58 c5db1d38 <span class="m">00000001</span> c89c3380 c57cbe60
 c0170981 c57cbf8c c014b698 <span class="m">00000000</span> <span class="m">00000000</span> c57cbf78 c57cbf20 <span class="m">00000580</span>
Call Trace:
 <span class="o">[</span>&lt;c010102d&gt;<span class="o">]</span> ? _stext+0x2d/0x170
 <span class="o">[</span>&lt;c01708e4&gt;<span class="o">]</span> ? __vunmap+0xa4/0xf0
 <span class="o">[</span>&lt;c0170981&gt;<span class="o">]</span> ? vfree+0x21/0x30
 <span class="o">[</span>&lt;c014b698&gt;<span class="o">]</span> ? load_module+0x19b8/0x1a40
 <span class="o">[</span>&lt;c035d083&gt;<span class="o">]</span> ? printk+0x0/0x1a
 <span class="o">[</span>&lt;c035e965&gt;<span class="o">]</span> ? __mutex_unlock_slowpath+0xd5/0x140
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c014b7aa&gt;<span class="o">]</span> ? sys_init_module+0x8a/0x1b0
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c0240a08&gt;<span class="o">]</span> ? trace_hardirqs_on_thunk+0xc/0x10
 <span class="o">[</span>&lt;c0103407&gt;<span class="o">]</span> ? sysenter_do_call+0x12/0x43
Code: &lt;a1&gt; <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> c7 <span class="m">04</span> <span class="m">24</span> <span class="m">54</span> <span class="m">30</span> 9c c8 <span class="m">89</span> <span class="m">44</span> <span class="m">24</span> <span class="m">04</span> e8 <span class="m">58</span> a0 <span class="m">99</span> f7 <span class="m">31</span>
EIP: <span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span> SS:ESP <span class="m">0068</span>:c57cbe1c
---<span class="o">[</span> end trace 45eeb3d6ea8ff1ed <span class="o">]</span>---
</pre></div>
</div>
<div class="section" id="objdump">
<h3>objdump<a class="headerlink" href="#objdump" title="Permalink to this headline">¶</a></h3>
<p>可以使用 <strong class="command">objdump</strong> 程序找到造成 oops 的指令（instruction）的详细信息。常用的选项有 <strong class="command">-d</strong> 用于反汇编代码， <strong class="command">-S</strong> 用于将 C 代码与汇编语言代码交错显示。然而，为了进行高效的解码，我们需要找到内核模块被加载到的地址。这可以在 <code class="file docutils literal"><span class="pre">/proc/modules</span></code> 中找到。</p>
<p>以下是在上述模块上使用 <strong class="command">objdump</strong> 的示例，以确定造成 oops 的指令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# cat /proc/modules
oops <span class="m">1280</span> <span class="m">1</span> - Loading 0xc89d4000
netconsole <span class="m">8352</span> <span class="m">0</span> - Live 0xc89ad000
pcnet32 <span class="m">33412</span> <span class="m">0</span> - Live 0xc895a000
ide_cd_mod <span class="m">34952</span> <span class="m">0</span> - Live 0xc8903000
crc32 <span class="m">4224</span> <span class="m">1</span> pcnet32, Live 0xc888a000
cdrom <span class="m">34848</span> <span class="m">1</span> ide_cd_mod, Live 0xc886d000

faust:~/lab-01/modul-oops# objdump -dS --adjust-vma<span class="o">=</span>0xc89d4000 oops.ko

oops.ko:     file format elf32-i386


Disassembly of section .text:

c89d4000 &lt;init_module&gt;:
<span class="c1">#define OP_READ         0</span>
<span class="c1">#define OP_WRITE        1</span>
<span class="c1">#define OP_OOPS         OP_WRITE</span>

static int my_oops_init <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4000:       <span class="m">55</span>                      push   %ebp
<span class="c1">#else</span>
<span class="c1">#error &quot;Unknown op for oops!&quot;</span>
<span class="c1">#endif</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
c89d4001:       <span class="m">31</span> c0                   xor    %eax,%eax
<span class="c1">#define OP_READ         0</span>
<span class="c1">#define OP_WRITE        1</span>
<span class="c1">#define OP_OOPS         OP_WRITE</span>

static int my_oops_init <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4003:       <span class="m">89</span> e5                   mov    %esp,%ebp
        int *a<span class="p">;</span>

        <span class="nv">a</span> <span class="o">=</span> <span class="o">(</span>int *<span class="o">)</span> 0x00001234<span class="p">;</span>
<span class="c1">#if OP_OOPS == OP_WRITE</span>
        *a <span class="o">=</span> <span class="m">3</span><span class="p">;</span>
c89d4005:       c7 <span class="m">05</span> <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> <span class="m">03</span>    movl   <span class="nv">$0</span>x3,0x1234
c89d400c:       <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
<span class="c1">#else</span>
<span class="c1">#error &quot;Unknown op for oops!&quot;</span>
<span class="c1">#endif</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
c89d400f:       5d                      pop    %ebp
c89d4010:       c3                      ret
c89d4011:       eb 0d                   jmp    c89c3020 &lt;cleanup_module&gt;
c89d4013:       <span class="m">90</span>                      nop
c89d4014:       <span class="m">90</span>                      nop
c89d4015:       <span class="m">90</span>                      nop
c89d4016:       <span class="m">90</span>                      nop
c89d4017:       <span class="m">90</span>                      nop
c89d4018:       <span class="m">90</span>                      nop
c89d4019:       <span class="m">90</span>                      nop
c89d401a:       <span class="m">90</span>                      nop
c89d401b:       <span class="m">90</span>                      nop
c89d401c:       <span class="m">90</span>                      nop
c89d401d:       <span class="m">90</span>                      nop
c89d401e:       <span class="m">90</span>                      nop
c89d401f:       <span class="m">90</span>                      nop

c89d4020 &lt;cleanup_module&gt;:

static void my_oops_exit <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4020:       <span class="m">55</span>                      push   %ebp
c89d4021:       <span class="m">89</span> e5                   mov    %esp,%ebp
<span class="o">}</span>
c89d4023:       5d                      pop    %ebp
c89d4024:       c3                      ret
c89d4025:       <span class="m">90</span>                      nop
c89d4026:       <span class="m">90</span>                      nop
c89d4027:       <span class="m">90</span>                      nop
</pre></div>
</div>
<p>请注意，生成 oops 的指令（先前确定为 <code class="docutils literal"><span class="pre">c89d4005</span></code> ）是：</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">`C89d4005:</span> <span class="pre">c7</span> <span class="pre">05</span> <span class="pre">34</span> <span class="pre">12</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">03</span> <span class="pre">movl</span> <span class="pre">$</span> <span class="pre">0x3,0x1234</span></code></div></blockquote>
<p>这正是预期的结果 - 将值 3 存储在地址 0x0001234 上。</p>
<p><code class="file docutils literal"><span class="pre">/proc/modules</span></code> 用于查找加载的内核模块的地址。<strong class="command">--adjust-vma</strong> 选项允许你相对于 <code class="docutils literal"><span class="pre">0xc89d4000</span></code> 位置显示指令。<strong class="command">-l</strong> 选项将显示源代码中每行的编号，源代码与汇编语言代码交错显示。</p>
</div>
<div class="section" id="addr2line">
<h3>addr2line<a class="headerlink" href="#addr2line" title="Permalink to this headline">¶</a></h3>
<p>寻找造成 oops 的代码的一种更简单的方法是使用 <strong class="command">addr2line</strong> 实用程序：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# addr2line -e oops.o 0x5
/root/lab-01/modul-oops/oops.c:23
</pre></div>
</div>
<p>其中``0x5``是生成 oops 的程序计数器的值（<code class="docutils literal"><span class="pre">EIP</span> <span class="pre">=</span> <span class="pre">c89d4005</span></code>），减去根据 <code class="file docutils literal"><span class="pre">/proc/modules</span></code> 的信息得出的模块的基地址（<code class="docutils literal"><span class="pre">0xc89d4000</span></code>），。</p>
</div>
<div class="section" id="minicom">
<h3>minicom<a class="headerlink" href="#minicom" title="Permalink to this headline">¶</a></h3>
<p><strong class="command">Minicom`（或其他等效程序，例如 :command:`picocom</strong> 以及 <strong class="command">screen</strong> ）是一种用于与串行端口（serial port）连接和交互的程序。串行端口是在开发阶段分析内核消息（kernel message）或与嵌入式系统进行交互的基本方法。有两种常见的连接方式：</p>
<ul class="simple">
<li>使用串行端口，设备路径为 <code class="file docutils literal"><span class="pre">/dev/ttyS0</span></code></li>
<li>使用串行 USB 端口（FTDI），在这种情况下，设备路径为 <code class="file docutils literal"><span class="pre">/dev/ttyUSB</span></code></li>
</ul>
<p>对于实验中使用的虚拟机，在虚拟机启动后，我们需要使用的设备路径将显示在屏幕上：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>char device redirected to /dev/pts/20 <span class="o">(</span>label virtiocon0<span class="o">)</span>
</pre></div>
</div>
<p>使用 Minicom：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 使用 COM1 连接，速率为 115,200 字符/秒</span>
minicom -b <span class="m">115200</span> -D /dev/ttyS0

<span class="c1"># 使用 USB 串行端口连接</span>
minicom -D /dev/ttyUSB0

<span class="c1"># 连接到虚拟机的串行端口</span>
minicom -D /dev/pts/20
</pre></div>
</div>
</div>
<div class="section" id="netconsole">
<h3>netconsole<a class="headerlink" href="#netconsole" title="Permalink to this headline">¶</a></h3>
<p><strong class="command">Netconsole</strong> 是允许通过网络记录内核调试消息的程序。当磁盘日志系统不起作用、串行端口不可用或终端不响应命令时，这非常有用。<strong class="command">Netconsole</strong> 是内核模块。</p>
<p>要想正常工作，它需要以下参数：</p>
<blockquote>
<div><ul class="simple">
<li>调试站点的端口、IP 地址和源接口名称</li>
<li>将调试消息发送到的机器的端口、MAC 地址和 IP 地址</li>
</ul>
</div></blockquote>
<p>这些参数可以在将模块插入内核时进行配置，甚至在模块插入后也可以配置，如果模块在编译时配置了 <code class="docutils literal"><span class="pre">CONFIG_NETCONSOLE_DYNAMIC</span></code> 选项。</p>
<p>插入 <strong class="command">netconsole</strong> 内核模块时的示例配置如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>alice:~# modprobe netconsole <span class="nv">netconsole</span><span class="o">=</span><span class="m">6666</span>@192.168.191.130/eth0,6000@192.168.191.1/00:50:56:c0:00:08
</pre></div>
</div>
<p>因此，在具有地址 <code class="docutils literal"><span class="pre">192.168.191.130</span></code> 的站点上，调试消息将被发送到 <code class="docutils literal"><span class="pre">eth0</span></code> 接口，源端口为``6666``。消息将被发送到``192.168.191.1``，使用 MAC 地址``00:50:56:c0:00:08``，至端口``6000``上。</p>
<p>可以在目标站点上使用 <strong class="command">netcat</strong> 显示消息：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>bob:~ <span class="c1"># nc -l -p 6000 -u</span>
</pre></div>
</div>
<p>或者，目标站点可以配置 <strong class="command">syslogd</strong> 来拦截这些消息。更多信息可以在 <code class="file docutils literal"><span class="pre">Documentation/networking/netconsole.txt</span></code> 中找到。</p>
</div>
<div class="section" id="printk">
<h3>Printk 调试<a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">最古老且最有用的两种调试辅助工具是你的大脑和</span> <span class="pre">Printf</span></code>。</p>
<p>在调试过程中，通常会使用一种原始但非常有效的方法：<code class="code docutils literal"><span class="pre">printk</span></code> 调试。尽管也可以使用调试器，但通常并不是非常有用：简单的错误（未初始化的变量、内存管理问题等）可以通过控制消息和内核解码的 oops 消息轻松找到。</p>
<p>对于更复杂的错误，即使是调试器也无法提供太多帮助，除非你对操作系统的结构非常熟悉。在调试内核模块时，其中存在许多未知因素：多个上下文（我们同时运行多个进程和线程）、中断以及虚拟内存等等。</p>
<p>你可以使用 <code class="code docutils literal"><span class="pre">printk</span></code> 将内核消息显示到用户空间。它类似于 <code class="code docutils literal"><span class="pre">printf</span></code> 的功能；唯一的区别是传输的消息可以用 <code class="code docutils literal"><span class="pre">&quot;&lt;n&gt;&quot;</span></code> 字符串为前缀，其中 <code class="code docutils literal"><span class="pre">n</span></code> 表示错误级别（日志级别），取值范围为 <code class="docutils literal"><span class="pre">0</span></code> 到 <code class="docutils literal"><span class="pre">7</span></code> 。除了 <code class="code docutils literal"><span class="pre">&quot;&lt;n&gt;&quot;</span></code>，级别也可以用符号常量编码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span>KERN_EMERG——n = 0
KERN_ALERT——n = 1
KERN_CRIT——n = 2
KERN_ERR——n = 3
KERN_WARNING——n = 4
KERN_NOTICE——n = 5
KERN_INFO——n = 6
KERN_DEBUG——n = 7
</pre></div>
</div>
<p>所有日志级别的定义都可以在 <code class="file docutils literal"><span class="pre">linux/kern_levels.h</span></code> 中找到。基本上，系统凭借这些日志级别将消息发送到各种输出：控制台、位于 <code class="file docutils literal"><span class="pre">/var/log</span></code> 中的日志文件等等。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">要在用户空间显示 <code class="code docutils literal"><span class="pre">printk</span></code> 消息，<code class="code docutils literal"><span class="pre">printk</span></code> 日志级别必须比 <cite>console_loglevel</cite> 变量的优先级高。可以从 <code class="file docutils literal"><span class="pre">/proc/sys/kernel/printk</span></code> 配置默认的控制台日志级别。</p>
</div>
<p>例如，以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="m">8</span> &gt; /proc/sys/kernel/printk
</pre></div>
</div>
<p>将使所有内核日志消息在控制台上显示。也就是说，日志级别必须严格小于 <code class="code docutils literal"><span class="pre">console_loglevel</span></code> 变量。例如，如果 <code class="code docutils literal"><span class="pre">console_loglevel</span></code> 的值为 <code class="docutils literal"><span class="pre">5``（指定于</span> <span class="pre">:code:`KERN_NOTICE`），只有比</span> <span class="pre">``5</span></code> 更严格的日志级别的消息（即 <code class="code docutils literal"><span class="pre">KERN_EMERG</span></code> 、<code class="code docutils literal"><span class="pre">KERN_ALERT</span></code> 、<code class="code docutils literal"><span class="pre">KERN_CRIT</span></code> 、<code class="code docutils literal"><span class="pre">KERN_ERR</span></code> 以及 <code class="code docutils literal"><span class="pre">KERN_WARNING</span></code>）将显示。</p>
<p>想要快速查看执行内核代码的效果的话，控制台重定向的消息可能对你很有帮助，但如果内核遇到不可修复的错误并且系统冻结，则不再那么有用。在这种情况下，必须查看系统的日志，因为它们保留从一次系统启动到下一次系统重新启动之间的信息。这些日志文件位于 <code class="file docutils literal"><span class="pre">/var/log</span></code> 中，是由内核运行期间的 <code class="code docutils literal"><span class="pre">syslogd</span></code> 和 <code class="code docutils literal"><span class="pre">klogd</span></code> 填充的文本文件。<code class="code docutils literal"><span class="pre">syslogd</span></code> 和 <code class="code docutils literal"><span class="pre">klogd</span></code> 从挂载在 <code class="file docutils literal"><span class="pre">/proc</span></code> 中的虚拟文件系统中获取信息。原则上，打开 <code class="code docutils literal"><span class="pre">syslogd</span></code> 和 <code class="code docutils literal"><span class="pre">klogd</span></code> 后，来自内核的所有消息都将发送到 <code class="file docutils literal"><span class="pre">/var/log/kern.log</span></code>。</p>
<p>调试的更简单的方法是使用 <code class="file docutils literal"><span class="pre">/var/log/debug</span></code> 文件。它只包含具有 <code class="code docutils literal"><span class="pre">KERN_DEBUG</span></code> 日志级别的内核的 <code class="code docutils literal"><span class="pre">printk</span></code> 消息。</p>
<p>给定一个生产内核（production kernel）（类似于我们可能正在运行的内核），其只包含发布代码，我们的模块是少数几个带有以 KERN_DEBUG 为前缀的消息的模块之一。通过查找与我们的模块的调试会话对应的消息，我们可以轻松浏览 <code class="file docutils literal"><span class="pre">/var/log/debug</span></code> 中的信息。</p>
<p>一个示例如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 清除先前信息的调试文件（或可能是备份文件）</span>
$ <span class="nb">echo</span> <span class="s2">&quot;新调试会话&quot;</span> &gt; /var/log/debug
<span class="c1"># 运行测试</span>
<span class="c1"># 如果没有导致内核崩溃的关键错误，检查输出</span>
<span class="c1"># 如果发生关键错误且机器只能通过重新启动来响应，请重新启动系统并检查 /var/log/debug。</span>
</pre></div>
</div>
<p>消息的格式显然必须包含所有相关信息，以便检测错误，但插入代码 <code class="code docutils literal"><span class="pre">printk</span></code> 以提供详细信息可能会花费与编写代码解决问题一样多的时间。通常在使用 <code class="code docutils literal"><span class="pre">printk</span></code> 显示的调试消息的完整性与将这些消息插入文本中所需的时间之间需要有权衡。</p>
<p>一种非常简单、插入 <code class="code docutils literal"><span class="pre">printk</span></code> 更省时并使我们能够分析测试指令流的方法是使用预定义的常量 <code class="code docutils literal"><span class="pre">__FILE__</span></code> 、<code class="code docutils literal"><span class="pre">__LINE__</span></code> 和 <code class="code docutils literal"><span class="pre">__func__</span></code>：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">__FILE__</span></code> 会被编译器替换为当前正在编译的源文件的名称。</li>
<li><code class="docutils literal"><span class="pre">__LINE__</span></code> 会被编译器替换为当前源文件中当前指令所在的行号。</li>
<li><code class="docutils literal"><span class="pre">__func__</span></code> / <code class="docutils literal"><span class="pre">__FUNCTION__</span></code> 会被编译器替换为当前指令所在的函数的名称。</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="code docutils literal"><span class="pre">__FILE__</span></code> 和 <code class="code docutils literal"><span class="pre">__LINE__</span></code> 是 ANSI C 规范的一部分，<code class="code docutils literal"><span class="pre">__func__</span></code> 是 C99 规范的一部分；<code class="code docutils literal"><span class="pre">__FUNCTION__</span></code> 是 GNU 的一个 C 扩展，不具有可移植性；然而，由于我们编写的代码是针对 Linux 内核的，所以可以毫无问题地使用它们。</p>
</div>
<p>可以在这种情况下使用以下宏定义：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define PRINT_DEBUG \</span>
<span class="cp">       printk (KERN_DEBUG &quot;[% s]: FUNC:% s: LINE:% d \ n&quot;, __FILE__,</span>
               <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">)</span>
</pre></div>
</div>
<p>然后，在每个想要查看执行是否“到达”的位置，插入 PRINT_DEBUG；这是一种简单快捷的方法，通过仔细分析输出可以得出结果。</p>
<p><strong class="command">dmesg</strong> 命令用于查看在控制台上不显示，需要使用 <code class="code docutils literal"><span class="pre">printk</span></code> 来打印的消息。</p>
<p>要删除日志文件中的所有先前消息，请运行：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>cat /dev/null &gt; /var/log/debug
</pre></div>
</div>
<p>要删除 <strong class="command">dmesg</strong> 命令显示的消息，请运行：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>dmesg -c
</pre></div>
</div>
</div>
<div class="section" id="section-9">
<h3>动态调试<a class="headerlink" href="#section-9" title="Permalink to this headline">¶</a></h3>
<p>动态调试（ <a class="reference external" href="https://www.kernel.org/doc/html/v4.15/admin-guide/dynamic-debug-howto.html">dyndbg</a> ）技术可以动态地激活/停用调试。与 <code class="code docutils literal"><span class="pre">printk</span></code> 不同，它提供了更高级的 <code class="code docutils literal"><span class="pre">printk</span></code> 选项，可以用于仅显示我们想要的消息；其对于复杂模块或故障排除子系统非常有用。这显著减少了显示的消息数量，只留下与调试上下文相关的消息。要启用 <code class="docutils literal"><span class="pre">dyndbg</span></code> ，内核必须编译时启用 <code class="docutils literal"><span class="pre">CONFIG_DYNAMIC_DEBUG</span></code> 选项。一旦配置了这个选项，就可以每次调用时动态启用 <code class="code docutils literal"><span class="pre">pr_debug()</span></code> 、 <code class="code docutils literal"><span class="pre">dev_dbg()</span></code> 和 <code class="code docutils literal"><span class="pre">print_hex_dump_debug()</span></code> 、 <code class="code docutils literal"><span class="pre">print_hex_dump_bytes()</span></code>。</p>
<p>debugfs 中的 <code class="file docutils literal"><span class="pre">/sys/kernel/debug/dynamic_debug/control</span></code> 文件可以用于过滤消息或查看现有过滤器。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">-</span><span class="n">t</span> <span class="n">debugfs</span> <span class="n">none</span> <span class="o">/</span><span class="n">debug</span>
</pre></div>
</div>
<p><a class="reference external" href="http://opensourceforu.com/2010/10/debugging-linux-kernel-with-debugfs/">Debugfs</a> 是个简单的文件系统，用作内核空间接口和用户空间接口，以配置不同的调试选项。任何调试工具都可以在 debugfs 中创建和使用自己的文件/文件夹。</p>
<p>例如，要显示 <code class="docutils literal"><span class="pre">dyndbg</span></code> 中的现有过滤器，可以使用以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>cat /debug/dynamic_debug/control
</pre></div>
</div>
<p>要启用 <code class="file docutils literal"><span class="pre">svcsock.c</span></code> 文件中第 <code class="docutils literal"><span class="pre">1603</span></code> 行的调试消息：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line 1603 +p&#39;</span> &gt; /debug/dynamic_debug/control
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">/debug/dynamic_debug/control</span></code> 文件不是普通文件。它显示了过滤器的 <code class="docutils literal"><span class="pre">dyndbg</span></code> 设置。使用 echo 在其中写入会更改这些设置（实际上不会进行写入）。请注意，该文件包含了 <code class="docutils literal"><span class="pre">dyndbg</span></code> 调试消息的设置。不要在该文件中进行日志记录。</p>
<div class="section" id="dyndbg-1">
<h4>Dyndbg 选项<a class="headerlink" href="#dyndbg-1" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">func</span></code> ——只显示与过滤器中定义的函数名称相同的函数的调试消息。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s1">&#39;func svc_tcp_accept +p&#39;</span> &gt; /debug/dynamic_debug/control
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">file</span></code> ——要显示调试消息的文件名。可以只是源文件名，也可以是绝对路径或内核树路径。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>file svcsock.c
file kernel/freezer.c
file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">module</span></code> ——显示模块名称。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>module sunrpc
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">format</span></code> ——只显示显示格式包含指定字符串的消息。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>format <span class="s2">&quot;nfsd: SETATTR&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">line</span></code> - 显示调试调用的行号或行号范围。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 在 svcsock.c 文件的第 1603 行到第 1605 行之间触发调试消息</span>
$ <span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line 1603-1605 +p&#39;</span> &gt; /sys/kernel/debug/dynamic_debug/control
<span class="c1"># 从文件开头到第 1605 行启用调试消息</span>
$ <span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line -1605 +p&#39;</span> &gt; /sys/kernel/debug/dynamic_debug/control
</pre></div>
</div>
</li>
</ul>
<p>除了上述选项外，还可以使用操作符 <code class="docutils literal"><span class="pre">+</span></code>、 <code class="docutils literal"><span class="pre">-</span></code> 或 <code class="docutils literal"><span class="pre">=</span></code> 来添加、删除或设置一系列标志：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">p</span></code> 激活 pr_debug()。</li>
<li><code class="docutils literal"><span class="pre">f</span></code> 在打印的消息中包含函数名。</li>
<li><code class="docutils literal"><span class="pre">l</span></code> 在打印的消息中包含行号。</li>
<li><code class="docutils literal"><span class="pre">m</span></code> 在打印的消息中包含模块名称。</li>
<li><code class="docutils literal"><span class="pre">t</span></code> 如果不是从中断上下文调用，则包括线程 ID。</li>
<li><code class="docutils literal"><span class="pre">_</span></code> 不设置标志。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="kdb">
<h3>KDB：内核调试器<a class="headerlink" href="#kdb" title="Permalink to this headline">¶</a></h3>
<p>内核调试器已被证明在开发和调试过程中非常有用。其主要优势之一是可以进行实时调试。这使得我们能够实时监视对内存的访问，甚至在调试过程中修改内存。内核调试器从版本 2.6.26-rc1 开始，已集成到主线内核中。KDB 不是一个*源代码调试器*，但在进行完整分析时，可以与 gdb 和符号文件并行使用——请参见 <a class="reference internal" href="#gdb-intro"><span class="std std-ref">GDB调试部分</span></a></p>
<p>要使用KDB，你有以下选项：</p>
<blockquote>
<div><ul class="simple">
<li>非 USB 键盘 + VGA 文本控制台</li>
<li>串口控制台</li>
<li>USB EHCI 调试端口</li>
</ul>
</div></blockquote>
<p>在实验中，我们将使用连接到主机的串口接口。以下命令将在串口上激活 GDB：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc
</pre></div>
</div>
<p>KDB 是一种*停止模式调试器*，这意味着在其活动期间，所有其他进程都将停止。可以使用 <a class="reference external" href="http://zh.wikipedia.org/wiki/Magic_SysRq組合鍵">SysRq</a> 命令强制内核在执行过程中进入 KDB</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> g &gt; /proc/sysrq-trigger
</pre></div>
</div>
<p>或者在连接到串口的终端中使用键盘组合键 <a href="#system-message-1"><span class="problematic" id="problematic-1">``</span></a>Ctrl+O g``（例如使用 <strong class="command">minicom</strong>）。</p>
<p>KDB 具有各种命令来控制和定义被调试系统的上下文：</p>
<blockquote>
<div><ul class="simple">
<li>lsmod, ps, kill, dmesg, env, bt（backtrace，回溯）</li>
<li>转储跟踪日志</li>
<li>硬件断点</li>
<li>修改内存</li>
</ul>
</div></blockquote>
<p>要获取有关可用命令的更详细描述，可以在 KDB shell 中使用 <code class="docutils literal"><span class="pre">help</span></code> 命令。在下一个示例中，你可以看到一个简单的 KDB 使用示例，它设置了一个硬件断点来监视 <code class="docutils literal"><span class="pre">mVar</span></code> 变量的更改。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 触发 KDB</span>
<span class="nb">echo</span> g &gt; /proc/sysrq-trigger
<span class="c1"># 或者如果我们连接到串口，使用以下命令</span>
Ctrl-O g
<span class="c1"># 在对 mVar 变量进行写访问时设置断点</span>
kdb&gt; bph mVar dataw
<span class="c1"># 从KDB返回</span>
kdb&gt; go
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you want to learn how to easily browse through the Linux source code
and how to debug kernel code, read the <a class="reference external" href="#good-to-know">Good to know</a>
section.</p>
</div>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="section" id="section-10">
<h3>备注<a class="headerlink" href="#section-10" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>通常，开发内核模块的步骤如下：<ul>
<li>编辑模块源代码（在物理机上）；</li>
<li>编译模块（在物理机上）；</li>
<li>生成用于虚拟机的最小镜像；该镜像包含内核、你的模块、busybox 以及测试程序；</li>
<li>使用 QEMU 启动虚拟机；</li>
<li>在虚拟机中运行测试。</li>
</ul>
</li>
<li>当使用 cscope 时，请使用文件 <code class="file docutils literal"><span class="pre">~/src/linux</span></code>。如果没有文件 <code class="file docutils literal"><span class="pre">cscope.out</span></code>，可以使用命令 <strong class="command">make ARCH=x86 cscope</strong> 来生成它。</li>
<li>你可以在 <a class="reference internal" href="../info/vm.html#vm-link"><span class="std std-ref">虚拟机配置</span></a> 找到有关虚拟机的更多详细信息。</li>
</ul>
</div>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p class="last">在解决练习之前，<a href="#system-message-2"><span class="problematic" id="problematic-2">**</span></a>仔细**阅读所有要点。</p>
</div>
<div class="admonition important" id="exercises-summary">
<p class="first admonition-title">Important</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 kernel_modules。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/kernel_modules/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a href="#system-message-5"><span class="problematic" id="problematic-5">`练习`_</span></a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
</div>
<div class="section" id="section-11">
<h3>启动虚拟机<a class="headerlink" href="#section-11" title="Permalink to this headline">¶</a></h3>
<p>虚拟机基础设施摘要：</p>
<ul class="simple">
<li><code class="file docutils literal"><span class="pre">~/src/linux</span></code> ——Linux 内核源代码，用于编译模块。该目录包含文件 <code class="file docutils literal"><span class="pre">cscope.out</span></code>，用于在源代码树中导航。</li>
<li><code class="file docutils literal"><span class="pre">~/src/linux/tools/labs/qemu</span></code> ——用于生成和运行 QEMU 虚拟机的脚本和辅助文件。</li>
</ul>
<p>要启动虚拟机，请在目录 <code class="file docutils literal"><span class="pre">~/src/linux/tools/labs</span></code> 中运行 <strong class="command">make boot</strong>：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>student@eg106:~$ <span class="nb">cd</span> ~/src/linux/tools/labs
student@eg106:~/src/linux/tools/labs$ make boot
</pre></div>
</div>
<p>默认情况下，你将不会获得提示符或任何图形界面，但你可以使用 <strong class="command">minicom</strong> 或 <strong class="command">screen</strong> 连接到虚拟机提供的控制台。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>student@eg106:~/src/linux/tools/labs$ minicom -D serial.pts

&lt;按回车键&gt;

qemux86 login:
Poky <span class="o">(</span>Yocto Project Reference Distro<span class="o">)</span> <span class="m">2</span>.3 qemux86 /dev/hvc0
</pre></div>
</div>
<p>另外，也可以使用命令 <strong class="command">QEMU_DISPLAY=gtk make boot</strong> 启动虚拟机，这种情况下虚拟机带有图形界面支持。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">要访问虚拟机，请在登录提示符处输入用户名 <code class="code docutils literal"><span class="pre">root</span></code>；无需输入密码。虚拟机将以 root 帐户的权限启动。</p>
</div>
</div>
<div class="section" id="section-12">
<h3>1. 内核模块<a class="headerlink" href="#section-12" title="Permalink to this headline">¶</a></h3>
<p>为了使用内核模块，我们将按照 <span class="xref std std-ref">上述</span> 步骤进行操作。</p>
<p>首先在 <cite>tools/labs</cite> 目录下运行以下命令生成名为 <strong>1-2-test-mod</strong> 的任务骨架，然后构建并复制模块到虚拟机中。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nv">LABS</span><span class="o">=</span>kernel_modules make skels
$ make build
$ make copy
</pre></div>
</div>
<p>这些命令将构建并复制当前实验骨架中的所有模块。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在解决练习 3 之前，编译 <code class="docutils literal"><span class="pre">3-error-mod</span></code> 时会出现编译错误。为了避免此问题，删除 <code class="file docutils literal"><span class="pre">skels/kernel_modules/3-error-mod/</span></code> 目录，并从 <code class="docutils literal"><span class="pre">skels/Kbuild</span></code> 中删除相应的行。</p>
</div>
<p>使用 <strong class="command">make boot</strong> 启动虚拟机，使用 <cite>minicom -D serial.pts</cite> 连接到串行控制台，并执行以下任务：</p>
<ul class="simple">
<li>加载内核模块。</li>
<li>列出内核模块并检查当前模块是否存在。</li>
<li>卸载内核模块。</li>
<li>使用 <strong class="command">dmesg</strong> 命令查看加载/卸载内核模块时显示的消息。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请阅读 <a class="reference internal" href="#section-7">加载/卸载内核模块</a> 部分。在卸载内核模块时，只需指定模块名称（不包括扩展名）。</p>
</div>
</div>
<div class="section" id="printk-1">
<h3>2. Printk<a class="headerlink" href="#printk-1" title="Permalink to this headline">¶</a></h3>
<p>观察虚拟机控制台。为什么消息直接显示在虚拟机控制台上？</p>
<p>配置系统，使消息不直接显示在串行控制台上，只能使用 <code class="docutils literal"><span class="pre">dmesg</span></code> 命令来查看。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">一种方法是通过将所需级别写入 <code class="docutils literal"><span class="pre">/proc/sys/kernel/printk</span></code> 来设置控制台日志级别。使用的值应小于模块源代码中用于打印消息的级别。</p>
</div>
<p>重新加载/卸载该模块。消息不应该打印到虚拟机控制台上，但是在运行 <code class="docutils literal"><span class="pre">dmesg</span></code> 命令时应该可见。</p>
</div>
<div class="section" id="section-13">
<h3>3. 错误<a class="headerlink" href="#section-13" title="Permalink to this headline">¶</a></h3>
<p>生成名为 <strong>3-error-mod</strong> 的任务的框架。编译源代码并得到相应的内核模块。</p>
<p>为什么会出现编译错误？<a href="#system-message-3"><span class="problematic" id="problematic-3">**</span></a>提示：<a href="#system-message-4"><span class="problematic" id="problematic-4">**</span></a>这个模块与前一个模块有什么不同？</p>
<p>修改该模块以解决这些错误的原因，然后编译和测试该模块。</p>
</div>
<div class="section" id="section-14">
<h3>4. 子模块<a class="headerlink" href="#section-14" title="Permalink to this headline">¶</a></h3>
<p>查看 <code class="file docutils literal"><span class="pre">4-multi-mod/</span></code> 目录中的 C 源代码文件 <code class="docutils literal"><span class="pre">mod1.c</span></code> 和 <code class="docutils literal"><span class="pre">mod2.c</span></code>。模块 2 仅包含模块 1 使用的函数的定义。</p>
<p>修改 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件，从这两个 C 源文件创建 <code class="docutils literal"><span class="pre">multi_mod.ko</span></code> 模块。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验室中的 <a class="reference internal" href="#section-6">编译内核模块</a> 部分。</p>
</div>
<p>编译、复制、启动虚拟机、加载和卸载内核模块。确保消息在控制台上正确显示。</p>
</div>
<div class="section" id="oops-1">
<h3>5. 内核 oops<a class="headerlink" href="#oops-1" title="Permalink to this headline">¶</a></h3>
<p>进入任务目录 <strong>5-oops-mod</strong> 并检查 C 源代码文件。注意问题将在哪里发生。在 Kbuild 文件中添加编译标记 <code class="docutils literal"><span class="pre">-g</span></code>。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验中的 <a class="reference internal" href="#section-6">编译内核模块</a> 部分。</p>
</div>
<p>编译相应的模块并将其加载到内核中。识别 oops 出现的内存地址。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验中的 <a href="#system-message-6"><span class="problematic" id="problematic-6">`调试`_</span></a> 部分。要识别地址，请遵循 oops 消息并提取指令指针 (<code class="docutils literal"><span class="pre">EIP</span></code>) 寄存器的值。</p>
</div>
<p>确定是哪条指令触发了 oops。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">使用 <code class="file docutils literal"><span class="pre">proc/modules</span></code> 信息获取内核模块的加载地址。在物理机上使用 objdump 和/或 addr2line。Objdump 需要编译时开启调试支持！请阅读实验中的 <a class="reference internal" href="#objdump">objdump</a> 和 <a class="reference internal" href="#addr2line">addr2line</a> 部分。</p>
</div>
<p>尝试卸载内核模块。请注意，该操作无法成功，因为自 oops 发生以来，内核模块内部仍然存在对内核的引用；在释放这些引用之前（在 oops 的情况下几乎不可能），模块无法卸载。</p>
</div>
<div class="section" id="section-15">
<h3>6. 模块参数<a class="headerlink" href="#section-15" title="Permalink to this headline">¶</a></h3>
<p>进入任务目录 <strong>6-cmd-mod</strong> 并检查 C 源代码文件 <code class="docutils literal"><span class="pre">cmd_mod.c</span></code>。编译并复制相关的模块，然后加载内核模块以查看 printk 消息。然后从内核中卸载该模块。</p>
<p>在不修改源代码的情况下，加载内核模块以显示消息 <code class="docutils literal"><span class="pre">Early</span> <span class="pre">bird</span> <span class="pre">gets</span> <span class="pre">tired</span></code>。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">可以通过向模块传递参数来更改 str 变量。在 <a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x323.html">这里</a> 找到更多相关信息。</p>
</div>
<span class="target" id="proc-info"></span></div>
<div class="section" id="section-16">
<h3>7. 进程信息<a class="headerlink" href="#section-16" title="Permalink to this headline">¶</a></h3>
<p>检查名为 <strong>7-list-proc</strong> 的任务的框架。添加代码来显示当前进程的进程 ID（ <code class="docutils literal"><span class="pre">PID</span></code> ）和可执行文件名。</p>
<p>按照标记为 <code class="docutils literal"><span class="pre">TODO</span></code> 的命令进行操作。在加载和卸载模块时，必须显示这些信息。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>在Linux内核中，进程由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 描述。使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 或 <code class="docutils literal"><span class="pre">cscope</span></code> 来查找 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的定义。</li>
<li>要找到包含可执行文件名的结构字段，请查找“executable”的注释。</li>
<li>内核中给定时间运行的当前进程的结构指针由 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 变量（类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct*</span></code>）给出。</li>
</ul>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">要使用 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code>，你需要包含定义 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的头文件，即 <code class="docutils literal"><span class="pre">linux/sched.h</span></code>。</p>
</div>
<p>编译、复制、启动虚拟机并加载模块。卸载内核模块。</p>
<p>重复加载/卸载操作。注意显示的进程 PID 是不同的。这是因为在加载模块时，从可执行文件 <code class="file docutils literal"><span class="pre">/sbin/insmod</span></code> 创建了一个进程，而在卸载模块时，从可执行文件 <code class="file docutils literal"><span class="pre">/sbin/rmmod</span></code> 创建了一个进程。</p>
</div>
</div>
<div class="section" id="good-to-know-1">
<span id="good-to-know"></span><h2>Good to know<a class="headerlink" href="#good-to-know-1" title="Permalink to this headline">¶</a></h2>
<p>The following sections contain useful information for getitng used to the Linux
kernel code and debugging techniques.</p>
</div>
<div class="section" id="section-17">
<h2>源代码导航<a class="headerlink" href="#section-17" title="Permalink to this headline">¶</a></h2>
<div class="section" id="cscope">
<span id="cscope-intro"></span><h3>cscope<a class="headerlink" href="#cscope" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://cscope.sourceforge.net/">Cscope</a> 是一个用于高效导航 C 源代码的工具。要使用它，必须从现有的源代码生成一个 cscope 数据库。在 Linux 树中，执行命令 <strong class="command">make ARCH=x86 cscope</strong> 就足够了。通过 ARCH 变量指定架构不是必须的，但建议这样做；否则，一些依赖于架构的函数会在数据库中出现多次。</p>
<p>你可以使用命令 <strong class="command">make ARCH=x86 COMPILED_SOURCE=1 cscope</strong> 构建 cscope 数据库。这样，cscope 数据库中只包含在编译过程中已经使用过的符号（symbol），从而在搜索符号时可以获得更好的性能。</p>
<p>Cscope 也可以作为独立工具使用，但与编辑器结合使用时更加有用。要在 <strong class="command">vim</strong> 中使用 cscope，需要安装两个软件包，并在文件 <code class="file docutils literal"><span class="pre">.vimrc</span></code> 中添加以下几行（实验室中的机器已经进行了设置）：</p>
<div class="highlight-vim"><div class="highlight"><pre><span></span><span class="k">if</span> has<span class="p">(</span><span class="s2">&quot;cscope&quot;</span><span class="p">)</span>
<span class="c">        &quot; Look for a &#39;cscope.out&#39; file starting from the current directory,</span>
<span class="c">        &quot; going up to the root directory.</span>
        <span class="k">let</span> s:dirs <span class="p">=</span> split<span class="p">(</span>getcwd<span class="p">(),</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="k">while</span> s:dirs <span class="p">!=</span> []
                <span class="k">let</span> s:<span class="nb">path</span> <span class="p">=</span> <span class="s2">&quot;/&quot;</span> . <span class="k">join</span><span class="p">(</span>s:dirs<span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>filereadable<span class="p">(</span>s:<span class="nb">path</span> . <span class="s2">&quot;/cscope.out&quot;</span><span class="p">))</span>
                        execute <span class="s2">&quot;cs add &quot;</span> . s:<span class="nb">path</span> . <span class="s2">&quot;/cscope.out &quot;</span> . s:<span class="nb">path</span> . <span class="s2">&quot; -v&quot;</span>
                        <span class="k">break</span>
                <span class="k">endif</span>
                <span class="k">let</span> s:dirs <span class="p">=</span> s:dirs[:<span class="m">-2</span>]
        <span class="k">endwhile</span>

        <span class="k">set</span> <span class="nb">csto</span><span class="p">=</span><span class="m">0</span>  <span class="c">&quot; Use cscope first, then ctags</span>
        <span class="k">set</span> <span class="nb">cst</span>     <span class="c">&quot; Only search cscope</span>
        <span class="k">set</span> <span class="nb">csverb</span>  <span class="c">&quot; Make cs verbose</span>

        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`s :<span class="k">cs</span> find s `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">g</span> :<span class="k">cs</span> find <span class="k">g</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">c</span> :<span class="k">cs</span> find <span class="k">c</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">t</span> :<span class="k">cs</span> find <span class="k">t</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">e</span> :<span class="k">cs</span> find <span class="k">e</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">f</span> :<span class="k">cs</span> find <span class="k">f</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cfile&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">i</span> :<span class="k">cs</span> find <span class="k">i</span> ^`<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cfile&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>`$`<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">d</span> :<span class="k">cs</span> find <span class="k">d</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap <span class="p">&lt;</span>F6<span class="p">&gt;</span> :cnext <span class="p">&lt;</span>CR<span class="p">&gt;</span>
        nmap <span class="p">&lt;</span>F5<span class="p">&gt;</span> :cprev <span class="p">&lt;</span>CR<span class="p">&gt;</span>

<span class="c">        &quot; Open a quickfix window for the following queries.</span>
        <span class="k">set</span> <span class="nb">cscopequickfix</span><span class="p">=</span>s<span class="p">-,</span><span class="k">c</span><span class="p">-,</span><span class="k">d</span><span class="p">-,</span><span class="k">i</span><span class="p">-,</span><span class="k">t</span><span class="p">-,</span><span class="k">e</span><span class="p">-,</span><span class="k">g</span><span class="p">-</span>
<span class="k">endif</span>
</pre></div>
</div>
<p>脚本在当前目录或父目录中搜索名为 <code class="file docutils literal"><span class="pre">cscope.out</span></code> 的文件。如果 <strong class="command">vim</strong> 找到该文件，你可以使用快捷键 <code class="code docutils literal"><span class="pre">Ctrl</span> <span class="pre">+</span> <span class="pre">]</span></code> 或 <code class="code docutils literal"><span class="pre">Ctrl+\</span> <span class="pre">g`（按下</span> <span class="pre">control-\\</span> <span class="pre">然后按</span> <span class="pre">g）直接跳转到光标所在单词的定义（函数、变量、结构等）。类似地，你可以使用</span> <span class="pre">:code:`Ctrl+\</span> <span class="pre">s</span></code> 前往光标所在单词的使用位置。</p>
<p>你可以从以下网址获取一个启用了 cscope 的 <code class="file docutils literal"><span class="pre">.vimrc</span></code> 文件（还包含其他好用的东西）：<a class="reference external" href="https://github.com/ddvlad/cfg/blob/master/_vimrc">https://github.com/ddvlad/cfg/blob/master/_vimrc</a>。以下指南基于该文件，同时也展示了具有相同效果的基本 <strong class="command">vim</strong> 命令。</p>
<p>如果有多个结果（通常会有），你可以使用 <code class="code docutils literal"><span class="pre">F6</span></code> 和 <code class="code docutils literal"><span class="pre">F5</span></code> （<code class="code docutils literal"><span class="pre">:ccnext</span></code> 和 <code class="code docutils literal"><span class="pre">:cprev</span></code>）在它们之间切换。你还可以使用命令 <code class="code docutils literal"><span class="pre">:copen</span></code> 打开一个新的面板来显示结果。要关闭面板，可以使用 <code class="code docutils literal"><span class="pre">:cclose</span></code> 命令。</p>
<p>要返回到先前的位置，可以使用 <code class="code docutils literal"><span class="pre">Ctrl+o</span></code> （是字母 o，不是零）。该命令可以多次使用，即使 cscope 更改了你当前正在编辑的文件也有效。</p>
<p>要在 <strong class="command">vim</strong> 启动时直接跳转到符号定义，可以使用 <code class="code docutils literal"><span class="pre">vim</span> <span class="pre">-t</span> <span class="pre">&lt;symbol_name&gt;`（例如</span> <span class="pre">:code:`vim</span> <span class="pre">-t</span> <span class="pre">task_struct</span></code>）。如果你已经启动了 <strong class="command">vim</strong> 并想按名称搜索符号，可以使用 <code class="code docutils literal"><span class="pre">cs</span> <span class="pre">find</span> <span class="pre">g</span> <span class="pre">&lt;symbol_name&gt;</span></code> (例如 <code class="code docutils literal"><span class="pre">cs</span> <span class="pre">find</span> <span class="pre">g</span> <span class="pre">task_struct</span></code>)。</p>
<p>如果你找到了多个结果，并且用 <code class="code docutils literal"><span class="pre">:copen</span></code> 命令打开了一个显示所有匹配项的面板，如果你想在面板中找到一种结构类型的符号，建议你用 <code class="code docutils literal"><span class="pre">/</span></code> ——斜杠命令在面板中搜索字符 <code class="code docutils literal"><span class="pre">{</span></code> （左花括号）。</p>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>你可以使用命令 <strong class="command">:cs help</strong> 获取所有 <strong class="command">cscope</strong> 命令的摘要。</p>
<p class="last">若要了解更多信息，请使用 <strong class="command">vim</strong> 内置的帮助命令：<strong class="command">:h cscope</strong> 或 <strong class="command">:h copen</strong>。</p>
</div>
<p>如果你使用 <strong class="command">emacs</strong>，请安装 <strong class="command">xcscope-el</strong> 包，并在 <code class="file docutils literal"><span class="pre">~/.emacs</span></code> 文件中添加以下行。</p>
<div class="highlight-vim"><div class="highlight"><pre><span></span><span class="p">(</span>require ‘xcscope<span class="p">)</span>
<span class="p">(</span><span class="k">cscope</span><span class="p">-</span>setup<span class="p">)</span>
</pre></div>
</div>
<p>这些命令将自动为 C 和 C++ 模式激活 cscope。<code class="code docutils literal"><span class="pre">C-s</span> <span class="pre">s</span></code> 是按键绑定前缀，<code class="code docutils literal"><span class="pre">C-s</span> <span class="pre">s</span> <span class="pre">s</span></code> 用于搜索符号（如果光标位置在单词上，调用它时将使用该位置的单词）。有关详细信息，请查看 <cite>https://github.com/dkogan/xcscope.el</cite>。</p>
</div>
<div class="section" id="clangd">
<h3>clangd<a class="headerlink" href="#clangd" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://clangd.llvm.org/">Clangd</a> 是一个语言服务器，提供了一些用于浏览 C 和 C++ 代码的工具。<a class="reference external" href="https://microsoft.github.io/language-server-protocol/">语言服务器协议</a> 利用语义全项目分析，实现了诸如跳转到定义、查找引用、悬停提示、代码补全等功能。</p>
<p>Clangd 需要一个编译数据库来理解内核源代码。可以通过以下方式生成编译数据库：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>make defconfig
make
scripts/clang-tools/gen_compile_commands.py
</pre></div>
</div>
<p>LSP 客户端：</p>
<ul class="simple">
<li>Vim/Neovim（ <a class="reference external" href="https://github.com/neoclide/coc.nvim">coc.nvim</a>、 <a class="reference external" href="https://github.com/neovim/nvim-lspconfig">nvim-lsp</a>、 <a class="reference external" href="https://github.com/natebosch/vim-lsc">vim-lsc</a> 以及 <a class="reference external" href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a> ）</li>
<li>Emacs（ <a class="reference external" href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> ）</li>
<li>VSCode（ <a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd extension</a> ）</li>
</ul>
</div>
<div class="section" id="kscope">
<h3>Kscope<a class="headerlink" href="#kscope" title="Permalink to this headline">¶</a></h3>
<p>如果想要一个更简单的界面的话，可以尝试 Kscope。<a class="reference external" href="http://sourceforge.net/projects/kscope/">Kscope</a> 是一个使用 QT 的 cscope 前端。它轻便、快速、易用。它支持使用正则表达式、调用图等方式进行搜索。Kscope 已经停止维护了。</p>
<p>还有一个适用于 Qt4 和 KDE 4 的 <a class="reference external" href="https///opendesktop.org/content/show.php/Kscope4?content=156987">移植版本</a> ，其保留了与文本编辑器 Kate 的集成，并且比 SourceForge 上的最新版本更易于使用。</p>
</div>
<div class="section" id="lxr-cross-reference">
<h3>LXR Cross-Reference<a class="headerlink" href="#lxr-cross-reference" title="Permalink to this headline">¶</a></h3>
<p>LXR（LXR Cross-Reference）是一种工具，允许使用 Web 界面来索引和引用程序源代码中的符号。Web 界面显示了符号在文件中定义或使用的位置的链接。LXR 的开发网站是 <a class="reference external" href="http://sourceforge.net/projects/lxr">http://sourceforge.net/projects/lxr</a>。类似的工具有 <a class="reference external" href="http://oracle.github.io/opengrok/">OpenGrok</a> 和 <a class="reference external" href="http://en.wikipedia.org/wiki/Gonzui">Gonzui</a>。</p>
<p>尽管 LXR 最初是用于 Linux 内核源代码的，但也用于 <a class="reference external" href="http://lxr.mozilla.org/">Mozilla</a>、 <a class="reference external" href="http://apache.wirebrain.de/lxr/">Apache HTTP 服务器</a> 和 <a class="reference external" href="http://lxr.linux.no/freebsd/source">FreeBSD</a> 的源代码。</p>
<p>有许多网站使用 LXR 来进行 Linux 内核源代码的交叉引用，主要网站是 <a class="reference external" href="http://lxr.linux.no/linux/">开发原址</a>，然而该网站已不再运作。你可以使用 <a class="reference external" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a>。</p>
<p>LXR 允许在任意文本或文件名上搜索标识符（符号）。它提供的主要特点和优势是可以轻松地找到任何全局标识符的声明。这样，它便于快速访问函数声明、变量、宏定义，以及轻松地浏览代码。此外，它还能够检测当变量或函数发生变化时，哪些代码区域会受到影响，这对于开发和调试阶段是一个真正的优势。</p>
</div>
<div class="section" id="sourceweb">
<h3>SourceWeb<a class="headerlink" href="#sourceweb" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="http://rprichard.github.io/sourceweb/">SourceWeb</a> 是一个用于 C 和 C++ 的源代码索引器。它使用 Clang 编译器提供的 <a class="reference external" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">框架</a> 来索引代码。</p>
<p>cscope 和 SourceWeb 之间的主要区别在于，SourceWeb 在某种程度上是一个编译器插件。SourceWeb 不会索引所有的代码，而只会索引实际被编译器编译的代码。这样的话，一些问题就没有了，例如在多个位置定义的函数变体中的的哪个被使用的歧义。这也意味着索引需要更多的时间，因为编译后的文件必须再次通过索引器以生成引用。</p>
<p>使用示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>make oldconfig
sw-btrace make -j4
sw-btrace-to-compile-db
sw-clang-indexer --index-project
sourceweb index
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">sw-btrace</span></code> 是一个添加 <code class="file docutils literal"><span class="pre">libsw-btrace.so</span></code> 库到 <code class="code docutils literal"><span class="pre">LD_PRELOAD</span></code> 的脚本。这样，该库将被 <code class="code docutils literal"><span class="pre">make</span></code> 启动的每个进程（基本上是编译器）加载， 注册用于启动进程的命令，并生成一个名为 <code class="file docutils literal"><span class="pre">btrace.log</span></code> 的文件。然后，<code class="code docutils literal"><span class="pre">sw-btrace-to-compile-db</span></code> 使用该文件将其转换为 clang 定义的格式： <a class="reference external" href="http://clang.llvm.org/docs/JSONCompilationDatabase.html">JSON Compilation Database</a> 。 然后上述步骤生成的 JSON 编译数据库由索引器使用，索引器通过已编译的源文件再进行一次遍历，生成 GUI 使用的索引。</p>
<p>建议：不要对正在使用的源代码进行索引，而是使用其副本，因为 SourceWeb 目前没有单独重新生成单个文件的索引的功能，你将不得不重新生成完整的索引。</p>
</div>
</div>
<div class="section" id="section-18">
<h2>内核调试<a class="headerlink" href="#section-18" title="Permalink to this headline">¶</a></h2>
<p>与调试程序相比，调试内核是一个更加困难的过程，因为操作系统没有提供支持。这就是为什么通常使用两台通过串行接口相互连接的计算机进行此过程。</p>
<div class="section" id="gdb-linux">
<span id="gdb-intro"></span><h3>gdb（Linux）<a class="headerlink" href="#gdb-linux" title="Permalink to this headline">¶</a></h3>
<p>在 Linux 上，一种更简单但也具有许多缺点的调试方法是使用 <a class="reference external" href="http://www.gnu.org/software/gdb/">gdb</a> 进行本地调试，其中涉及到未压缩的内核镜像（<code class="file docutils literal"><span class="pre">vmlinux</span></code> ）和文件：<code class="file docutils literal"><span class="pre">/proc/kcore</span></code> （实时内核镜像）。这种方法通常用于检查内核并在其运行时检测特定的不一致性。特别是如果内核是使用 <code class="code docutils literal"><span class="pre">-g</span></code> 选项编译的（该选项会保留调试信息）这种方法就非常有用。但是，这种方法无法使用一些众所周知的调试技术，例如数据修改的断点。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>因为 <code class="file docutils literal"><span class="pre">/proc</span></code> 是一个虚拟文件系统，<code class="file docutils literal"><span class="pre">/proc/kcore</span></code> 在磁盘上并不存在。当程序尝试访问 <code class="file docutils literal"><span class="pre">/proc/kcore</span></code> 时，内核会即时生成它。它用于调试目的。</p>
<p>根据 <strong class="command">man proc</strong> 的说明：</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>/proc/kcore
此文件代表系统的物理内存，并以 ELF 核心文件格式存储。借助这个伪文件（pseudo-file）和未剥离（unstripped）的内核（/usr/src/linux/vmlinux）二进制文件，可以使用 GDB 来检查任何内核数据结构的当前状态。
</pre></div>
</div>
</div>
<p>未压缩的内核镜像提供关于其中所包含的数据结构和符号的信息。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ <span class="nb">cd</span> ~/src/linux
student@eg106$ file vmlinux
vmlinux: ELF <span class="m">32</span>-bit LSB executable, Intel <span class="m">80386</span>, ...
student@eg106$ nm vmlinux <span class="p">|</span> grep sys_call_table
c02e535c R sys_call_table
student@eg106$ cat System.map <span class="p">|</span> grep sys_call_table
c02e535c R sys_call_table
</pre></div>
</div>
<p><strong class="command">nm</strong> 程序用于显示对象或可执行文件中的符号。在我们的例子中，<code class="file docutils literal"><span class="pre">vmlinux</span></code> 是一个 ELF 文件。或者，我们可以使用文件 <code class="file docutils literal"><span class="pre">System.map</span></code> 来查看内核中的符号信息。</p>
<p>然后，我们使用 <strong class="command">gdb</strong> 来使用未压缩的内核镜像检查这些符号。一个简单的 <strong class="command">gdb</strong> 会话如下所示：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ <span class="nb">cd</span> ~/src/linux
stduent@eg106$ gdb --quiet vmlinux
Using host libthread_db library <span class="s2">&quot;/lib/tls/libthread_db.so.1&quot;</span>.
<span class="o">(</span>gdb<span class="o">)</span> x/x 0xc02e535c
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58
<span class="o">(</span>gdb<span class="o">)</span> x/16 0xc02e535c
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sb">`</span>&lt;sys_call_table+16&gt;<span class="sb">`</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sb">`</span>&lt;sys_call_table+32&gt;<span class="sb">`</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sb">`</span>&lt;sys_call_table+48&gt;<span class="sb">`</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="o">(</span>gdb<span class="o">)</span> x/x sys_call_table
0xc011bc58 <span class="sb">`</span>&lt;sys_restart_syscall&gt;<span class="sb">`</span>:       0xffe000ba
<span class="o">(</span>gdb<span class="o">)</span> x/x <span class="p">&amp;</span>sys_call_table
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58
<span class="o">(</span>gdb<span class="o">)</span> x/16 <span class="p">&amp;</span>sys_call_table
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sb">`</span>&lt;sys_call_table+16&gt;<span class="sb">`</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sb">`</span>&lt;sys_call_table+32&gt;<span class="sb">`</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sb">`</span>&lt;sys_call_table+48&gt;<span class="sb">`</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="o">(</span>gdb<span class="o">)</span> x/x sys_fork
0xc01013d3 <span class="sb">`</span>&lt;sys_fork&gt;<span class="sb">`</span>:  0x3824548b
<span class="o">(</span>gdb<span class="o">)</span> disass sys_fork
Dump of assembler code <span class="k">for</span> <span class="k">function</span> sys_fork:
0xc01013d3 <span class="sb">`</span>&lt;sys_fork+0&gt;<span class="sb">`</span>:        mov    0x38<span class="o">(</span>%esp<span class="o">)</span>,%edx
0xc01013d7 <span class="sb">`</span>&lt;sys_fork+4&gt;<span class="sb">`</span>:        mov    <span class="nv">$0</span>x11,%eax
0xc01013dc <span class="sb">`</span>&lt;sys_fork+9&gt;<span class="sb">`</span>:        push   <span class="nv">$0</span>x0
0xc01013de <span class="sb">`</span>&lt;sys_fork+11&gt;<span class="sb">`</span>:       push   <span class="nv">$0</span>x0
0xc01013e0 <span class="sb">`</span>&lt;sys_fork+13&gt;<span class="sb">`</span>:       push   <span class="nv">$0</span>x0
0xc01013e2 <span class="sb">`</span>&lt;sys_fork+15&gt;<span class="sb">`</span>:       lea    0x10<span class="o">(</span>%esp<span class="o">)</span>,%ecx
0xc01013e6 <span class="sb">`</span>&lt;sys_fork+19&gt;<span class="sb">`</span>:       call   0xc0111aab <span class="sb">`</span>&lt;do_fork&gt;<span class="sb">`</span>
0xc01013eb <span class="sb">`</span>&lt;sys_fork+24&gt;<span class="sb">`</span>:       add    <span class="nv">$0</span>xc,%esp
0xc01013ee <span class="sb">`</span>&lt;sys_fork+27&gt;<span class="sb">`</span>:       ret
End of assembler dump.
</pre></div>
</div>
<p>可以注意到未压缩的内核映像被用作 <strong class="command">gdb</strong> 的参数。在编译后，可以在内核源代码的根目录中找到该映像。</p>
<p>使用 <strong class="command">gdb</strong> 进行调试的几个命令如下：</p>
<ul class="simple">
<li><strong class="command">x</strong> （examine）——用于显示指定地址的内存区域的内容（该地址可以是物理地址的值、符号或符号的地址）。它可以接受以下参数（以 <code class="code docutils literal"><span class="pre">/</span></code> 开头）：要显示数据的格式（<code class="code docutils literal"><span class="pre">x</span></code> 表示十六进制，<code class="code docutils literal"><span class="pre">d</span></code> 表示十进制，等等）、要显示的内存单元（memory unit）数量以及单个内存单元的大小。</li>
<li><strong class="command">disassemble</strong> ——用于反汇编函数。</li>
<li><strong class="command">p</strong> （print）——用于评估并显示表达式的值。可以通过参数指定要显示数据的格式（<code class="code docutils literal"><span class="pre">/x</span></code> 表示十六进制，<code class="code docutils literal"><span class="pre">/d</span></code> 表示十进制，等等）。</li>
</ul>
<p>对内核映像的分析是一种静态分析方法。如果我们想进行动态分析（分析内核的运行情况，而不仅仅是静态映像），我们可以使用 <code class="file docutils literal"><span class="pre">/proc/kcore</span></code>；这是内核的动态映像（存储在内存中）。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ gdb ~/src/linux/vmlinux /proc/kcore
Core was generated by `root=/dev/hda3 ro&#39;.
#0  0x00000000 in ?? ()
(gdb) p sys_call_table
$1 = -1072579496
(gdb) p /x sys_call_table
$2 = 0xc011bc58
(gdb) p /x &amp;sys_call_table
$3 = 0xc02e535c
(gdb) x/16 &amp;sys_call_table
0xc02e535c `&lt;sys_call_table&gt;`:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c `&lt;sys_call_table+16&gt;`: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c `&lt;sys_call_table+32&gt;`: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c `&lt;sys_call_table+48&gt;`: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
</pre></div>
</div>
<p>使用内核的动态镜像有助于检测 <a class="reference external" href="http://zh.wikipedia.org/wiki/Rootkit">rootkit</a> 。</p>
<ul class="simple">
<li><a class="reference external" href="http://linuxdriver.co.il/ldd3/linuxdrive3-CHP-4-SECT-6.html">Linux设备驱动程序第 3 版——调试器和相关工具</a></li>
<li><a class="reference external" href="http://www.securityfocus.com/infocus/1811">在 Linux 中检测 Rootkit 和内核级入侵</a></li>
<li><a class="reference external" href="http://user-mode-linux.sf.net/">用户模式 Linux</a></li>
</ul>
</div>
<div class="section" id="section-19">
<h3>获取堆栈跟踪<a class="headerlink" href="#section-19" title="Permalink to this headline">¶</a></h3>
<p>有时，你需要获取有关执行路径到达某个特定点的信息。你可以使用 <strong class="command">cscope</strong> 或 LXR 来确定这些信息，但某些函数从许多执行路径调用，这使得这种方法变得困难。</p>
<p>在这些情况下，使用函数 <code class="code docutils literal"><span class="pre">dump_stack()</span></code> 获取堆栈跟踪非常有用。</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="lec12-virtualization.html" class="btn btn-neutral float-left" title="SO2 Lecture 12 - Virtualization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="lab2-kernel-api.html" class="btn btn-neutral float-right" title="SO2 Lab 02 - Kernel API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>