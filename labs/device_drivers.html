<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>字符设备驱动程序 &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh-CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="I/O 访问和中断" href="interrupts.html" />
    <link rel="prev" title="内核 API" href="kernel_api.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">Operating Systems 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">内核 API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">字符设备驱动程序</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-2">实验目标</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-3">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-4">主设备号和次设备号</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-5">字符设备的数据结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#struct-file-operations"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#inode-file"><code class="docutils literal"><span class="pre">inode</span></code> 和 <code class="docutils literal"><span class="pre">file</span></code> 结构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-6">实现操作</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-7">字符设备的注册和注销</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-8">访问进程地址空间</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-9">打开和释放</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-10">读取和写入</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ioctl-1">ioctl</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-11">等待队列</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-12">练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-13">0. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-14">1. 注册/注销</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-15">2. 注册一个已注册的主设备号</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-16">3. 打开和关闭</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-17">4. 访问限制</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-18">5. 读操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-19">6. 写操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ioctl-2">7. ioctl 操作</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-20">额外练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ioctl-3">带消息的 ioctl</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ioctl-4">使用等待队列的 ioctl</a></li>
<li class="toctree-l3"><a class="reference internal" href="#o-nonblock">O_NONBLOCK 实现</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">字符设备驱动程序</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/device_drivers.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="section-1">
<h1>字符设备驱动程序<a class="headerlink" href="#section-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="section-2">
<h2>实验目标<a class="headerlink" href="#section-2" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>理解字符设备驱动程序背后的概念</li>
<li>理解可以在字符设备上执行的各种操作</li>
<li>使用等待队列进行工作</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-3">
<h2>概述<a class="headerlink" href="#section-3" title="Permalink to this headline">¶</a></h2>
<p>在 UNIX 系统中，用户通过特殊的设备文件访问硬件设备。这些文件被组织在 /dev 目录下，并且操作系统会将对这些文件的系统调用（如 <code class="docutils literal"><span class="pre">open</span></code>、 <code class="docutils literal"><span class="pre">read</span></code>、  <code class="docutils literal"><span class="pre">write</span></code>、 <code class="docutils literal"><span class="pre">close</span></code>、 <code class="docutils literal"><span class="pre">lseek</span></code>、 <code class="docutils literal"><span class="pre">mmap</span></code> 等），重定向到与物理设备关联的设备驱动程序。设备驱动程序是与硬件设备交互的内核组件（通常是一个模块）。</p>
<p>在 UNIX 世界中，设备文件和设备驱动程序分为两个类别：字符设备和块设备。这种划分是根据数据传输的速度、容量和数据组织方式进行的。第一类是一些速度较慢的设备，它们仅处理少量数据，并且对数据的访问不需要频繁的搜索查询，例如键盘、鼠标、串口、声卡、游戏手柄等设备。通常情况下，对这些设备（读取、写入）的操作是按字节顺序逐个执行的。第二类包括数据量大、数据以块为单位组织且搜索频繁的设备。这一类别的设备包括硬盘、光驱、RAM 磁盘以及磁带驱动器等。这些设备的读取和写入是以数据块为单位进行的。</p>
<p>对于这两种类型的设备驱动程序，Linux 内核提供了不同的 API。如果是字符设备，系统调用直接传递给设备驱动程序；而如果是块设备，驱动程序不能直接与系统调用交互。用户空间和块设备驱动程序之间的通信是通过文件管理子系统和块设备子系统进行的。这些子系统的作用是准备设备驱动程序所需的资源（缓冲区），将最近读取的数据保存在缓存缓冲区中，并为了提升性能而对读取和写入操作进行排序。</p>
</div>
<div class="section" id="section-4">
<h2>主设备号和次设备号<a class="headerlink" href="#section-4" title="Permalink to this headline">¶</a></h2>
<p>在 UNIX 中，设备通常有一个唯一的、固定的标识符与之关联。这种传统在 Linux 中得以保留，尽管标识符可以动态分配（出于兼容性的原因，大多数驱动程序仍然使用静态标识符）。这个标识符由两部分组成：主设备号（major）和次设备号（minor）。第一部分用于标识设备类型（如 IDE 硬盘、SCSI 硬盘、串口等），而第二部分用于标识设备本身（如第一个硬盘、第二个串口等）。大多数情况下，主设备号用于标识驱动程序，而次设备号用于标识驱动程序所服务的某个物理设备。通常情况下，一个驱动程序会有一个关联的主设备号，并负责处理与该主设备号关联的所有次设备号。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ ls -la /dev/hda? /dev/ttyS?
brw-rw----  <span class="m">1</span> root disk    <span class="m">3</span>,  <span class="m">1</span> <span class="m">2004</span>-09-18 <span class="m">14</span>:51 /dev/hda1
brw-rw----  <span class="m">1</span> root disk    <span class="m">3</span>,  <span class="m">2</span> <span class="m">2004</span>-09-18 <span class="m">14</span>:51 /dev/hda2
crw-rw----  <span class="m">1</span> root dialout <span class="m">4</span>, <span class="m">64</span> <span class="m">2004</span>-09-18 <span class="m">14</span>:52 /dev/ttyS0
crw-rw----  <span class="m">1</span> root dialout <span class="m">4</span>, <span class="m">65</span> <span class="m">2004</span>-09-18 <span class="m">14</span>:52 /dev/ttyS1
</pre></div>
</div>
<p>如上例所示，可以使用 ls 命令找到设备类型信息。特殊字符文件在命令输出的第一列中通过字符 <code class="docutils literal"><span class="pre">c</span></code> 进行标识，块类型则通过字符 <code class="docutils literal"><span class="pre">b</span></code> 进行标识。在结果的第 <code class="docutils literal"><span class="pre">5</span></code> 和第 <code class="docutils literal"><span class="pre">6</span></code> 列中，可以看到每个设备的主设备号和次设备号。</p>
<p>某些主设备号是静态分配给设备的（可以在内核源代码的 <code class="docutils literal"><span class="pre">Documentation/admin-guide/devices.txt</span></code> 文件中查看）。选择新设备的标识符时，你可以使用两种方法：静态方法（选择一个尚未被使用的数字）或动态方法。/proc/devices 目录中列出了已加载的设备，以及其主设备号。</p>
<p>要创建设备类型文件，请使用 <code class="docutils literal"><span class="pre">mknod</span></code> 命令；该命令的参数为设备的类型 (<code class="docutils literal"><span class="pre">block</span></code> 或 <code class="docutils literal"><span class="pre">character</span></code>)、主设备号和次设备号 (<code class="docutils literal"><span class="pre">mknod</span> <span class="pre">name</span> <span class="pre">type</span> <span class="pre">major</span> <span class="pre">minor</span></code>)。因此，要想创建一个名为 <code class="docutils literal"><span class="pre">mycdev</span></code>、主设备号为 <code class="docutils literal"><span class="pre">42</span></code>、次设备号为 <code class="docutils literal"><span class="pre">0</span></code> 的字符设备，可以使用以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># mknod /dev/mycdev c 42 0</span>
</pre></div>
</div>
<p>要创建名为 <code class="docutils literal"><span class="pre">mybdev</span></code>、主设备号为 <code class="docutils literal"><span class="pre">240</span></code> 并且次设备号为 <code class="docutils literal"><span class="pre">0</span></code> 的块设备，请使用如下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># mknod /dev/mybdev b 240 0</span>
</pre></div>
</div>
<p>接下来，我们会把字符设备称为驱动程序。</p>
</div>
<div class="section" id="section-5">
<h2>字符设备的数据结构<a class="headerlink" href="#section-5" title="Permalink to this headline">¶</a></h2>
<p>在内核中，字符设备由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">cdev</span></code> 结构表示，该结构用于在系统中注册字符设备。大多数驱动程序操作都用到了三个重要的结构: <code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code>、 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code> 和 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">inode</span></code>。</p>
<div class="section" id="struct-file-operations">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code><a class="headerlink" href="#struct-file-operations" title="Permalink to this headline">¶</a></h3>
<p>如上所述，字符设备驱动程序接收用户对设备类型文件的原始系统调用。因此，要想实现字符设备驱动程序，我们就需要实现特定于文件的系统调用，例如 <code class="docutils literal"><span class="pre">open</span></code>、 <code class="docutils literal"><span class="pre">close</span></code>、 <code class="docutils literal"><span class="pre">read</span></code>、 <code class="docutils literal"><span class="pre">write</span></code>、 <code class="docutils literal"><span class="pre">lseek</span></code> 以及 <code class="docutils literal"><span class="pre">mmap</span></code> 等。这些操作在 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code> 结构的字段中描述：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
    <span class="n">loff_t</span> <span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
    <span class="p">[...]</span>
    <span class="kt">long</span> <span class="p">(</span><span class="o">*</span><span class="n">unlocked_ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="p">[...]</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">);</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
    <span class="p">[...]</span>
</pre></div>
</div>
<p>可以看出，函数的签名与用户使用的系统调用不同。操作系统位于用户和设备驱动程序之间，其简化了设备驱动程序的实现。</p>
<p><code class="docutils literal"><span class="pre">open</span></code> 函数不接收参数路径或控制文件打开模式的各种参数。同样， <code class="docutils literal"><span class="pre">read</span></code>、 <code class="docutils literal"><span class="pre">write</span></code>、 <code class="docutils literal"><span class="pre">release</span></code>、 <code class="docutils literal"><span class="pre">ioctl</span></code>、 <code class="docutils literal"><span class="pre">lseek</span></code> 的参数也不包括文件描述符。相反，这些例程接收两个结构作为参数： <code class="docutils literal"><span class="pre">file</span></code> 和 <code class="docutils literal"><span class="pre">inode</span></code>。这两个结构都从不同的角度表示文件。</p>
<dl class="docutils">
<dt>所提供操作的大多数参数具有直接的含义：</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">file</span></code> 和 <code class="docutils literal"><span class="pre">inode</span></code> 标识设备类型文件；</li>
<li><code class="docutils literal"><span class="pre">size</span></code> 是要读取或写入的字节数；</li>
<li><code class="docutils literal"><span class="pre">offset</span></code> 是要读取或写入的位移（将相应地更新）；</li>
<li><code class="docutils literal"><span class="pre">user_buffer</span></code> 是要读取/写入的用户缓冲区；</li>
<li><code class="docutils literal"><span class="pre">whence</span></code> 是寻找的方式（搜索操作开始的位置）；</li>
<li><code class="docutils literal"><span class="pre">cmd</span></code> 和 <code class="docutils literal"><span class="pre">arg</span></code> 是由用户发送到 ioctl（IO 控制）调用的参数。</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="inode-file">
<h3><code class="docutils literal"><span class="pre">inode</span></code> 和 <code class="docutils literal"><span class="pre">file</span></code> 结构<a class="headerlink" href="#inode-file" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">inode</span></code> 代表文件系统视角中的文件。inode 的属性包括文件大小、权限和相关时间。单个 inode 在文件系统中唯一标识一个文件。</p>
<p><code class="docutils literal"><span class="pre">file</span></code> 结构仍然代表单个文件，但更接近用户的视角。file 结构的属性中，有 inode、文件名、文件打开属性和文件位置等。在给定时间内，所有打开的文件都有一个关联的 <code class="docutils literal"><span class="pre">file</span></code> 结构。</p>
<p>为了更好的理解 inode 和 file 之间的区别，我们可以使用面向对象编程的类比：如果我们将 inode 视为一个类，那么文件就是对象，即 inode 类的实例。inode 表示文件的静态映像（inode 没有状态），而 file 表示文件的动态映像（file 具有状态）。</p>
<p>回到设备驱动程序，这两个实体几乎总是有标准的使用方式：inode 用于确定操作执行的设备的主设备号和次设备号，而 file 用于确定文件的打开标志，还可以保存和（稍后）访问私有数据。</p>
<p>file 结构包含许多字段，其中包括：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">f_mode</span></code>，指定是读取 (<code class="docutils literal"><span class="pre">FMODE_READ</span></code>) 还是写入 (<code class="docutils literal"><span class="pre">FMODE_WRITE</span></code>)；</li>
<li><code class="docutils literal"><span class="pre">f_flags</span></code>，指定文件的打开标志 (<code class="docutils literal"><span class="pre">O_RDONLY</span></code>、 <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code>、 <code class="docutils literal"><span class="pre">O_SYNC</span></code>、 <code class="docutils literal"><span class="pre">O_APPEND</span></code>、 <code class="docutils literal"><span class="pre">O_TRUNC</span></code> 等)；</li>
<li><code class="docutils literal"><span class="pre">f_op</span></code>，指定与文件关联的操作（指向 <code class="docutils literal"><span class="pre">file_operations</span></code> 结构的指针）；</li>
<li><code class="docutils literal"><span class="pre">private_data</span></code>，一个指针，程序员可以用来存储特定于设备的数据；该指针将被初始化到程序员分配的内存位置。</li>
<li><code class="docutils literal"><span class="pre">f_pos</span></code>，文件内的偏移量。</li>
</ul>
</div></blockquote>
<p>inode 结构包含许多信息，其中包括一个 <code class="docutils literal"><span class="pre">i_cdev</span></code> 字段，它是一个指向定义字符设备的结构的指针（如果 inode 对应于字符设备）。</p>
</div>
</div>
<div class="section" id="section-6">
<h2>实现操作<a class="headerlink" href="#section-6" title="Permalink to this headline">¶</a></h2>
<p>为了实现设备驱动程序，建议创建一个包含有关设备信息和模块使用的信息的结构体。如果是字符设备驱动程序，则结构体将包含一个指向设备的 cdev 结构体字段。下面的示例使用了名为 my_device_data 的结构体：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">my_device_data</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
    <span class="cm">/* 数据从这里开始 */</span>
    <span class="c1">//...</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span><span class="p">;</span>

    <span class="n">my_data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">my_device_data</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>

    <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buffer</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span><span class="p">;</span>

    <span class="n">my_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>名为 <code class="docutils literal"><span class="pre">my_device_data</span></code> 的结构包含与设备相关的数据。<code class="docutils literal"><span class="pre">cdev</span></code> 字段 (<code class="docutils literal"><span class="pre">cdev</span></code> 类型)对应字符设备，用于在系统中记录和识别设备。可以使用 <code class="docutils literal"><span class="pre">inode</span></code> 结构的 <code class="docutils literal"><span class="pre">i_cdev</span></code> 字段（使用 <code class="docutils literal"><span class="pre">container_of</span></code> 宏）找到指向 <code class="docutils literal"><span class="pre">cdev</span></code> 的指针。可以在打开文件时，在 file 结构的 <code class="docutils literal"><span class="pre">private_data</span></code> 字段中存储可用于 <code class="docutils literal"><span class="pre">read</span></code>、 <code class="docutils literal"><span class="pre">write</span></code>、 <code class="docutils literal"><span class="pre">release</span></code> 等函数的信息。</p>
</div>
<div class="section" id="section-7">
<h2>字符设备的注册和注销<a class="headerlink" href="#section-7" title="Permalink to this headline">¶</a></h2>
<p>要想注册和注销设备，你需要指定主设备号和次设备号。<code class="docutils literal"><span class="pre">dev_t</span></code> 类型用于保存设备的标识符（包括主设备号和次设备号），其可以通过使用 <cite>MKDEV</cite> 宏来获取。</p>
<p>要想完成设备标识符的静态分配和释放，可以使用 <code class="docutils literal"><span class="pre">register_chrdev_region</span></code> 和 <code class="docutils literal"><span class="pre">unregister_chrdev_region</span></code> 函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">register_chrdev_region</span><span class="p">(</span><span class="kt">dev_t</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">unregister_chrdev_region</span><span class="p">(</span><span class="kt">dev_t</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></div>
</div>
<p>建议将设备标识符动态分配给 <code class="docutils literal"><span class="pre">alloc_chrdev_region</span></code> 函数。</p>
<p>以下程序准备了 <code class="docutils literal"><span class="pre">my_minor_count</span></code> 个设备，从 <code class="docutils literal"><span class="pre">my_major</span></code> 主设备号和 <code class="docutils literal"><span class="pre">my_first_minor</span></code> 次设备号开始（如果次设备号的最大值溢出了，就会切换到下一个主设备号）：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="p">...</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">my_major</span><span class="p">,</span> <span class="n">my_first_minor</span><span class="p">),</span> <span class="n">my_minor_count</span><span class="p">,</span>
                             <span class="s">&quot;my_device_driver&quot;</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 报告错误 */</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>在分配标识符之后，字符设备需要进行初始化（使用 <code class="docutils literal"><span class="pre">cdev_init</span></code> 函数），并通知内核（使用 <code class="docutils literal"><span class="pre">cdev_add</span></code> 函数）。只有在设备准备好接收调用时才能调用 <code class="docutils literal"><span class="pre">cdev_add</span></code> 函数。使用 <code class="docutils literal"><span class="pre">cdev_del</span></code> 函数可以移除设备。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">cdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cdev_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">dev_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cdev_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<p>以下程序注册并初始化 MY_MAX_MINORS 个设备：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_MAJOR       42</span>
<span class="cp">#define MY_MAX_MINORS  5</span>

<span class="k">struct</span> <span class="n">my_device_data</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
    <span class="cm">/* 数据从这里开始 */</span>
    <span class="c1">//...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">my_device_data</span> <span class="n">devs</span><span class="p">[</span><span class="n">MY_MAX_MINORS</span><span class="p">];</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">my_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">my_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">my_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">my_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_release</span><span class="p">,</span>
    <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">my_ioctl</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">init_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

    <span class="n">err</span> <span class="o">=</span> <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">MY_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">MY_MAX_MINORS</span><span class="p">,</span>
                                 <span class="s">&quot;my_device_driver&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 报告错误 */</span>
        <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MY_MAX_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 初始化 devs[i] 字段 */</span>
        <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_fops</span><span class="p">);</span>
        <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cdev</span><span class="p">,</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">MY_MAJOR</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下代码删除并注销它们：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">cleanup_module</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MY_MAX_MINORS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 释放 devs[i] 字段 */</span>
        <span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">cdev</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">MKDEV</span><span class="p">(</span><span class="n">MY_MAJOR</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">MY_MAX_MINORS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal"><span class="pre">my_fops</span></code> 结构的初始化使用了 C99 标准中的按名称初始化成员的方法（参见指定初始化器和 file_operations 结构）。未在此初始化中显式出现的结构成员将被设置为其类型的默认值。例如，在上述初始化之后，<code class="docutils literal"><span class="pre">my_fops.mmap</span></code> 将为 NULL。</p>
</div>
</div>
<div class="section" id="section-8">
<span id="access-to-process-address-space"></span><h2>访问进程地址空间<a class="headerlink" href="#section-8" title="Permalink to this headline">¶</a></h2>
<p>设备的驱动程序是应用程序与硬件之间的接口。因此，我们经常需要访问用户空间数据。直接访问用户空间数据是不可行的（通过解引用用户空间指针）。直接访问用户空间指针可能导致不正确的行为（根据体系结构，用户空间指针可能无效或映射到内核空间）、内核 oops（用户态指针可能引用非驻留内存区域）或安全问题。请通过调用下面的宏/函数来正确访问用户空间数据：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/uaccess.h&gt;</span><span class="cp"></span>

<span class="n">put_user</span><span class="p">(</span><span class="n">type</span> <span class="n">val</span><span class="p">,</span> <span class="n">type</span> <span class="o">*</span><span class="n">address</span><span class="p">);</span>
<span class="n">get_user</span><span class="p">(</span><span class="n">type</span> <span class="n">val</span><span class="p">,</span> <span class="n">type</span> <span class="o">*</span><span class="n">address</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<p>这些宏/函数成功后返回 0，错误时返回其他值，并具有以下作用：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">put_user</span></code> 将值 <code class="docutils literal"><span class="pre">val</span></code> 存储到用户空间地址 <code class="docutils literal"><span class="pre">address</span></code>；类型可以是 8 位、16 位、32 位，也可以是 64 位（最大的支持类型取决于硬件平台）；</li>
<li><code class="docutils literal"><span class="pre">get_user</span></code> 类似于前一个函数，只是将值设置为与用户空间地址 <code class="docutils literal"><span class="pre">address</span></code> 处的值相同的值；</li>
<li><code class="docutils literal"><span class="pre">copy_to_user</span></code> 从 <code class="docutils literal"><span class="pre">from</span></code> 引用的内核空间地址开始复制 <code class="docutils literal"><span class="pre">n</span></code> 字节到由 <code class="docutils literal"><span class="pre">to</span></code> 引用的用户空间地址；</li>
<li><code class="docutils literal"><span class="pre">copy_from_user</span></code> 从 <code class="docutils literal"><span class="pre">from</span></code> 引用的用户空间地址开始复制 <code class="docutils literal"><span class="pre">n</span></code> 字节到由 <code class="docutils literal"><span class="pre">to</span></code> 引用的内核空间地址；</li>
</ul>
<p>以下是这些函数的常用代码示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/uaccess.h&gt;</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm">* 将最多 size 字节复制到用户空间。</span>
<span class="cm">* 成功则返回 0，错误则返回其他值。</span>
<span class="cm">*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_buffer</span><span class="p">,</span> <span class="n">kernel_buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
   <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="k">else</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="section-9">
<h2>打开和释放<a class="headerlink" href="#section-9" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">open</span></code> 函数执行设备的初始化。在大多数情况下，这些操作涉及初始化设备并填充特定数据（如果是第一次打开调用）。<a href="#system-message-1"><span class="problematic" id="problematic-1">*</span></a>释放函数*用于释放设备特定资源：在调用全部完成后，解除对特定数据的锁定并关闭设备。</p>
<p>在大多数情况下，<a href="#system-message-2"><span class="problematic" id="problematic-2">*</span></a>打开函数*的结构如下所示：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span> <span class="o">=</span>
             <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">my_device_data</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>

    <span class="cm">/* 验证设备访问权限 */</span>
    <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">my_data</span><span class="p">;</span>

    <span class="cm">/* 初始化设备 */</span>
    <span class="p">...</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>实施 <code class="docutils literal"><span class="pre">open</span></code> 函数时会遇到访问控制的问题。有时候一个设备在同一时刻需要只打开一次；更具体地说，不允许在释放之前进行第二次打开。为了实现这种限制，你可以选择一种处理已经打开的设备的打开调用的方法：它可以返回一个错误 (<code class="docutils literal"><span class="pre">-EBUSY</span></code>)，阻塞打开调用直到进行释放操作，或者在执行打开操作之前关闭设备。</p>
<p>在用户空间对设备调用打开和关闭函数时，会调用驱动程序中的 my_open 和 my_release 函数。以下是一个用户空间调用的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="s">&quot;/dev/my_device&quot;</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>

<span class="cm">/* 执行工作 */</span>
<span class="c1">//..</span>

<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-10">
<h2>读取和写入<a class="headerlink" href="#section-10" title="Permalink to this headline">¶</a></h2>
<p>用户空间程序调用读取或写入系统调用，会导致设备驱动程序的读和写操作。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">write</span></code> 函数会在设备和用户空间之间传输数据：read 函数从设备读取数据并将其传输到用户空间，而 write 函数则读取用户空间的数据并将其写入设备。参数 buffer（缓冲区）是一个用户空间指针，这就是为什么需要使用 <code class="docutils literal"><span class="pre">copy_to_user</span></code> 或 <code class="docutils literal"><span class="pre">copy_from_user</span></code> 函数。</p>
<p>read 或 write 返回的值可以是：</p>
<blockquote>
<div><ul class="simple">
<li>传输的字节数；如果返回的值小于参数 size（请求的字节数），则表示只传输了部分数据。大多数情况下，用户空间应用程序会持续调用系统调用（read 或 write）函数，直到所需的数据量全部传输完成为止。</li>
<li>如果是 read，返回值为 0 表示文件读到底了；如果 write 返回值为 0，则表示没有写入任何字节且没有发生错误；在这种情况下，用户空间应用程序会重新尝试写入调用。</li>
<li>负值表示程序错误。</li>
</ul>
</div></blockquote>
<p>要执行由多次部分传输组成的数据传输，应执行以下操作：</p>
<blockquote>
<div><ul class="simple">
<li>在作为参数接收的缓冲区和设备之间传输尽可能多的字节（从作为参数接收的偏移量开始进行设备写入/读取）；</li>
<li>更新作为参数接收的偏移量，以表示下一次读取/写入数据的位置；</li>
<li>返回传输的字节数。</li>
</ul>
</div></blockquote>
<p>下面的示例展示了考虑了内部缓冲区大小、用户缓冲区大小和偏移量的 read 函数的程序：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buffer</span><span class="p">,</span>
                   <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">my_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* 从 my_data-&gt;buffer 读取数据到用户缓冲区 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_buffer</span><span class="p">,</span> <span class="n">my_data</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

    <span class="o">*</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>下面的图片展示了读操作以及数据如何在用户空间和驱动程序之间传输：</p>
<ol class="arabic simple">
<li>驱动程序有足够的可用数据（从偏移位置开始），以准确地传输所需大小（SIZE）给用户。</li>
<li>传输的数量比所需的少。</li>
</ol>
<a class="reference internal image-reference" href="../_images/read.png"><img alt="../_images/read.png" src="../_images/read.png" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="../_images/read2.png"><img alt="../_images/read2.png" src="../_images/read2.png" style="width: 49%;" /></a>
<p>我们可以将驱动程序实现的读操作视为对用户空间读取请求的响应。在这种情况下，驱动程序负责根据其读取的量推进偏移，并返回读取的大小（可能小于所需大小）。</p>
<p>写函数的结构类似：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_buffer</span><span class="p">,</span>
                    <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="kt">ssize_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">my_data</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* 将数据从用户缓冲区读到 my_data-&gt;buffer */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">my_data</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">user_buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

    <span class="o">*</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>写操作将响应来自用户空间的写请求。在这种情况下，根据驱动程序的最大容量（MAXSIZ），它可以写入比所需大小更多或更少的数据。</p>
<a class="reference internal image-reference" href="../_images/write.png"><img alt="../_images/write.png" src="../_images/write.png" style="width: 49%;" /></a>
<a class="reference internal image-reference" href="../_images/write2.png"><img alt="../_images/write2.png" src="../_images/write2.png" style="width: 49%;" /></a>
</div>
<div class="section" id="ioctl-1">
<span id="ioctl"></span><h2>ioctl<a class="headerlink" href="#ioctl-1" title="Permalink to this headline">¶</a></h2>
<p>除了读和写操作之外，驱动程序需要能够执行某些物理设备控制任务。这些操作通过实现一个名为 <code class="docutils literal"><span class="pre">ioctl</span></code> 的函数来完成。最初，ioctl 系统调用使用了 Big Kernel Lock。因此，其无锁版本 <code class="docutils literal"><span class="pre">unlocked_ioctl</span></code> 逐渐替代了该调用。你可以在 LWN 上阅读更多信息：<a class="reference external" href="http://lwn.net/Articles/119652/">http://lwn.net/Articles/119652/</a></p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">long</span> <span class="nf">my_ioctl</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">cmd</span></code> 是从用户空间发送的命令。如果用户空间调用发送了一个值，可以通过 <code class="docutils literal"><span class="pre">cmd</span></code> 直接访问它。如果获取了一个缓冲区，那么 arg 的值将是指向它的指针，并且必须通过 <code class="docutils literal"><span class="pre">copy_to_user</span></code> 或 <code class="docutils literal"><span class="pre">copy_from_user</span></code> 进行访问。</p>
<p>在实现 <code class="docutils literal"><span class="pre">ioctl</span></code> 函数之前，必须选择与命令对应的数字。一种方法是从 0 开始选择连续的数字，但我们建议使用 <code class="docutils literal"><span class="pre">_IOC(dir,</span> <span class="pre">type,</span> <span class="pre">nr,</span> <span class="pre">size)</span></code> 宏定义来生成 ioctl 代码。宏定义的参数如下：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">dir</span></code> 表示数据传输 (<code class="docutils literal"><span class="pre">_IOC_NONE</span></code> , <code class="docutils literal"><span class="pre">_IOC_READ</span></code> , <code class="docutils literal"><span class="pre">_IOC_WRITE</span></code>)。</li>
<li><code class="docutils literal"><span class="pre">type</span></code> 表示魔数 (<code class="docutils literal"><span class="pre">Documentation/ioctl/ioctl-number.txt</span></code>)；</li>
<li><code class="docutils literal"><span class="pre">nr</span></code> 是设备的 ioctl 代码；</li>
<li><code class="docutils literal"><span class="pre">size</span></code> 是传输数据的大小。</li>
</ul>
</div></blockquote>
<p>下面的示例展示了 <code class="docutils literal"><span class="pre">ioctl</span></code> 函数的实现：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;asm/ioctl.h&gt;</span><span class="cp"></span>

<span class="cp">#define MY_IOCTL_IN _IOC(_IOC_WRITE, &#39;k&#39;, 1, sizeof(my_ioctl_data))</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">my_ioctl</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span><span class="n">my_data</span> <span class="o">=</span>
         <span class="p">(</span><span class="k">struct</span> <span class="n">my_device_data</span><span class="o">*</span><span class="p">)</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
    <span class="n">my_ioctl_data</span> <span class="n">mid</span><span class="p">;</span>

    <span class="k">switch</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nl">MY_IOCTL_IN</span><span class="p">:</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mid</span><span class="p">,</span> <span class="p">(</span><span class="n">my_ioctl_data</span> <span class="o">*</span><span class="p">)</span> <span class="n">arg</span><span class="p">,</span>
                           <span class="k">sizeof</span><span class="p">(</span><span class="n">my_ioctl_data</span><span class="p">))</span> <span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

        <span class="cm">/* 处理数据以及执行命令 */</span>

        <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>用户空间调用 ioctl 函数时，将调用驱动程序的 my_ioctl 函数。以下是用户空间调用的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">ioctl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">MY_IOCTL_IN</span><span class="p">,</span> <span class="n">buffer</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-11">
<h2>等待队列<a class="headerlink" href="#section-11" title="Permalink to this headline">¶</a></h2>
<p>许多情况下，线程需要等待某个操作完成。但最好避免忙等待。通过使用等待队列，我们可以阻塞一个线程，直到发生某个事件再激活这个线程。当条件满足时（可能是内核中的其他地方、另一个进程、中断或可延迟工作）我们会唤醒该进程。</p>
<p>等待队列是一个等待特定事件的进程列表。队列使用 <code class="docutils literal"><span class="pre">wait_queue_head_t</span></code> 类型定义，并可通过以下函数/宏使用：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/wait.h&gt;</span><span class="cp"></span>

<span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">wq_name</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">init_waitqueue_head</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wait_event</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">condition</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wait_event_interruptible</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">condition</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wait_event_timeout</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">condition</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">condition</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">wake_up</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">wake_up_interruptible</span><span class="p">(</span><span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">q</span><span class="p">);</span>
</pre></div>
</div>
<p>上述宏/函数的作用如下：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">init_waitqueue_head()</span></code> 初始化等待队列；如果是要在编译期间初始化队列，可以使用 <code class="xref c c-macro docutils literal"><span class="pre">DECLARE_WAIT_QUEUE_HEAD</span></code> 宏；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">wait_event()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">wait_event_interruptible()</span></code> 在条件为假时将当前线程加入队列，将其设置为 TASK_UNINTERRUPTIBLE 或 TASK_INTERRUPTIBLE，并调用调度程序以安排新线程；当另一个线程调用 wake_up 函数时，等待将被中断；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">wait_event_timeout()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">wait_event_interruptible_timeout()</span></code> 具有与上述函数相同的效果，只是等待也可以在参数 timeout（超时）结束时被中断；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">wake_up()</span></code> 将所有处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 状态的线程切换到 TASK_RUNNING 状态；从队列中移除这些线程；</li>
<li><code class="xref c c-func docutils literal"><span class="pre">wake_up_interruptible()</span></code> 执行相同的操作，但只唤醒处于 TASK_INTERRUPTIBLE 状态的线程。</li>
</ul>
</div></blockquote>
<p>举个简单的示例，线程等待某个标志位的值的改变。以下代码实现初始化：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp"></span>

<span class="n">wait_queue_head_t</span> <span class="n">wq</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
</pre></div>
</div>
<p>某个线程等待标志的值变为非零：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="n">flag</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>而另一个线程将改变标志（flag）的值并唤醒等待中的线程：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
<span class="n">wake_up_interruptible</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-12">
<h2>练习<a class="headerlink" href="#section-12" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 设备驱动。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/设备驱动/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-12">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-13">
<h3>0. 简介<a class="headerlink" href="#section-13" title="Permalink to this headline">¶</a></h3>
<p>使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 查找 Linux 内核中以下符号的定义：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">file_operations</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">generic_ro_fops</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">vfs_read()</span></code></li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-14">
<h3>1. 注册/注销<a class="headerlink" href="#section-14" title="Permalink to this headline">¶</a></h3>
<p>驱动程序控制一个具有 <code class="docutils literal"><span class="pre">MY_MAJOR</span></code> 主设备号和 <code class="docutils literal"><span class="pre">MY_MINOR</span></code> 次设备号的设备（这些宏定义在 kernel/so2_cdev.c 文件中）。</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">使用 <strong>mknod</strong> 创建 <strong>/dev/so2_cdev</strong> 字符设备节点。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验中的 <a class="reference internal" href="#section-4">主设备号和次设备号</a> 部分。</p>
</div>
</li>
<li><p class="first">在 init 和 exit 模块函数中实现设备的注册和注销，设备名称应为 <code class="docutils literal"><span class="pre">so2_cdev</span></code>。实现 <strong>TODO 1</strong>。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读 <a class="reference internal" href="#section-7">字符设备的注册和注销</a> 部分。</p>
</div>
</li>
<li><p class="first">通过 <code class="docutils literal"><span class="pre">pr_info</span></code> 函数使得在注册和注销操作后显示一条消息，以确认它们是否成功。然后将模块加载到内核中：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ insmod so2_cdev.ko
</pre></div>
</div>
<p>并查看 <code class="docutils literal"><span class="pre">/proc/devices</span></code> 中的字符设备：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ cat /proc/devices <span class="p">|</span> less
</pre></div>
</div>
<p>确定使用主设备号 42 注册的设备类型。请注意，<code class="docutils literal"><span class="pre">/proc/devices</span></code> 仅包含设备类型（主设备号），而不包含实际设备（即次设备号）。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>/dev 中的条目不会通过加载模块来创建。可以通过两种方式创建：</p>
<ul class="last simple">
<li>手动使用 <code class="docutils literal"><span class="pre">mknod</span></code> 命令，就像我们上面所做的那样。</li>
<li>使用 udev 守护进程自动创建</li>
</ul>
</div>
</li>
<li><p class="first">卸载内核模块</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>rmmod so2_cdev
</pre></div>
</div>
</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="section-15">
<h3>2. 注册一个已注册的主设备号<a class="headerlink" href="#section-15" title="Permalink to this headline">¶</a></h3>
<p>修改 <strong>MY_MAJOR</strong>，使其指向已经使用的主设备号。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">查看 <code class="docutils literal"><span class="pre">/proc/devices</span></code> 来获取一个已分配的主设备号。</p>
</div>
<p>参考 <a class="reference external" href="http://elixir.free-electrons.com/linux/v4.9/source/include/uapi/asm-generic/errno-base.h">errno-base.h</a> 并找出错误码的含义。恢复模块的初始配置。</p>
</div>
<div class="section" id="section-16">
<h3>3. 打开和关闭<a class="headerlink" href="#section-16" title="Permalink to this headline">¶</a></h3>
<p>运行 <code class="docutils literal"><span class="pre">cat</span> <span class="pre">/dev/so2_cdev</span></code> ，从我们的字符设备中读取数据。由于驱动程序没有实现打开函数，因此读取操作无法正常工作。按照标记为 TODO 2 的注释进行操作并实现以下内容。</p>
<blockquote>
<div><ol class="arabic simple">
<li>初始化设备<ul>
<li>在 <code class="docutils literal"><span class="pre">so2_device_data</span></code> 结构体中添加一个 cdev 字段。</li>
<li>阅读实验中的 <a class="reference internal" href="#section-7">字符设备的注册和注销</a> 部分。</li>
</ul>
</li>
<li>在驱动程序中实现打开和释放函数。</li>
<li>在打开和释放函数中显示一条消息。</li>
<li>再次读取 <code class="docutils literal"><span class="pre">/dev/so2_cdev</span></code> 文件。按照内核显示的消息进行操作。由于尚未实现 <code class="docutils literal"><span class="pre">read</span></code> 函数，因此仍会出现错误。</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">设备驱动程序操作的原型在 <code class="docutils literal"><span class="pre">file_operations</span></code> 结构体中。请阅读 <a class="reference internal" href="#section-9">打开和释放</a> 部分。</p>
</div>
</div>
<div class="section" id="section-17">
<h3>4. 访问限制<a class="headerlink" href="#section-17" title="Permalink to this headline">¶</a></h3>
<p>使用原子变量限制设备访问，以便一次只能有一个进程打开该设备。其他进程将收到“设备忙”错误 (<code class="docutils literal"><span class="pre">-EBUSY</span></code>)。限制访问将在驱动程序中的打开函数中完成。按照标记为 <strong>TODO 3</strong> 的注释进行操作并实现以下内容。</p>
<blockquote>
<div><ol class="arabic simple">
<li>在设备结构体中添加 <code class="docutils literal"><span class="pre">atomic_t</span></code> 变量。</li>
<li>在模块初始化时对该变量进行初始化。</li>
<li>在打开函数中使用该变量限制对设备的访问。我们建议使用 <code class="xref c c-func docutils literal"><span class="pre">atomic_cmpxchg()</span></code>。</li>
<li>在释放函数中重置该变量以恢复对设备的访问权限。</li>
<li>要测试你的部署，你需要模拟对设备的长期使用。要模拟休眠，请在设备打开操作的末尾调用调度器：</li>
</ol>
</div></blockquote>
<div class="highlight-bash"><div class="highlight"><pre><span></span>set_current_state<span class="o">(</span>TASK_INTERRUPTIBLE<span class="o">)</span><span class="p">;</span>
schedule_timeout<span class="o">(</span><span class="m">1000</span><span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">atomic_cmpxchg 函数的优点在于它可以在一个原子操作中检查变量的旧值并将其设置为新值。详细了解 <a class="reference external" href="https://www.khronos.org/registry/OpenCL/sdk/1.1/docs/man/xhtml/atomic_cmpxchg.html">atomic_cmpxchg</a>。这里有一个使用示例 <a class="reference external" href="http://elixir.free-electrons.com/linux/v4.9/source/lib/dump_stack.c#L24">http://elixir.free-electrons.com/linux/v4.9/source/lib/dump_stack.c#L24</a> 。</p>
</div>
</div>
<div class="section" id="section-18">
<h3>5. 读操作<a class="headerlink" href="#section-18" title="Permalink to this headline">¶</a></h3>
<p>在驱动程序中实现读取函数。按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">4</span></code> 的注释并实现以下步骤：</p>
<blockquote>
<div><ol class="arabic simple">
<li>在 <code class="docutils literal"><span class="pre">so2_device_data</span></code> 结构中保持一个缓冲区，并用 <code class="docutils literal"><span class="pre">MESSAGE</span></code> 宏的值进行初始化。缓冲区的初始化在模块的 <code class="docutils literal"><span class="pre">init</span></code> 函数中完成。</li>
<li>在读取调用时，将内核空间缓冲区的内容复制到用户空间缓冲区。<ul>
<li>使用 <code class="xref c c-func docutils literal"><span class="pre">copy_to_user()</span></code> 函数将信息从内核空间复制到用户空间。</li>
<li>暂时忽略大小和偏移参数。可以假设用户空间的缓冲区足够大，不需要检查读取函数的大小参数的有效性。</li>
<li>读取调用返回的值是从内核空间缓冲区传输到用户空间缓冲区的字节数。</li>
</ul>
</li>
<li>实现完成后，使用 <code class="docutils literal"><span class="pre">cat</span> <span class="pre">/dev/so2_cdev</span></code> 进行测试。</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">命令 <code class="docutils literal"><span class="pre">cat</span> <span class="pre">/dev/so2_cdev</span></code> 不会结束（使用Ctrl+C）。请阅读 <a href="#system-message-3"><span class="problematic" id="problematic-3">`读和写`_</span></a> 和 <a href="#system-message-4"><span class="problematic" id="problematic-4">`访问进程的地址空间`_</span></a> 部分。如果要显示偏移值，请使用以下形式的构造: <code class="docutils literal"><span class="pre">pr_info(&quot;Offset:</span> <span class="pre">%lld</span> <span class="pre">\n&quot;,</span> <span class="pre">*offset)</span></code>；偏移值的数据类型 <code class="docutils literal"><span class="pre">loff_t</span></code> 是 <code class="docutils literal"><span class="pre">long</span> <span class="pre">long</span> <span class="pre">int</span></code> 的 typedef。</p>
</div>
<p><code class="docutils literal"><span class="pre">cat</span></code> 命令一直读取到文件的末尾，文件通过读取返回值为 0 来表示读到末尾了。因此，为了正确实现，你需要更新并使用读函数中接收的偏移参数，并在用户达到缓冲区末尾时返回 0。</p>
<p>修改驱动程序以使 <code class="docutils literal"><span class="pre">cat</span></code> 命令结束：</p>
<blockquote>
<div><ol class="arabic simple">
<li>使用大小参数。</li>
<li>对于每次读取，相应地更新偏移参数。</li>
<li>确保读取函数返回已复制到用户缓冲区的字节数。</li>
</ol>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">通过解引用偏移参数，可以读取并移动在文件中的当前位置。每次成功进行读取后都需要更新其值。</p>
</div>
</div>
<div class="section" id="section-19">
<h3>6. 写操作<a class="headerlink" href="#section-19" title="Permalink to this headline">¶</a></h3>
<p>添加将消息写入内核缓冲区以替换预定义消息的功能。在驱动程序中实现写函数。按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">5</span></code> 的注释进行操作。</p>
<p>此时忽略偏移参数。你可以假设驱动程序缓冲区足够大。你无需检查写函数大小参数的有效性。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>设备驱动程序操作的原型位于 file_operations 结构中。使用以下命令进行测试：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s2">&quot;arpeggio&quot;</span>&gt; /dev/so2_cdev
cat /dev/so2_cdev
</pre></div>
</div>
<p class="last">请阅读 <a href="#system-message-5"><span class="problematic" id="problematic-5">`读和写`_</span></a> 小节和 <a class="reference internal" href="#section-8">访问进程地址空间</a> 小节。</p>
</div>
</div>
<div class="section" id="ioctl-2">
<h3>7. ioctl 操作<a class="headerlink" href="#ioctl-2" title="Permalink to this headline">¶</a></h3>
<p>对于这个练习，我们希望在驱动程序中添加 ioctl <code class="docutils literal"><span class="pre">MY_IOCTL_PRINT</span></code> 来显示来自宏 <code class="docutils literal"><span class="pre">IOCTL_MESSAGE</span></code> 的消息。按照标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">6</span></code> 的注释进行操作。</p>
<p>为此：</p>
<blockquote>
<div><ol class="arabic simple">
<li>在驱动程序中实现 ioctl 函数。</li>
<li>我们需要使用 <code class="docutils literal"><span class="pre">user/so2_cdev_test.c</span></code> 调用 ioctl 函数，并传递适当的参数。</li>
<li>为了进行测试，我们将使用一个用户空间程序 (<code class="docutils literal"><span class="pre">user/so2_cdev_test.c</span></code>) 来调用具有所需参数的 <code class="docutils literal"><span class="pre">ioctl</span></code> 函数。</li>
</ol>
</div></blockquote>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>宏 <code class="docutils literal"><span class="pre">MY_IOCTL_PRINT</span></code> 在文件 <code class="docutils literal"><span class="pre">include/so2_cdev.h</span></code> 中定义，该文件在内核模块和用户空间程序之间共享。</p>
<p class="last">请阅读实验中的 <a class="reference internal" href="#ioctl">ioctl</a> 章节。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p>用户空间代码在 <code class="docutils literal"><span class="pre">make</span> <span class="pre">build</span></code> 时会自动编译，并在 <code class="docutils literal"><span class="pre">make</span> <span class="pre">copy</span></code> 时被复制。</p>
<p class="last">由于我们需要为 32 位的 qemu 机器编译程序，如果你的主机是 64 位的，那么你需要安装 <code class="docutils literal"><span class="pre">gcc-multilib</span></code> 软件包。</p>
</div>
</div>
</div>
<div class="section" id="section-20">
<h2>额外练习<a class="headerlink" href="#section-20" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ioctl-3">
<h3>带消息的 ioctl<a class="headerlink" href="#ioctl-3" title="Permalink to this headline">¶</a></h3>
<p>为驱动程序添加两个 ioctl 操作，用于修改与驱动程序关联的消息。应使用固定长度的缓冲区（BUFFER_SIZE）。</p>
<ol class="arabic simple">
<li>在驱动程序的 <code class="docutils literal"><span class="pre">ioctl</span></code> 函数中添加以下操作：<ul>
<li><code class="docutils literal"><span class="pre">MY_IOCTL_SET_BUFFER</span></code>：用于向设备写入消息；</li>
<li><code class="docutils literal"><span class="pre">MY_IOCTL_GET_BUFFER</span></code>：用于从设备读取消息。</li>
</ul>
</li>
<li>为进行测试，将所需的命令行参数传递给用户空间程序。</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">阅读实验中的 <a class="reference internal" href="#ioctl">ioctl</a> 和 <a class="reference internal" href="#section-8">访问进程地址空间</a> 部分。</p>
</div>
</div>
<div class="section" id="ioctl-4">
<h3>使用等待队列的 ioctl<a class="headerlink" href="#ioctl-4" title="Permalink to this headline">¶</a></h3>
<p>为设备驱动程序添加两个 <code class="docutils literal"><span class="pre">ioctl</span></code> 操作，用于队列处理。</p>
<ol class="arabic simple">
<li>在驱动程序的 <code class="docutils literal"><span class="pre">ioctl</span></code> 函数中添加以下操作：<ul>
<li><code class="docutils literal"><span class="pre">MY_IOCTL_DOWN</span></code>：将进程添加到队列中；</li>
<li><code class="docutils literal"><span class="pre">MY_IOCTL_UP</span></code>：将进程从队列中移除。</li>
</ul>
</li>
<li>在设备结构中填充 <code class="docutils literal"><span class="pre">wait_queue_head_t</span></code> 字段和一个标志。</li>
<li>不要忘记初始化等待队列和标志。</li>
<li>从前一个练习中移除独占访问条件。</li>
<li>为进行测试，将所需的命令行参数传递给用户空间程序。</li>
</ol>
<p>当进程被添加到队列中时，它将保持阻塞状态；要运行队列命令，请使用 Alt+F2 打开虚拟机中的新控制台；可以使用 Alt+F1 返回到上一个控制台。如果是通过 SSH 连接到虚拟机的，请打开新的控制台。</p>
<div class="admonition attention">
<p class="first admonition-title">Attention</p>
<p class="last">阅读实验中的 <a class="reference internal" href="#ioctl">ioctl</a> 和 <a class="reference internal" href="#section-11">等待队列</a> 部分。</p>
</div>
</div>
<div class="section" id="o-nonblock">
<h3>O_NONBLOCK 实现<a class="headerlink" href="#o-nonblock" title="Permalink to this headline">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>如果文件使用 <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code> 标志打开，则其操作将是非阻塞的。</p>
<p>如果在执行读取操作时数据不可用，则会发生以下情况：</p>
<blockquote class="last">
<div><ul class="simple">
<li>如果文件是使用 <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code> 打开的，读取调用将返回 <code class="docutils literal"><span class="pre">-EWOULDBLOCK</span></code>。</li>
<li>否则，当前任务（进程）将被放入等待队列，并在数据可用时解除阻塞（在我们的情况下，在写入时）。</li>
</ul>
</div></blockquote>
</div>
<ul class="simple">
<li>为允许非阻塞的读取操作，从前面的练习中移除独占访问条件。</li>
<li>可以使用前一个练习中定义的队列。</li>
<li>可以忽略文件偏移量。</li>
<li>将数据的初始大小修改为 <code class="docutils literal"><span class="pre">0</span></code>，以便进行测试。</li>
<li>为进行测试，将所需的命令行参数传递给用户空间程序。<ul>
<li>当使用 <code class="docutils literal"><span class="pre">n</span></code> 选项时，测试程序会将打开标志更改为 <code class="docutils literal"><span class="pre">O_NONBLOCK</span></code>，然后执行 <code class="docutils literal"><span class="pre">read</span></code> 操作。</li>
</ul>
</li>
<li>运行 <code class="docutils literal"><span class="pre">cat</span> <span class="pre">/dev/so2_dev</span></code> 命令时，打开文件过程中使用了哪些标志？</li>
</ul>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="kernel_api.html" class="btn btn-neutral float-left" title="内核 API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="interrupts.html" class="btn btn-neutral float-right" title="I/O 访问和中断" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>