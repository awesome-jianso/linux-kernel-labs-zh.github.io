<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>介绍 &mdash; Linux 系统内核  文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="内核模块" href="kernel_modules.html" />
    <link rel="prev" title="基础设施" href="infrastructure.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">Operating Systems 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">基础设施</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">介绍</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-2">实验目标</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-3">关键词</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-4">关于本实验</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-5">参考资料</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-6">源代码导航</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#cscope">cscope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#clangd">clangd</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kscope">Kscope</a></li>
<li class="toctree-l3"><a class="reference internal" href="#lxr-cross-reference">LXR Cross-Reference</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sourceweb">SourceWeb</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-7">内核调试</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#gdb-linux">gdb（Linux）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-8">获取堆栈跟踪</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-9">文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-10">练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-11">备注</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-12">启动虚拟机</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">添加和使用虚拟磁盘</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gdb-qemu">GDB 和 QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="#gdb">4. GDB 探索</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cscope-1">5. Cscope 探索</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">介绍</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/introduction.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="section-1">
<h1>介绍<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-2">
<h2>实验目标<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>介绍操作系统 2 实验的规则和目标</li>
<li>介绍实验文档</li>
<li>介绍 Linux 内核及相关资源</li>
</ul>
</div>
<div class="section" id="section-3">
<h2>关键词<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>内核，内核编程</li>
<li>Linux，标准版（vanilla），<a class="reference external" href="http://www.kernel.org">http://www.kernel.org</a></li>
<li>cscope，LXR</li>
<li>gdb，/proc/kcore，addr2line，dump_stack</li>
</ul>
</div>
<div class="section" id="section-4">
<h2>关于本实验<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h2>
<p>操作系统 2 实验是一个内核编程和驱动程序开发实验。本实验的目标是：</p>
<ul class="simple">
<li>加深课程中介绍的概念</li>
<li>展示内核编程接口（内核 API）</li>
<li>获取在一个独立的环境中记录、开发和调试的技能</li>
<li>获取驱动程序开发的知识和技能</li>
</ul>
<p>每个实验将呈现一组特定问题的概念、应用和命令。实验将以演示开始（每个实验都会有一组幻灯片）（15分钟），其余时间将用于实验室练习（80分钟）。</p>
<p>为了获得最佳的实验效果，我们建议你阅读相关幻灯片。要完全理解一个实验，我们建议你查阅实验技术支持材料。如果需要深入学习，可以使用辅助文档。</p>
</div>
<div class="section" id="section-5">
<h2>参考资料<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>Linux<ul>
<li><a class="reference external" href="http://www.amazon.com/Linux-Kernel-Development-Robert-Love/dp/0672329468/">Linux 内核开发（第 3 版）</a></li>
<li><a class="reference external" href="http://free-electrons.com/doc/books/ldd3.pdf">Linux设备驱动（第 3 版）</a></li>
<li><a class="reference external" href="http://www.amazon.com/Essential-Device-Drivers-Sreekrishnan-Venkateswaran/dp/0132396556">精通 Linux 设备驱动程序</a></li>
</ul>
</li>
<li>通用<ul>
<li><a class="reference external" href="http://cursuri.cs.pub.ro/cgi-bin/mailman/listinfo/pso">邮件列表</a>
（<a class="reference external" href="http://blog.gmane.org/gmane.education.region.romania.operating-systems-design">搜索邮件列表</a> ）</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="section-6">
<h2>源代码导航<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h2>
<div class="section" id="cscope">
<span id="cscope-intro"></span><h3>cscope<a class="headerlink" href="#cscope" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="http://cscope.sourceforge.net/">Cscope</a> 是一个用于高效导航 C 源代码的工具。要使用它，必须从现有的源代码生成一个 cscope 数据库。在 Linux 树中，执行命令 <strong class="command">make ARCH=x86 cscope</strong> 就足够了。通过 ARCH 变量指定架构不是必须的，但建议这样做；否则，一些依赖于架构的函数会在数据库中出现多次。</p>
<p>你可以使用命令 <strong class="command">make ARCH=x86 COMPILED_SOURCE=1 cscope</strong> 构建 cscope 数据库。这样，cscope 数据库中只包含在编译过程中已经使用过的符号（symbol），从而在搜索符号时可以获得更好的性能。</p>
<p>Cscope 也可以作为独立工具使用，但与编辑器结合使用时更加有用。要在 <strong class="command">vim</strong> 中使用 cscope，需要安装两个软件包，并在文件 <code class="file docutils literal"><span class="pre">.vimrc</span></code> 中添加以下几行（实验室中的机器已经进行了设置）：</p>
<div class="highlight-vim"><div class="highlight"><pre><span></span><span class="k">if</span> has<span class="p">(</span><span class="s2">&quot;cscope&quot;</span><span class="p">)</span>
<span class="c">        &quot; Look for a &#39;cscope.out&#39; file starting from the current directory,</span>
<span class="c">        &quot; going up to the root directory.</span>
        <span class="k">let</span> s:dirs <span class="p">=</span> split<span class="p">(</span>getcwd<span class="p">(),</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
        <span class="k">while</span> s:dirs <span class="p">!=</span> []
                <span class="k">let</span> s:<span class="nb">path</span> <span class="p">=</span> <span class="s2">&quot;/&quot;</span> . <span class="k">join</span><span class="p">(</span>s:dirs<span class="p">,</span> <span class="s2">&quot;/&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>filereadable<span class="p">(</span>s:<span class="nb">path</span> . <span class="s2">&quot;/cscope.out&quot;</span><span class="p">))</span>
                        execute <span class="s2">&quot;cs add &quot;</span> . s:<span class="nb">path</span> . <span class="s2">&quot;/cscope.out &quot;</span> . s:<span class="nb">path</span> . <span class="s2">&quot; -v&quot;</span>
                        <span class="k">break</span>
                <span class="k">endif</span>
                <span class="k">let</span> s:dirs <span class="p">=</span> s:dirs[:<span class="m">-2</span>]
        <span class="k">endwhile</span>

        <span class="k">set</span> <span class="nb">csto</span><span class="p">=</span><span class="m">0</span>  <span class="c">&quot; Use cscope first, then ctags</span>
        <span class="k">set</span> <span class="nb">cst</span>     <span class="c">&quot; Only search cscope</span>
        <span class="k">set</span> <span class="nb">csverb</span>  <span class="c">&quot; Make cs verbose</span>

        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`s :<span class="k">cs</span> find s `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">g</span> :<span class="k">cs</span> find <span class="k">g</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">c</span> :<span class="k">cs</span> find <span class="k">c</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">t</span> :<span class="k">cs</span> find <span class="k">t</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">e</span> :<span class="k">cs</span> find <span class="k">e</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">f</span> :<span class="k">cs</span> find <span class="k">f</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cfile&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">i</span> :<span class="k">cs</span> find <span class="k">i</span> ^`<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cfile&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>`$`<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap `<span class="p">&lt;</span>C<span class="p">-</span>\<span class="p">&gt;</span>`<span class="k">d</span> :<span class="k">cs</span> find <span class="k">d</span> `<span class="p">&lt;</span>C<span class="p">-</span>R<span class="p">&gt;</span>`<span class="p">=</span>expand<span class="p">(</span><span class="s2">&quot;`&lt;cword&gt;`&quot;</span><span class="p">)</span>`<span class="p">&lt;</span>CR<span class="p">&gt;</span>``<span class="p">&lt;</span>CR<span class="p">&gt;</span>`
        nmap <span class="p">&lt;</span>F6<span class="p">&gt;</span> :cnext <span class="p">&lt;</span>CR<span class="p">&gt;</span>
        nmap <span class="p">&lt;</span>F5<span class="p">&gt;</span> :cprev <span class="p">&lt;</span>CR<span class="p">&gt;</span>

<span class="c">        &quot; Open a quickfix window for the following queries.</span>
        <span class="k">set</span> <span class="nb">cscopequickfix</span><span class="p">=</span>s<span class="p">-,</span><span class="k">c</span><span class="p">-,</span><span class="k">d</span><span class="p">-,</span><span class="k">i</span><span class="p">-,</span><span class="k">t</span><span class="p">-,</span><span class="k">e</span><span class="p">-,</span><span class="k">g</span><span class="p">-</span>
<span class="k">endif</span>
</pre></div>
</div>
<p>脚本在当前目录或父目录中搜索名为 <code class="file docutils literal"><span class="pre">cscope.out</span></code> 的文件。如果 <strong class="command">vim</strong> 找到该文件，你可以使用快捷键 <code class="code docutils literal"><span class="pre">Ctrl</span> <span class="pre">+</span> <span class="pre">]</span></code> 或 <code class="code docutils literal"><span class="pre">Ctrl+\</span> <span class="pre">g`（按下</span> <span class="pre">control-\\</span> <span class="pre">然后按</span> <span class="pre">g）直接跳转到光标所在单词的定义（函数、变量、结构等）。类似地，你可以使用</span> <span class="pre">:code:`Ctrl+\</span> <span class="pre">s</span></code> 前往光标所在单词的使用位置。</p>
<p>你可以从以下网址获取一个启用了 cscope 的 <code class="file docutils literal"><span class="pre">.vimrc</span></code> 文件（还包含其他好用的东西）：<a class="reference external" href="https://github.com/ddvlad/cfg/blob/master/_vimrc">https://github.com/ddvlad/cfg/blob/master/_vimrc</a>。以下指南基于该文件，同时也展示了具有相同效果的基本 <strong class="command">vim</strong> 命令。</p>
<p>如果有多个结果（通常会有），你可以使用 <code class="code docutils literal"><span class="pre">F6</span></code> 和 <code class="code docutils literal"><span class="pre">F5</span></code> （<code class="code docutils literal"><span class="pre">:ccnext</span></code> 和 <code class="code docutils literal"><span class="pre">:cprev</span></code>）在它们之间切换。你还可以使用命令 <code class="code docutils literal"><span class="pre">:copen</span></code> 打开一个新的面板来显示结果。要关闭面板，可以使用 <code class="code docutils literal"><span class="pre">:cclose</span></code> 命令。</p>
<p>要返回到先前的位置，可以使用 <code class="code docutils literal"><span class="pre">Ctrl+o</span></code> （是字母 o，不是零）。该命令可以多次使用，即使 cscope 更改了你当前正在编辑的文件也有效。</p>
<p>要在 <strong class="command">vim</strong> 启动时直接跳转到符号定义，可以使用 <code class="code docutils literal"><span class="pre">vim</span> <span class="pre">-t</span> <span class="pre">&lt;symbol_name&gt;`（例如</span> <span class="pre">:code:`vim</span> <span class="pre">-t</span> <span class="pre">task_struct</span></code>）。如果你已经启动了 <strong class="command">vim</strong> 并想按名称搜索符号，可以使用 <code class="code docutils literal"><span class="pre">cs</span> <span class="pre">find</span> <span class="pre">g</span> <span class="pre">&lt;symbol_name&gt;</span></code> (例如 <code class="code docutils literal"><span class="pre">cs</span> <span class="pre">find</span> <span class="pre">g</span> <span class="pre">task_struct</span></code>)。</p>
<p>如果你找到了多个结果，并且用 <code class="code docutils literal"><span class="pre">:copen</span></code> 命令打开了一个显示所有匹配项的面板，如果你想在面板中找到一种结构类型的符号，建议你用 <code class="code docutils literal"><span class="pre">/</span></code> ——斜杠命令在面板中搜索字符 <code class="code docutils literal"><span class="pre">{</span></code> （左花括号）。</p>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>你可以使用命令 <strong class="command">:cs help</strong> 获取所有 <strong class="command">cscope</strong> 命令的摘要。</p>
<p class="last">若要了解更多信息，请使用 <strong class="command">vim</strong> 内置的帮助命令：<strong class="command">:h cscope</strong> 或 <strong class="command">:h copen</strong>。</p>
</div>
<p>如果你使用 <strong class="command">emacs</strong>，请安装 <strong class="command">xcscope-el</strong> 包，并在 <code class="file docutils literal"><span class="pre">~/.emacs</span></code> 文件中添加以下行。</p>
<div class="highlight-vim"><div class="highlight"><pre><span></span><span class="p">(</span>require ‘xcscope<span class="p">)</span>
<span class="p">(</span><span class="k">cscope</span><span class="p">-</span>setup<span class="p">)</span>
</pre></div>
</div>
<p>这些命令将自动为 C 和 C++ 模式激活 cscope。<code class="code docutils literal"><span class="pre">C-s</span> <span class="pre">s</span></code> 是按键绑定前缀，<code class="code docutils literal"><span class="pre">C-s</span> <span class="pre">s</span> <span class="pre">s</span></code> 用于搜索符号（如果光标位置在单词上，调用它时将使用该位置的单词）。有关详细信息，请查看 <cite>https://github.com/dkogan/xcscope.el</cite>。</p>
</div>
<div class="section" id="clangd">
<h3>clangd<a class="headerlink" href="#clangd" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="https://clangd.llvm.org/">Clangd</a> 是一个语言服务器，提供了一些用于浏览 C 和 C++ 代码的工具。<a class="reference external" href="https://microsoft.github.io/language-server-protocol/">语言服务器协议</a> 利用语义全项目分析，实现了诸如跳转到定义、查找引用、悬停提示、代码补全等功能。</p>
<p>Clangd 需要一个编译数据库来理解内核源代码。可以通过以下方式生成编译数据库：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>make defconfig
make
scripts/clang-tools/gen_compile_commands.py
</pre></div>
</div>
<p>LSP 客户端：</p>
<ul class="simple">
<li>Vim/Neovim（ <a class="reference external" href="https://github.com/neoclide/coc.nvim">coc.nvim</a>、 <a class="reference external" href="https://github.com/neovim/nvim-lspconfig">nvim-lsp</a>、 <a class="reference external" href="https://github.com/natebosch/vim-lsc">vim-lsc</a> 以及 <a class="reference external" href="https://github.com/prabirshrestha/vim-lsp">vim-lsp</a> ）</li>
<li>Emacs（ <a class="reference external" href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> ）</li>
<li>VSCode（ <a class="reference external" href="https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd">clangd extension</a> ）</li>
</ul>
</div>
<div class="section" id="kscope">
<h3>Kscope<a class="headerlink" href="#kscope" title="永久链接至标题">¶</a></h3>
<p>如果想要一个更简单的界面的话，可以尝试 Kscope。<a class="reference external" href="http://sourceforge.net/projects/kscope/">Kscope</a> 是一个使用 QT 的 cscope 前端。它轻便、快速、易用。它支持使用正则表达式、调用图等方式进行搜索。Kscope 已经停止维护了。</p>
<p>还有一个适用于 Qt4 和 KDE 4 的 <a class="reference external" href="https///opendesktop.org/content/show.php/Kscope4?content=156987">移植版本</a> ，其保留了与文本编辑器 Kate 的集成，并且比 SourceForge 上的最新版本更易于使用。</p>
</div>
<div class="section" id="lxr-cross-reference">
<h3>LXR Cross-Reference<a class="headerlink" href="#lxr-cross-reference" title="永久链接至标题">¶</a></h3>
<p>LXR（LXR Cross-Reference）是一种工具，允许使用 Web 界面来索引和引用程序源代码中的符号。Web 界面显示了符号在文件中定义或使用的位置的链接。LXR 的开发网站是 <a class="reference external" href="http://sourceforge.net/projects/lxr">http://sourceforge.net/projects/lxr</a>。类似的工具有 <a class="reference external" href="http://oracle.github.io/opengrok/">OpenGrok</a> 和 <a class="reference external" href="http://en.wikipedia.org/wiki/Gonzui">Gonzui</a>。</p>
<p>尽管 LXR 最初是用于 Linux 内核源代码的，但也用于 <a class="reference external" href="http://lxr.mozilla.org/">Mozilla</a>、 <a class="reference external" href="http://apache.wirebrain.de/lxr/">Apache HTTP 服务器</a> 和 <a class="reference external" href="http://lxr.linux.no/freebsd/source">FreeBSD</a> 的源代码。</p>
<p>有许多网站使用 LXR 来进行 Linux 内核源代码的交叉引用，主要网站是 <a class="reference external" href="http://lxr.linux.no/linux/">开发原址</a>，然而该网站已不再运作。你可以使用 <a class="reference external" href="https://elixir.bootlin.com/">https://elixir.bootlin.com/</a>。</p>
<p>LXR 允许在任意文本或文件名上搜索标识符（符号）。它提供的主要特点和优势是可以轻松地找到任何全局标识符的声明。这样，它便于快速访问函数声明、变量、宏定义，以及轻松地浏览代码。此外，它还能够检测当变量或函数发生变化时，哪些代码区域会受到影响，这对于开发和调试阶段是一个真正的优势。</p>
</div>
<div class="section" id="sourceweb">
<h3>SourceWeb<a class="headerlink" href="#sourceweb" title="永久链接至标题">¶</a></h3>
<p><a class="reference external" href="http://rprichard.github.io/sourceweb/">SourceWeb</a> 是一个用于 C 和 C++ 的源代码索引器。它使用 Clang 编译器提供的 <a class="reference external" href="http://clang.llvm.org/docs/IntroductionToTheClangAST.html">框架</a> 来索引代码。</p>
<p>cscope 和 SourceWeb 之间的主要区别在于，SourceWeb 在某种程度上是一个编译器插件。SourceWeb 不会索引所有的代码，而只会索引实际被编译器编译的代码。这样的话，一些问题就没有了，例如在多个位置定义的函数变体中的的哪个被使用的歧义。这也意味着索引需要更多的时间，因为编译后的文件必须再次通过索引器以生成引用。</p>
<p>使用示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>make oldconfig
sw-btrace make -j4
sw-btrace-to-compile-db
sw-clang-indexer --index-project
sourceweb index
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">sw-btrace</span></code> 是一个添加 <code class="file docutils literal"><span class="pre">libsw-btrace.so</span></code> 库到 <code class="code docutils literal"><span class="pre">LD_PRELOAD</span></code> 的脚本。这样，该库将被 <code class="code docutils literal"><span class="pre">make</span></code> 启动的每个进程（基本上是编译器）加载， 注册用于启动进程的命令，并生成一个名为 <code class="file docutils literal"><span class="pre">btrace.log</span></code> 的文件。然后，<code class="code docutils literal"><span class="pre">sw-btrace-to-compile-db</span></code> 使用该文件将其转换为 clang 定义的格式： <a class="reference external" href="http://clang.llvm.org/docs/JSONCompilationDatabase.html">JSON Compilation Database</a> 。 然后上述步骤生成的 JSON 编译数据库由索引器使用，索引器通过已编译的源文件再进行一次遍历，生成 GUI 使用的索引。</p>
<p>建议：不要对正在使用的源代码进行索引，而是使用其副本，因为 SourceWeb 目前没有单独重新生成单个文件的索引的功能，你将不得不重新生成完整的索引。</p>
</div>
</div>
<div class="section" id="section-7">
<h2>内核调试<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h2>
<p>与调试程序相比，调试内核是一个更加困难的过程，因为操作系统没有提供支持。这就是为什么通常使用两台通过串行接口相互连接的计算机进行此过程。</p>
<div class="section" id="gdb-linux">
<span id="gdb-intro"></span><h3>gdb（Linux）<a class="headerlink" href="#gdb-linux" title="永久链接至标题">¶</a></h3>
<p>在 Linux 上，一种更简单但也具有许多缺点的调试方法是使用 <a class="reference external" href="http://www.gnu.org/software/gdb/">gdb</a> 进行本地调试，其中涉及到未压缩的内核镜像（<code class="file docutils literal"><span class="pre">vmlinux</span></code> ）和文件：<code class="file docutils literal"><span class="pre">/proc/kcore</span></code> （实时内核镜像）。这种方法通常用于检查内核并在其运行时检测特定的不一致性。特别是如果内核是使用 <code class="code docutils literal"><span class="pre">-g</span></code> 选项编译的（该选项会保留调试信息）这种方法就非常有用。但是，这种方法无法使用一些众所周知的调试技术，例如数据修改的断点。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>因为 <code class="file docutils literal"><span class="pre">/proc</span></code> 是一个虚拟文件系统，<code class="file docutils literal"><span class="pre">/proc/kcore</span></code> 在磁盘上并不存在。当程序尝试访问 <code class="file docutils literal"><span class="pre">/proc/kcore</span></code> 时，内核会即时生成它。它用于调试目的。</p>
<p>根据 <strong class="command">man proc</strong> 的说明：</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>/proc/kcore
此文件代表系统的物理内存，并以 ELF 核心文件格式存储。借助这个伪文件（pseudo-file）和未剥离（unstripped）的内核（/usr/src/linux/vmlinux）二进制文件，可以使用 GDB 来检查任何内核数据结构的当前状态。
</pre></div>
</div>
</div>
<p>未压缩的内核镜像提供关于其中所包含的数据结构和符号的信息。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ <span class="nb">cd</span> ~/src/linux
student@eg106$ file vmlinux
vmlinux: ELF <span class="m">32</span>-bit LSB executable, Intel <span class="m">80386</span>, ...
student@eg106$ nm vmlinux <span class="p">|</span> grep sys_call_table
c02e535c R sys_call_table
student@eg106$ cat System.map <span class="p">|</span> grep sys_call_table
c02e535c R sys_call_table
</pre></div>
</div>
<p><strong class="command">nm</strong> 程序用于显示对象或可执行文件中的符号。在我们的例子中，<code class="file docutils literal"><span class="pre">vmlinux</span></code> 是一个 ELF 文件。或者，我们可以使用文件 <code class="file docutils literal"><span class="pre">System.map</span></code> 来查看内核中的符号信息。</p>
<p>然后，我们使用 <strong class="command">gdb</strong> 来使用未压缩的内核镜像检查这些符号。一个简单的 <strong class="command">gdb</strong> 会话如下所示：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ <span class="nb">cd</span> ~/src/linux
stduent@eg106$ gdb --quiet vmlinux
Using host libthread_db library <span class="s2">&quot;/lib/tls/libthread_db.so.1&quot;</span>.
<span class="o">(</span>gdb<span class="o">)</span> x/x 0xc02e535c
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58
<span class="o">(</span>gdb<span class="o">)</span> x/16 0xc02e535c
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sb">`</span>&lt;sys_call_table+16&gt;<span class="sb">`</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sb">`</span>&lt;sys_call_table+32&gt;<span class="sb">`</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sb">`</span>&lt;sys_call_table+48&gt;<span class="sb">`</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="o">(</span>gdb<span class="o">)</span> x/x sys_call_table
0xc011bc58 <span class="sb">`</span>&lt;sys_restart_syscall&gt;<span class="sb">`</span>:       0xffe000ba
<span class="o">(</span>gdb<span class="o">)</span> x/x <span class="p">&amp;</span>sys_call_table
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58
<span class="o">(</span>gdb<span class="o">)</span> x/16 <span class="p">&amp;</span>sys_call_table
0xc02e535c <span class="sb">`</span>&lt;sys_call_table&gt;<span class="sb">`</span>:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c <span class="sb">`</span>&lt;sys_call_table+16&gt;<span class="sb">`</span>: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c <span class="sb">`</span>&lt;sys_call_table+32&gt;<span class="sb">`</span>: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c <span class="sb">`</span>&lt;sys_call_table+48&gt;<span class="sb">`</span>: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
<span class="o">(</span>gdb<span class="o">)</span> x/x sys_fork
0xc01013d3 <span class="sb">`</span>&lt;sys_fork&gt;<span class="sb">`</span>:  0x3824548b
<span class="o">(</span>gdb<span class="o">)</span> disass sys_fork
Dump of assembler code <span class="k">for</span> <span class="k">function</span> sys_fork:
0xc01013d3 <span class="sb">`</span>&lt;sys_fork+0&gt;<span class="sb">`</span>:        mov    0x38<span class="o">(</span>%esp<span class="o">)</span>,%edx
0xc01013d7 <span class="sb">`</span>&lt;sys_fork+4&gt;<span class="sb">`</span>:        mov    <span class="nv">$0</span>x11,%eax
0xc01013dc <span class="sb">`</span>&lt;sys_fork+9&gt;<span class="sb">`</span>:        push   <span class="nv">$0</span>x0
0xc01013de <span class="sb">`</span>&lt;sys_fork+11&gt;<span class="sb">`</span>:       push   <span class="nv">$0</span>x0
0xc01013e0 <span class="sb">`</span>&lt;sys_fork+13&gt;<span class="sb">`</span>:       push   <span class="nv">$0</span>x0
0xc01013e2 <span class="sb">`</span>&lt;sys_fork+15&gt;<span class="sb">`</span>:       lea    0x10<span class="o">(</span>%esp<span class="o">)</span>,%ecx
0xc01013e6 <span class="sb">`</span>&lt;sys_fork+19&gt;<span class="sb">`</span>:       call   0xc0111aab <span class="sb">`</span>&lt;do_fork&gt;<span class="sb">`</span>
0xc01013eb <span class="sb">`</span>&lt;sys_fork+24&gt;<span class="sb">`</span>:       add    <span class="nv">$0</span>xc,%esp
0xc01013ee <span class="sb">`</span>&lt;sys_fork+27&gt;<span class="sb">`</span>:       ret
End of assembler dump.
</pre></div>
</div>
<p>可以注意到未压缩的内核映像被用作 <strong class="command">gdb</strong> 的参数。在编译后，可以在内核源代码的根目录中找到该映像。</p>
<p>使用 <strong class="command">gdb</strong> 进行调试的几个命令如下：</p>
<ul class="simple">
<li><strong class="command">x</strong> （examine）——用于显示指定地址的内存区域的内容（该地址可以是物理地址的值、符号或符号的地址）。它可以接受以下参数（以 <code class="code docutils literal"><span class="pre">/</span></code> 开头）：要显示数据的格式（<code class="code docutils literal"><span class="pre">x</span></code> 表示十六进制，<code class="code docutils literal"><span class="pre">d</span></code> 表示十进制，等等）、要显示的内存单元（memory unit）数量以及单个内存单元的大小。</li>
<li><strong class="command">disassemble</strong> ——用于反汇编函数。</li>
<li><strong class="command">p</strong> （print）——用于评估并显示表达式的值。可以通过参数指定要显示数据的格式（<code class="code docutils literal"><span class="pre">/x</span></code> 表示十六进制，<code class="code docutils literal"><span class="pre">/d</span></code> 表示十进制，等等）。</li>
</ul>
<p>对内核映像的分析是一种静态分析方法。如果我们想进行动态分析（分析内核的运行情况，而不仅仅是静态映像），我们可以使用 <code class="file docutils literal"><span class="pre">/proc/kcore</span></code>；这是内核的动态映像（存储在内存中）。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>student@eg106$ gdb ~/src/linux/vmlinux /proc/kcore
Core was generated by `root=/dev/hda3 ro&#39;.
#0  0x00000000 in ?? ()
(gdb) p sys_call_table
$1 = -1072579496
(gdb) p /x sys_call_table
$2 = 0xc011bc58
(gdb) p /x &amp;sys_call_table
$3 = 0xc02e535c
(gdb) x/16 &amp;sys_call_table
0xc02e535c `&lt;sys_call_table&gt;`:    0xc011bc58      0xc011482a      0xc01013d3     0xc014363d
0xc02e536c `&lt;sys_call_table+16&gt;`: 0xc014369f      0xc0142d4e      0xc0142de5     0xc011548b
0xc02e537c `&lt;sys_call_table+32&gt;`: 0xc0142d7d      0xc01507a1      0xc015042c     0xc0101431
0xc02e538c `&lt;sys_call_table+48&gt;`: 0xc014249e      0xc0115c6c      0xc014fee7     0xc0142725
</pre></div>
</div>
<p>使用内核的动态镜像有助于检测 <a class="reference external" href="http://zh.wikipedia.org/wiki/Rootkit">rootkit</a> 。</p>
<ul class="simple">
<li><a class="reference external" href="http://linuxdriver.co.il/ldd3/linuxdrive3-CHP-4-SECT-6.html">Linux设备驱动程序第 3 版——调试器和相关工具</a></li>
<li><a class="reference external" href="http://www.securityfocus.com/infocus/1811">在 Linux 中检测 Rootkit 和内核级入侵</a></li>
<li><a class="reference external" href="http://user-mode-linux.sf.net/">用户模式 Linux</a></li>
</ul>
</div>
<div class="section" id="section-8">
<h3>获取堆栈跟踪<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p>有时，你需要获取有关执行路径到达某个特定点的信息。你可以使用 <strong class="command">cscope</strong> 或 LXR 来确定这些信息，但某些函数从许多执行路径调用，这使得这种方法变得困难。</p>
<p>在这些情况下，使用函数 <code class="code docutils literal"><span class="pre">dump_stack()</span></code> 获取堆栈跟踪非常有用。</p>
</div>
</div>
<div class="section" id="section-9">
<h2>文档<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h2>
<p>与用户空间编程相比，内核开发是一个困难的过程。内核的 API 和用户空间不同，内核子系统的复杂性也更高，因此需要额外的准备工作。相关的文档比较零散，有时候需要查阅多个来源才能对某个方面有较全面的了解。</p>
<p>Linux 内核的主要优势是可以访问源代码和其开放式开发系统。因此，互联网上提供了大量的内核文档。</p>
<p>以下是与 Linux 内核相关的一些链接：</p>
<ul class="simple">
<li><a class="reference external" href="http://kernelnewbies.org">KernelNewbies</a></li>
<li><a class="reference external" href="http://kernelnewbies.org/KernelHacking">KernelNewbies——内核编程</a></li>
<li><a class="reference external" href="http://www.tldp.org/HOWTO/KernelAnalysis-HOWTO.html">内核分析——HOWTO</a></li>
<li><a class="reference external" href="http://web.archive.org/web/20090228191439/http://www.linuxhq.com/lkprogram.html">Linux 内核编程</a></li>
<li><a class="reference external" href="http://en.wikibooks.org/wiki/Linux_kernel">Linux 内核——Wikibooks</a></li>
</ul>
<p>这些链接并不全面。使用 <a class="reference external" href="http://www.google.com">互联网</a> 和 <a class="reference external" href="http://lxr.free-electrons.com/">内核源代码</a> 是必不可少的。</p>
</div>
<div class="section" id="section-10">
<h2>练习<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h2>
<div class="section" id="section-11">
<h3>备注<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<ul class="last simple">
<li>通常，开发内核模块的步骤如下：<ul>
<li>编辑模块源代码（在物理机上）；</li>
<li>编译模块（在物理机上）；</li>
<li>生成用于虚拟机的最小镜像；该镜像包含内核、你的模块、busybox 以及测试程序；</li>
<li>使用 QEMU 启动虚拟机；</li>
<li>在虚拟机中运行测试。</li>
</ul>
</li>
<li>当使用 cscope 时，请使用文件 <code class="file docutils literal"><span class="pre">~/src/linux</span></code>。如果没有文件 <code class="file docutils literal"><span class="pre">cscope.out</span></code>，可以使用命令 <strong class="command">make ARCH=x86 cscope</strong> 来生成它。</li>
<li>你可以在 <a class="reference internal" href="../info/vm.html#vm-link"><span class="std std-ref">虚拟机配置</span></a> 找到有关虚拟机的更多详细信息。</li>
</ul>
</div>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p class="last">在解决练习之前，<a href="#system-message-1"><span class="problematic" id="problematic-1">**</span></a>仔细**阅读所有要点。</p>
</div>
</div>
<div class="section" id="section-12">
<h3>启动虚拟机<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h3>
<p>虚拟机基础设施摘要：</p>
<ul class="simple">
<li><code class="file docutils literal"><span class="pre">~/src/linux</span></code> ——Linux 内核源代码，用于编译模块。该目录包含文件 <code class="file docutils literal"><span class="pre">cscope.out</span></code>，用于在源代码树中导航。</li>
<li><code class="file docutils literal"><span class="pre">~/src/linux/tools/labs/qemu</span></code> ——用于生成和运行 QEMU 虚拟机的脚本和辅助文件。</li>
</ul>
<p>要启动虚拟机，请在目录 <code class="file docutils literal"><span class="pre">~/src/linux/tools/labs</span></code> 中运行 <strong class="command">make boot</strong>：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>student@eg106:~$ <span class="nb">cd</span> ~/src/linux/tools/labs
student@eg106:~/src/linux/tools/labs$ make boot
</pre></div>
</div>
<p>默认情况下，你将不会获得提示符或任何图形界面，但你可以使用 <strong class="command">minicom</strong> 或 <strong class="command">screen</strong> 连接到虚拟机提供的控制台。</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>student@eg106:~/src/linux/tools/labs$ minicom -D serial.pts

&lt;按回车键&gt;

qemux86 login:
Poky <span class="o">(</span>Yocto Project Reference Distro<span class="o">)</span> <span class="m">2</span>.3 qemux86 /dev/hvc0
</pre></div>
</div>
<p>另外，也可以使用命令 <strong class="command">QEMU_DISPLAY=gtk make boot</strong> 启动虚拟机，这种情况下虚拟机带有图形界面支持。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">要访问虚拟机，请在登录提示符处输入用户名 <code class="code docutils literal"><span class="pre">root</span></code>；无需输入密码。虚拟机将以 root 帐户的权限启动。</p>
</div>
</div>
<div class="section" id="section-13">
<h3>添加和使用虚拟磁盘<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">如果你没有文件 <code class="file docutils literal"><span class="pre">mydisk.img</span></code>，你可以从地址 <a class="reference external" href="http://elf.cs.pub.ro/so2/res/laboratoare/mydisk.img">http://elf.cs.pub.ro/so2/res/laboratoare/mydisk.img</a> 下载它。该文件必须放在 <code class="file docutils literal"><span class="pre">tools/labs</span></code> 目录下。</p>
</div>
<p>在 <code class="file docutils literal"><span class="pre">~/src/linux/tools/labs</span></code> 目录下，有一个新的虚拟机磁盘，文件名为 <code class="file docutils literal"><span class="pre">mydisk.img</span></code>。我们想要将该磁盘添加到虚拟机并在虚拟机中使用它。</p>
<p>编辑 <code class="file docutils literal"><span class="pre">qemu/Makefile</span></code> 文件，在 <code class="code docutils literal"><span class="pre">QEMU_OPTS</span></code> 变量中添加 <code class="code docutils literal"><span class="pre">-drive</span> <span class="pre">file=mydisk.img,if=virtio,format=raw</span></code>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">qemu 中已经添加了两个磁盘（disk1.img 和 disk2.img）。你需要在它们之后添加新的磁盘。在这种情况下，新的磁盘可以通过 <code class="file docutils literal"><span class="pre">/dev/vdd</span></code> 访问（vda 是根分区，vdb 是 disk1，vdc 是 disk2）。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">你不需要在 <code class="file docutils literal"><span class="pre">/dev</span></code> 中手动创建新磁盘的条目，因为虚拟机使用的是 <strong class="command">devtmpfs</strong>。</p>
</div>
<p>在 <code class="file docutils literal"><span class="pre">tools/labs</span></code> 目录下运行 <code class="code docutils literal"><span class="pre">make</span></code> 命令以启动虚拟机。创建 <code class="file docutils literal"><span class="pre">/test</span></code> 目录，并尝试挂载新的磁盘：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>mkdir /test
mount /dev/vdd /test
</pre></div>
</div>
<p>我们无法挂载该虚拟磁盘的原因是，内核不支持 <code class="file docutils literal"><span class="pre">mydisk.img</span></code> 的文件系统。你需要识别出 <code class="file docutils literal"><span class="pre">mydisk.img</span></code> 的文件系统类型，并在编译内核时在内核中添加对该文件系统的支持。</p>
<p>关闭虚拟机（关闭 QEMU 窗口，无需使用其他命令）。在物理机上使用 <strong class="command">file</strong> 命令查看 <code class="file docutils literal"><span class="pre">mydisk.img</span></code> 文件的文件系统类型。可以识别出它是 <strong class="command">btrfs</strong> 文件系统。</p>
<p>你需要在内核中启用 <strong class="command">btrfs</strong> 支持并重新编译内核镜像。</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>如果在执行 <strong class="command">make menuconfig</strong> 命令时收到错误提示，可能是因为你没有安装 <strong class="command">libncurses5-dev</strong> 包。使用以下命令安装它：</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>sudo apt-get install libncurses5-dev
</pre></div>
</div>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>进入 <code class="file docutils literal"><span class="pre">~/src/linux/</span></code> 子目录。运行 <strong class="command">make menuconfig</strong> 命令，进入 <em>File systems</em> 部分。启用 <em>Btrfs filesystem support</em> 选项。你需要使用内置选项（而不是模块），即 <strong class="command">&lt;*&gt;</strong> 必须出现在选项旁边（<strong>不是</strong> <strong class="command">&lt;M&gt;</strong>）。</p>
<p>保存你所做的配置。使用默认配置文件（<code class="file docutils literal"><span class="pre">config</span></code>）。</p>
<p>在内核源代码子目录（<code class="file docutils literal"><span class="pre">~/src/linux/</span></code>）中使用以下命令重新编译：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>make
</pre></div>
</div>
<p>为了加快速度，你可以使用 <strong class="command">-j</strong> 选项并行运行多个任务。通常建议使用 <strong class="command">CPU 数量+1</strong>：</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>make -j5
</pre></div>
</div>
</div>
<p>内核重新编译完成后，<strong>重新启动</strong> QEMU 虚拟机：也就是在子目录中执行 <strong class="command">make</strong> 命令。你无需复制任何内容，因为 <code class="file docutils literal"><span class="pre">bzImage</span></code> 文件正指向你刚刚重新编译的内核映像的符号链接。</p>
<p>在 QEMU 虚拟机内部，重复执行 <strong class="command">mkdir</strong> 和 <strong class="command">mount</strong> 操作。有了 <strong class="command">btrfs</strong> 文件系统的支持，现在 <strong class="command">mount</strong> 命令将成功完成。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在做作业时，无需重新编译内核，因为你只会使用内核模块。然而，熟悉配置和重新编译内核很重要。</p>
</div>
<p>如果你仍然想重新编译内核，请备份 <code class="file docutils literal"><span class="pre">bzImage</span></code> 文件（在 ~/src/linux 的链接中有完整路径）。这将允许你返回到初始配置，以便拥有与 vmchecker 所使用的环境完全相同的环境。</p>
</div>
<div class="section" id="gdb-qemu">
<h3>GDB 和 QEMU<a class="headerlink" href="#gdb-qemu" title="永久链接至标题">¶</a></h3>
<p>我们可以实时对 QEMU 虚拟机进行调查和排除问题 。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>你还可以使用 <strong class="command">GDB Dashboard</strong> 插件，以获得友好的界面。<strong class="command">gdb</strong> 在编译时必须添加对 Python 的支持。</p>
<p>要想安装它，你只需运行：</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>wget -P ~ git.io/.gdbinit
</pre></div>
</div>
</div>
<p>为此，我们首先启动 QEMU 虚拟机。然后，我们可以使用以下命令通过 <strong class="command">gdb</strong> 连接到**正在运行的 QEMU 虚拟机**：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>make gdb
</pre></div>
</div>
<p>我们在 QEMU 命令中使用了 <strong class="command">-s</strong> 参数，这意味着 QEMU 会监听 <code class="code docutils literal"><span class="pre">1234</span></code> 端口等待 <strong class="command">gdb</strong> 的连接。我们可以使用 <strong class="command">gdb</strong> 的 <strong>远程目标</strong> 功能来进行调试。现有的 <code class="file docutils literal"><span class="pre">Makefile</span></code> 已经帮我们处理了相关细节。</p>
<p>当你附加调试器到一个进程时，该进程会暂停。你可以添加断点并检查进程的当前状态。</p>
<p>附加到 QEMU 虚拟机（使用 <strong class="command">make gdb</strong> 命令）并在 <strong class="command">gdb</strong> 控制台中使用以下命令在 <code class="code docutils literal"><span class="pre">sys_access</span></code> 函数中设置断点：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>break sys_access
</pre></div>
</div>
<p>此时，虚拟机已暂停。要继续执行（直到可能调用 <code class="code docutils literal"><span class="pre">sys_access</span></code> 函数），请在 <strong class="command">gdb</strong> 控制台中使用命令：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>continue
</pre></div>
</div>
<p>此时，虚拟机处于活动状态并具有可用的控制台。要进行 <code class="code docutils literal"><span class="pre">sys_access</span></code> 调用，我们使用 <strong class="command">ls</strong> 命令。请注意，此时虚拟机再次被 <strong class="command">gdb</strong> 暂停，并且在 <strong class="command">gdb</strong> 控制台中出现了相应的 <code class="code docutils literal"><span class="pre">sys_access</span></code> 回调消息。</p>
<p>使用 <strong class="command">step</strong> 、<strong class="command">continue</strong> 或 <strong class="command">next</strong> 指令逐步跟踪代码执行。你可能不完全理解整个执行过程，所以可以使用 <strong class="command">list</strong> 和 <strong class="command">backtrace</strong> 等命令来跟踪执行流程。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">在 <strong class="command">gdb</strong> 提示符处，你可以按 <strong class="command">Enter</strong>
（不输入其他内容）来重新运行上一条命令。</p>
</div>
</div>
<div class="section" id="gdb">
<h3>4. GDB 探索<a class="headerlink" href="#gdb" title="永久链接至标题">¶</a></h3>
<p>使用 <cite>gdb</cite> 命令显示创建内核线程（<cite>kernel_thread</cite>）的函数的源代码。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>你可以使用 GDB 进行静态内核分析，在内核源代码目录中执行类似以下命令：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>gdb vmlinux
</pre></div>
</div>
<p class="last">请参阅实验中的 <a class="reference external" href="#gdb-linux">gdb (Linux)</a> 部分。</p>
</div>
<p>使用 <cite>gdb</cite> 命令找到 <cite>jiffies</cite> 变量在内存中的地址和内容。<code class="code docutils literal"><span class="pre">jiffies</span></code> 变量保存了系统启动以来的时钟节拍数。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>要跟踪 jiffies 变量的值，可以在 <strong class="command">gdb</strong> 中使用动态分析，运行以下命令：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>make gdb
</pre></div>
</div>
<p>就像前面的练习一样。</p>
<p class="last">请参阅实验室中的 <a class="reference external" href="#gdb-linux">gdb (Linux)</a> 部分。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p><code class="code docutils literal"><span class="pre">jiffies</span></code> 是一个 64 位变量。
可以发现它的地址与 <code class="code docutils literal"><span class="pre">jiffies_64</span></code> 变量相同。</p>
<p>要查看 64 位变量的内容，请在 <strong class="command">gdb</strong> 控制台中使用以下命令：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>x/gx &amp; jiffies
</pre></div>
</div>
<p>如果要显示 32 位变量的内容，可以在 <strong class="command">gdb</strong> 控制台中使用以下命令：</p>
<div class="last highlight-none"><div class="highlight"><pre><span></span>x/wx &amp; jiffies
</pre></div>
</div>
</div>
<p><a href="#system-message-2"><span class="problematic" id="problematic-2">``</span></a><a href="#system-message-3"><span class="problematic" id="problematic-3">`</span></a></p>
</div>
<div class="section" id="cscope-1">
<h3>5. Cscope 探索<a class="headerlink" href="#cscope-1" title="永久链接至标题">¶</a></h3>
<p>使用 LXR 或 cscope 在 <code class="file docutils literal"><span class="pre">~/src/linux/</span></code> 目录下查找特定结构或函数的位置。</p>
<p>已生成 Cscope 索引文件。使用 <strong class="command">vim</strong> 和其他相关命令来滚动浏览源代码。例如，使用以下命令：</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>vim
</pre></div>
</div>
<p>打开 <strong class="command">vim</strong> 编辑器。然后，在编辑器内部使用以下命令：</p>
<p><strong class="command">:cs find g task_struct</strong></p>
<p>找到定义以下数据类型的文件：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code></li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">semaphore</span></code></li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">list_head</span></code></li>
<li><code class="docutils literal"><span class="pre">spinlock_t</span></code></li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">file_system_type</span></code></li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>对于特定结构，只需搜索其名称。</p>
<p class="last">例如，在 <strong class="command">struct task_struct</strong> 的情况下，搜索 <strong class="command">task_struct</strong> 字符串。</p>
</div>
<p>通常，你会得到更多匹配项。要找到你感兴趣的匹配项，请执行以下操作：</p>
<ol class="arabic simple">
<li>使用 <strong class="command">vim</strong> 的 <strong class="command">:copen</strong> 命令列出所有匹配项。</li>
<li>通过查找左括号（<strong class="command">{</strong>），即结构定义行上的单个字符，找到正确的匹配项，要搜索左括号，可以在 <strong class="command">vim</strong> 中使用 <strong class="command">/{</strong>。</li>
<li>在相应的行上，按下 <strong class="command">Enter</strong> 键进入定义变量的源代码。</li>
<li>使用命令 <strong class="command">:cclose</strong> 关闭次要窗口。</li>
</ol>
<p>找到声明以下全局内核变量的文件：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">sys_call_table</span></code></li>
<li><code class="docutils literal"><span class="pre">file_systems</span></code></li>
<li><code class="docutils literal"><span class="pre">current</span></code></li>
<li><code class="docutils literal"><span class="pre">chrdevs</span></code></li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>要做到这一点，使用带有以下语法的 <strong class="command">vim</strong> 命令：</p>
<p><strong class="command">:cs f g &lt;symbol&gt;</strong></p>
<p class="last">其中 <strong class="command">&lt;symbol&gt;</strong> 是要搜索的符号的名称。</p>
</div>
<p>找到声明以下函数的文件：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">copy_from_user</span></code></li>
<li><code class="docutils literal"><span class="pre">vmalloc</span></code></li>
<li><code class="docutils literal"><span class="pre">schedule_timeout</span></code></li>
<li><code class="docutils literal"><span class="pre">add_timer</span></code></li>
</ul>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>要做到这一点，使用带有以下语法的 <strong class="command">vim</strong> 命令：</p>
<p><strong class="command">:cs f g &lt;symbol&gt;</strong></p>
<p class="last">其中:command:<a href="#system-message-4"><span class="problematic" id="problematic-4">`</span></a>&lt;symbol&gt;`是要搜索的符号的名称。</p>
</div>
<p>顺序浏览以下的数据结构：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code></li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code></li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code></li>
<li><code class="docutils literal"><span class="pre">struct</span> <span class="pre">vm_operations_struct</span></code></li>
</ul>
<p>也就是说，你访问一个结构，然后找到其中具有下一个结构数据类型的字段，访问相应的字段，依此类推。注意这些结构定义在哪些文件中；这将对接下来的实验有用。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>要在 <strong class="command">vim</strong> 中搜索符号（<strong class="command">vim</strong> 带有 <strong class="command">cscope</strong> 支持），可以将光标放在符号上，并使用键盘快捷键 <strong class="command">Ctrl+]</strong>。</p>
<p>要返回到上一个匹配项（在搜索/跳转之前的匹配项），请使用键盘快捷键 <strong class="command">Ctrl+o</strong>。</p>
<p class="last">要向前进行搜索（返回到 <strong class="command">Ctrl+o</strong> 之前的匹配项），请使用键盘快捷键 <strong class="command">Ctrl+i</strong>。</p>
</div>
<p>按照上述说明，找到并浏览以下函数调用序列：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">bio_alloc</span></code></li>
<li><code class="docutils literal"><span class="pre">bio_alloc_bioset</span></code></li>
<li><code class="docutils literal"><span class="pre">bvec_alloc</span></code></li>
<li><code class="docutils literal"><span class="pre">kmem_cache_alloc</span></code></li>
<li><code class="docutils literal"><span class="pre">slab_alloc</span></code></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">阅读实验中的 <a class="reference external" href="#cscope">cscope</a> 或 <a class="reference external" href="#lxr-cross-reference">LXR 交叉引用</a> 部分。</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="infrastructure.html" class="btn btn-neutral float-left" title="基础设施" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kernel_modules.html" class="btn btn-neutral float-right" title="内核模块" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>