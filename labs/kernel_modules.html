<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>内核模块 &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="内核 API" href="kernel_api.html" />
    <link rel="prev" title="介绍" href="introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">Operating Systems 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">内核模块</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-2">实验目标</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-3">内核模块概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-4">内核模块示例</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-5">编译内核模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-6">加载/卸载内核模块</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-7">内核模块调试</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#objdump">objdump</a></li>
<li class="toctree-l3"><a class="reference internal" href="#addr2line">addr2line</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minicom">minicom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#netconsole">netconsole</a></li>
<li class="toctree-l3"><a class="reference internal" href="#printk">Printk 调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-8">动态调试</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#dyndbg-1">Dyndbg 选项</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdb">KDB：内核调试器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-9">练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-10">0. 引言</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-11">1. 内核模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#printk-1">2. Printk</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-12">3. 错误</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">4. 子模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#oops-1">5. 内核 oops</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-14">6. 模块参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-15">7. 进程信息</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#extra-exercises">Extra Exercises</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-16">额外练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#kdb-1">1. KDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ps">2. PS模块</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-17">3. 内存信息</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-18">4. 动态调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-19">5. 初始化期间的动态调试</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux Device Model</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">内核模块</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/kernel_modules.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="section-1">
<h1>内核模块<a class="headerlink" href="#section-1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="section-2">
<h2>实验目标<a class="headerlink" href="#section-2" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>创建简单的模块</li>
<li>描述内核模块编译的过程</li>
<li>展示如何在内核中使用模块</li>
<li>简单的内核调试方法</li>
</ul>
</div>
<div class="section" id="section-3">
<h2>内核模块概述<a class="headerlink" href="#section-3" title="Permalink to this headline">¶</a></h2>
<p>虽然单体内核比微内核更快，但缺乏模块化和可扩展性。在现代单体内核中，这个问题已经通过使用内核模块来解决。内核模块（或可加载内核模式）是一个包含代码的目标文件（object file），它可以在运行时扩展内核的功能（根据需要加载）；当不需要内核模块时，可以卸载它。大多数设备驱动程序以内核模块的形式使用。</p>
<p>为了开发 Linux 设备驱动程序，建议下载内核源代码，配置和编译它们，然后将编译后的版本安装在测试/开发工具机上。</p>
</div>
<div class="section" id="section-4">
<h2>内核模块示例<a class="headerlink" href="#section-4" title="Permalink to this headline">¶</a></h2>
<p>以下是一个非常简单的内核模块示例。当加载到内核中时，它会生成消息 <code class="code docutils literal"><span class="pre">&quot;Hi&quot;</span></code>。当卸载内核模块时，将生成消息 <code class="code docutils literal"><span class="pre">&quot;Bye&quot;</span></code>。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>

<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;My kernel module&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Me&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dummy_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Hi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dummy_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;Bye</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">dummy_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">dummy_exit</span><span class="p">);</span>
</pre></div>
</div>
<p>生成的消息不会显示在控制台上，而是保存在专门预留的内存区域中，由日志守护程序（syslog）负责将其提取出来。要显示内核消息，你可以使用 <cite>dmesg</cite> 命令或检查日志文件。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># cat /var/log/syslog | tail -2</span>
Feb <span class="m">20</span> <span class="m">13</span>:57:38 asgard kernel: Hi
Feb <span class="m">20</span> <span class="m">13</span>:57:43 asgard kernel: Bye

<span class="c1"># dmesg | tail -2</span>
Hi
Bye
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h2>编译内核模块<a class="headerlink" href="#section-5" title="Permalink to this headline">¶</a></h2>
<p>编译内核模块与编译用户程序不同。首先，需要使用另外的头文件。此外，模块不应链接到库。最重要的是，模块必须使用与加载模块的内核相同的选项进行编译。出于这些原因，有一种标准的编译方法（kbuild）。该方法需要使用两个文件： <code class="file docutils literal"><span class="pre">Makefile</span></code> 文件和 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件。</p>
<p>以下是 <code class="file docutils literal"><span class="pre">Makefile</span></code> 文件的示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">KDIR</span> <span class="o">=</span> /lib/modules/<span class="sb">`</span>uname -r<span class="sb">`</span>/build

kbuild:
        make -C <span class="k">$(</span>KDIR<span class="k">)</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>

clean:
        make -C <span class="k">$(</span>KDIR<span class="k">)</span> <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span> clean
</pre></div>
</div>
<p>以下是用于编译模块的 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">EXTRA_CFLAGS</span> <span class="o">=</span> -Wall -g

obj-m        <span class="o">=</span> modul.o
</pre></div>
</div>
<p>正如你所见，在示例中调用 <strong class="command">make</strong> 命令对 <code class="file docutils literal"><span class="pre">Makefile</span></code> 文件进行编译将导致在内核源代码目录（<code class="docutils literal"><span class="pre">/lib/modules/`uname</span> <span class="pre">-r`/build</span></code>）中调用 <strong class="command">make</strong> 并引用当前目录（<code class="docutils literal"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">`pwd</span></code>）。该过程最终会读取当前目录中的 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件，并按照该文件中的指示编译模块。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>对于实验，我们将根据虚拟机的规格配置不同的 <strong class="command">KDIR</strong>：</p>
<div class="last highlight-bash"><div class="highlight"><pre><span></span><span class="nv">KDIR</span> <span class="o">=</span> /home/student/src/linux
<span class="o">[</span>...<span class="o">]</span>
</pre></div>
</div>
</div>
<p><code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件包含一个或多个指令，用于编译内核模块。其中一个最简单的指令示例是 <code class="docutils literal"><span class="pre">obj-m</span> <span class="pre">=</span> <span class="pre">module.o</span></code>。根据该指令，将从 <code class="docutils literal"><span class="pre">module.o</span></code> 文件开始创建一个内核模块（ <code class="code docutils literal"><span class="pre">ko</span></code> ，即 <code class="code docutils literal"><span class="pre">kernel</span> <span class="pre">object</span></code>，也就是内核对象）。<code class="docutils literal"><span class="pre">module.o</span></code> 将基于 <code class="docutils literal"><span class="pre">module.c</span></code> 或 <code class="docutils literal"><span class="pre">module.S</span></code> 创建。所有这些文件都可以在 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 所在的目录中找到。</p>
<p>下面是一个使用多个子模块的 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">EXTRA_CFLAGS</span> <span class="o">=</span> -Wall -g

obj-m        <span class="o">=</span> supermodule.o
supermodule-y <span class="o">=</span> module-a.o module-b.o
</pre></div>
</div>
<p>对于上面的示例，编译步骤如下：</p>
<blockquote>
<div><ul class="simple">
<li>编译 <code class="file docutils literal"><span class="pre">module-a.c</span></code> 和 <code class="file docutils literal"><span class="pre">module-b.c</span></code> 源文件，生成 module-a.o 和 module-b.o 对象文件（object）</li>
<li>然后将 <code class="file docutils literal"><span class="pre">module-a.o</span></code> 和 <code class="file docutils literal"><span class="pre">module-b.o</span></code> 链接到 <code class="file docutils literal"><span class="pre">supermodule.o</span></code></li>
<li>基于 <code class="file docutils literal"><span class="pre">supermodule.o</span></code> 创建 <code class="file docutils literal"><span class="pre">supermodule.ko</span></code> 模块</li>
</ul>
</div></blockquote>
<p><code class="file docutils literal"><span class="pre">Kbuild</span></code> 中目标（target）的后缀决定了它们的用途，如下所示：</p>
<blockquote>
<div><ul class="simple">
<li>M（modules） 标示目标为可加载内核模块</li>
<li>Y（yes） 表示目标是用于编译并链接到模块（<code class="docutils literal"><span class="pre">$(模块名称)-y</span></code>）或内核（<code class="docutils literal"><span class="pre">obj-y</span></code>）的对象文件</li>
<li>其他任何目标后缀都将被 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 忽略，不会被编译</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">这些后缀使得可以通过运行 <strong class="command">make menuconfig</strong> 命令或直接编辑 <code class="file docutils literal"><span class="pre">.config</span></code> 文件来轻松配置内核。该文件设置了一系列变量，用于确定在构建时向内核添加哪些特性。例如，使用 <strong class="command">make menuconfig</strong> 命令添加 BTRFS 支持时，在 <code class="file docutils literal"><span class="pre">.config</span></code> 文件中添加行 <code class="code docutils literal"><span class="pre">CONFIG_BTRFS_FS</span> <span class="pre">=</span> <span class="pre">y</span></code>。BTRFS kbuild 包含了一行 <code class="docutils literal"><span class="pre">obj-$(CONFIG_BTRFS_FS):=</span> <span class="pre">btrfs.o</span></code>，它会转变成 <code class="docutils literal"><span class="pre">obj-y:=</span> <span class="pre">btrfs.o</span></code>。这将编译 <code class="file docutils literal"><span class="pre">btrfs.o</span></code> 对象，并将其链接到内核。如果没有设置变量，该行会转变成 <code class="docutils literal"><span class="pre">obj:=btrfs.o</span></code>，然后被忽略，进而内核构建时不会包含 BTRFS 支持。</p>
</div>
<p>要了解更多详细信息，请参阅内核源代码中的 <code class="file docutils literal"><span class="pre">Documentation/kbuild/makefiles.txt</span></code> 和 <code class="file docutils literal"><span class="pre">Documentation/kbuild/modules.txt</span></code> 文件。</p>
</div>
<div class="section" id="section-6">
<h2>加载/卸载内核模块<a class="headerlink" href="#section-6" title="Permalink to this headline">¶</a></h2>
<p>要加载内核模块，请使用 <strong class="command">insmod</strong> 程序。该程序接收用于编译和链接模块的 <code class="file docutils literal"><span class="pre">*.ko</span></code> 文件的路径作为参数。要从内核中卸载模块请使用 <strong class="command">rmmod</strong> 命令，该命令接收模块名称作为参数。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ insmod module.ko
$ rmmod module.ko
</pre></div>
</div>
<p>加载内核模块时，将执行 <code class="docutils literal"><span class="pre">module_init</span></code> 宏（macro）参数指定的函数。同样，当卸载模块时，将执行 <code class="docutils literal"><span class="pre">module_exit</span></code> 宏参数指定的函数。</p>
<p>下面是一个完整的编译、加载和卸载内核模块的示例：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-lin# ls
Kbuild  Makefile  modul.c

faust:~/lab-01/modul-lin# make
make -C /lib/modules/<span class="sb">`</span>uname -r<span class="sb">`</span>/build <span class="nv">M</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
make<span class="o">[</span><span class="m">1</span><span class="o">]</span>: Entering directory <span class="sb">`</span>/usr/src/linux-2.6.28.4<span class="s1">&#39;</span>
<span class="s1">  LD      /root/lab-01/modul-lin/built-in.o</span>
<span class="s1">  CC [M]  /root/lab-01/modul-lin/modul.o</span>
<span class="s1">  Building modules, stage 2.</span>
<span class="s1">  MODPOST 1 modules</span>
<span class="s1">  CC      /root/lab-01/modul-lin/modul.mod.o</span>
<span class="s1">  LD [M]  /root/lab-01/modul-lin/modul.ko</span>
<span class="s1">make[1]: Leaving directory `/usr/src/linux-2.6.28.4&#39;</span>

faust:~/lab-01/modul-lin# ls
built-in.o  Kbuild  Makefile  modul.c  Module.markers
modules.order  Module.symvers  modul.ko  modul.mod.c
modul.mod.o  modul.o

faust:~/lab-01/modul-lin# insmod modul.ko

faust:~/lab-01/modul-lin# dmesg <span class="p">|</span> tail -1
Hi

faust:~/lab-01/modul-lin# rmmod modul

faust:~/lab-01/modul-lin# dmesg <span class="p">|</span> tail -2
Hi
Bye
</pre></div>
</div>
<p>可以使用 <strong class="command">lsmod</strong> 命令或查看 <code class="file docutils literal"><span class="pre">/proc/modules</span></code> 、 <code class="file docutils literal"><span class="pre">/sys/module</span></code> 目录来获取有关加载到内核中的模块的信息。</p>
</div>
<div class="section" id="section-7">
<h2>内核模块调试<a class="headerlink" href="#section-7" title="Permalink to this headline">¶</a></h2>
<p>与调试常规程序相比，调试内核模块要复杂得多。首先，内核模块中的错误可能导致整个系统阻塞。因此，故障排除的速度会大大降低。为了避免重新启动，建议使用虚拟机（qemu、virtualbox 或者 vmware）。</p>
<p>当插入包含错误的模块到内核中时，它最终会生成一个 <a class="reference external" href="https://zh.wikipedia.org/wiki/Oops_(Linux内核)">内核 oops</a> 。内核 oops 是内核检测到的无效操作，只可能由内核生成。对于稳定的内核版本，这几乎可以肯定意味着模块含有错误。在 oops 出现后，内核仍将继续工作。</p>
<p>出现内核 oops 时，保存生成的消息非常重要。如上所述，内核生成的消息保存在日志中，并可使用 <strong class="command">dmesg</strong> 命令显示。为了确保不丢失任何内核消息，建议直接从控制台插入/测试内核，或定期检查内核消息。值得注意的是，oops 不止可能是由于编程错误，也有可能是硬件错误引起的。</p>
<p>如果发生致命错误，系统无法恢复到稳定状态，将造成 <a class="reference external" href="https://zh.wikipedia.org/wiki/内核错误">内核错误（kernel panic）</a> 。</p>
<p>以下是一个包含错误并会造成 oops 的内核模块示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * 造成 oops 的内核模块</span>
<span class="cm"> */</span>

<span class="cp">#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp"></span>

<span class="n">MODULE_DESCRIPTION</span> <span class="p">(</span><span class="s">&quot;Oops&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span> <span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span> <span class="p">(</span><span class="s">&quot;PSO&quot;</span><span class="p">);</span>

<span class="cp">#define OP_READ         0</span>
<span class="cp">#define OP_WRITE        1</span>
<span class="cp">#define OP_OOPS         OP_WRITE</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_oops_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="mh">0x00001234</span><span class="p">;</span>
<span class="cp">#if OP_OOPS == OP_WRITE</span>
        <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="cp">#elif OP_OOPS == OP_READ</span>
        <span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&quot;value = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#error &quot;Unknown op for oops!&quot;</span>
<span class="cp">#endif</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_oops_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">module_init</span> <span class="p">(</span><span class="n">my_oops_init</span><span class="p">);</span>
<span class="n">module_exit</span> <span class="p">(</span><span class="n">my_oops_exit</span><span class="p">);</span>
</pre></div>
</div>
<p>将此模块插入内核将造成 oops：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# insmod oops.ko
<span class="o">[</span>...<span class="o">]</span>

faust:~/lab-01/modul-oops# dmesg <span class="p">|</span> tail -32
BUG: unable to handle kernel paging request at <span class="m">00001234</span>
IP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span>
  *de <span class="o">=</span> <span class="m">00000000</span>
Oops: <span class="m">0002</span> <span class="o">[</span><span class="c1">#1] PREEMPT DEBUG_PAGEALLOC</span>
last sysfs file: /sys/devices/virtual/net/lo/operstate
Modules linked in: oops<span class="o">(</span>+<span class="o">)</span> netconsole ide_cd_mod pcnet32 crc32 cdrom <span class="o">[</span>last unloaded: modul<span class="o">]</span>

Pid: <span class="m">4157</span>, comm: insmod Not tainted <span class="o">(</span><span class="m">2</span>.6.28.4 <span class="c1">#2) VMware Virtual Platform</span>
EIP: <span class="m">0060</span>:<span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> EFLAGS: <span class="m">00010246</span> CPU: <span class="m">0</span>
EIP is at my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span>
EAX: <span class="m">00000000</span> EBX: fffffffc ECX: c89d4300 EDX: <span class="m">00000001</span>
ESI: c89d4000 EDI: <span class="m">00000000</span> EBP: c5799e24 ESP: c5799e24
 DS: 007b ES: 007b FS: <span class="m">0000</span> GS: <span class="m">0033</span> SS: <span class="m">0068</span>
Process insmod <span class="o">(</span>pid: <span class="m">4157</span>, <span class="nv">ti</span><span class="o">=</span>c5799000 <span class="nv">task</span><span class="o">=</span>c665c780 task.ti<span class="o">=</span>c5799000<span class="o">)</span>
Stack:
 c5799f8c c010102d c72b51d8 0000000c c5799e58 c01708e4 <span class="m">00000124</span> <span class="m">00000000</span>
 c89d4300 c5799e58 c724f448 <span class="m">00000001</span> c89d4300 c5799e60 c0170981 c5799f8c
 c014b698 <span class="m">00000000</span> <span class="m">00000000</span> c5799f78 c5799f20 <span class="m">00000500</span> c665cb00 c89d4300
Call Trace:
 <span class="o">[</span>&lt;c010102d&gt;<span class="o">]</span> ? _stext+0x2d/0x170
 <span class="o">[</span>&lt;c01708e4&gt;<span class="o">]</span> ? __vunmap+0xa4/0xf0
 <span class="o">[</span>&lt;c0170981&gt;<span class="o">]</span> ? vfree+0x21/0x30
 <span class="o">[</span>&lt;c014b698&gt;<span class="o">]</span> ? load_module+0x19b8/0x1a40
 <span class="o">[</span>&lt;c035e965&gt;<span class="o">]</span> ? __mutex_unlock_slowpath+0xd5/0x140
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c014b7aa&gt;<span class="o">]</span> ? sys_init_module+0x8a/0x1b0
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c0240a08&gt;<span class="o">]</span> ? trace_hardirqs_on_thunk+0xc/0x10
 <span class="o">[</span>&lt;c0103407&gt;<span class="o">]</span> ? sysenter_do_call+0x12/0x43
Code: &lt;c7&gt; <span class="m">05</span> <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> <span class="m">03</span> <span class="m">00</span> <span class="m">00</span> <span class="m">00</span> 5d c3 eb 0d <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span> <span class="m">90</span>
EIP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init+0x5/0x20 <span class="o">[</span>oops<span class="o">]</span> SS:ESP <span class="m">0068</span>:c5799e24
---<span class="o">[</span> end trace 2981ce73ae801363 <span class="o">]</span>---
</pre></div>
</div>
<p>虽然相对晦涩，但内核在出现 oops 时提供了有关错误的宝贵信息。第一行：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>BUG: unable to handle kernel paging request at <span class="m">00001234</span>
EIP: <span class="o">[</span>&lt;c89d4005&gt;<span class="o">]</span> my_oops_init + 0x5 / 0x20 <span class="o">[</span>oops<span class="o">]</span>
</pre></div>
</div>
<p>告诉我们错误的原因和生成错误的指令的地址。在我们的例子中，这是对内存的无效访问。</p>
<p>接下来的一行是：</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">Oops:</span> <span class="pre">0002</span> <span class="pre">[#</span> <span class="pre">1]</span> <span class="pre">PREEMPT</span> <span class="pre">DEBUG_PAGEALLOC</span></code></div></blockquote>
<p>告诉我们这是第一个 oops（#1）。在这个上下文中，这很重要，因为一个 oops 可能会导致其他 oops。通常只有第一个 oops 是相关的。此外，oops 代码（ <code class="docutils literal"><span class="pre">0002</span></code> ）提供了有关错误类型的信息（参见 <code class="file docutils literal"><span class="pre">arch/x86/include/asm/trap_pf.h</span></code> ）：</p>
<blockquote>
<div><ul class="simple">
<li>Bit 0 == 0 表示找不到页面，1 表示保护故障</li>
<li>Bit 1 == 0 表示读取，1 表示写入</li>
<li>Bit 2 == 0 表示内核模式，1 表示用户模式</li>
</ul>
</div></blockquote>
<p>在这种情况下，我们有一个写入访问导致了 oops（bit 1 为 1）。</p>
<p>下面是寄存器的转储（dump）。它解码了指令指针 (<code class="docutils literal"><span class="pre">EIP</span></code>) 的值，并指出错误出现在 <code class="code docutils literal"><span class="pre">my_oops_init</span></code> 函数中，偏移为 5 个字节（<code class="docutils literal"><span class="pre">EIP:</span> <span class="pre">[&lt;c89d4005&gt;]</span> <span class="pre">my_oops_init+0x5</span></code>）。该消息还显示了堆栈内容和到目前为止的调用回溯。</p>
<p>如果发生了无效的读取调用 (<code class="docutils literal"><span class="pre">#define</span> <span class="pre">OP_OOPS</span> <span class="pre">OP_READ</span></code>)，消息将是相同的，但是 oops 代码将不同，现在将是 <code class="docutils literal"><span class="pre">0000</span></code>:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# dmesg <span class="p">|</span> tail -33
BUG: unable to handle kernel paging request at <span class="m">00001234</span>
IP: <span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span>
  *de <span class="o">=</span> <span class="m">00000000</span>
Oops: <span class="m">0000</span> <span class="o">[</span><span class="c1">#1] PREEMPT DEBUG_PAGEALLOC</span>
last sysfs file: /sys/devices/virtual/net/lo/operstate
Modules linked in: oops<span class="o">(</span>+<span class="o">)</span> netconsole pcnet32 crc32 ide_cd_mod cdrom

Pid: <span class="m">2754</span>, comm: insmod Not tainted <span class="o">(</span><span class="m">2</span>.6.28.4 <span class="c1">#2) VMware Virtual Platform</span>
EIP: <span class="m">0060</span>:<span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> EFLAGS: <span class="m">00010292</span> CPU: <span class="m">0</span>
EIP is at my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span>
EAX: <span class="m">00000000</span> EBX: fffffffc ECX: c89c3380 EDX: <span class="m">00000001</span>
ESI: c89c3010 EDI: <span class="m">00000000</span> EBP: c57cbe24 ESP: c57cbe1c
 DS: 007b ES: 007b FS: <span class="m">0000</span> GS: <span class="m">0033</span> SS: <span class="m">0068</span>
Process insmod <span class="o">(</span>pid: <span class="m">2754</span>, <span class="nv">ti</span><span class="o">=</span>c57cb000 <span class="nv">task</span><span class="o">=</span>c66ec780 task.ti<span class="o">=</span>c57cb000<span class="o">)</span>
Stack:
 c57cbe34 <span class="m">00000282</span> c57cbf8c c010102d c57b9280 0000000c c57cbe58 c01708e4
 <span class="m">00000124</span> <span class="m">00000000</span> c89c3380 c57cbe58 c5db1d38 <span class="m">00000001</span> c89c3380 c57cbe60
 c0170981 c57cbf8c c014b698 <span class="m">00000000</span> <span class="m">00000000</span> c57cbf78 c57cbf20 <span class="m">00000580</span>
Call Trace:
 <span class="o">[</span>&lt;c010102d&gt;<span class="o">]</span> ? _stext+0x2d/0x170
 <span class="o">[</span>&lt;c01708e4&gt;<span class="o">]</span> ? __vunmap+0xa4/0xf0
 <span class="o">[</span>&lt;c0170981&gt;<span class="o">]</span> ? vfree+0x21/0x30
 <span class="o">[</span>&lt;c014b698&gt;<span class="o">]</span> ? load_module+0x19b8/0x1a40
 <span class="o">[</span>&lt;c035d083&gt;<span class="o">]</span> ? printk+0x0/0x1a
 <span class="o">[</span>&lt;c035e965&gt;<span class="o">]</span> ? __mutex_unlock_slowpath+0xd5/0x140
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c014b7aa&gt;<span class="o">]</span> ? sys_init_module+0x8a/0x1b0
 <span class="o">[</span>&lt;c0140da6&gt;<span class="o">]</span> ? trace_hardirqs_on_caller+0x106/0x150
 <span class="o">[</span>&lt;c0240a08&gt;<span class="o">]</span> ? trace_hardirqs_on_thunk+0xc/0x10
 <span class="o">[</span>&lt;c0103407&gt;<span class="o">]</span> ? sysenter_do_call+0x12/0x43
Code: &lt;a1&gt; <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> c7 <span class="m">04</span> <span class="m">24</span> <span class="m">54</span> <span class="m">30</span> 9c c8 <span class="m">89</span> <span class="m">44</span> <span class="m">24</span> <span class="m">04</span> e8 <span class="m">58</span> a0 <span class="m">99</span> f7 <span class="m">31</span>
EIP: <span class="o">[</span>&lt;c89c3016&gt;<span class="o">]</span> my_oops_init+0x6/0x20 <span class="o">[</span>oops<span class="o">]</span> SS:ESP <span class="m">0068</span>:c57cbe1c
---<span class="o">[</span> end trace 45eeb3d6ea8ff1ed <span class="o">]</span>---
</pre></div>
</div>
<div class="section" id="objdump">
<h3>objdump<a class="headerlink" href="#objdump" title="Permalink to this headline">¶</a></h3>
<p>可以使用 <strong class="command">objdump</strong> 程序找到造成 oops 的指令（instruction）的详细信息。常用的选项有 <strong class="command">-d</strong> 用于反汇编代码， <strong class="command">-S</strong> 用于将 C 代码与汇编语言代码交错显示。然而，为了进行高效的解码，我们需要找到内核模块被加载到的地址。这可以在 <code class="file docutils literal"><span class="pre">/proc/modules</span></code> 中找到。</p>
<p>以下是在上述模块上使用 <strong class="command">objdump</strong> 的示例，以确定造成 oops 的指令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# cat /proc/modules
oops <span class="m">1280</span> <span class="m">1</span> - Loading 0xc89d4000
netconsole <span class="m">8352</span> <span class="m">0</span> - Live 0xc89ad000
pcnet32 <span class="m">33412</span> <span class="m">0</span> - Live 0xc895a000
ide_cd_mod <span class="m">34952</span> <span class="m">0</span> - Live 0xc8903000
crc32 <span class="m">4224</span> <span class="m">1</span> pcnet32, Live 0xc888a000
cdrom <span class="m">34848</span> <span class="m">1</span> ide_cd_mod, Live 0xc886d000

faust:~/lab-01/modul-oops# objdump -dS --adjust-vma<span class="o">=</span>0xc89d4000 oops.ko

oops.ko:     file format elf32-i386


Disassembly of section .text:

c89d4000 &lt;init_module&gt;:
<span class="c1">#define OP_READ         0</span>
<span class="c1">#define OP_WRITE        1</span>
<span class="c1">#define OP_OOPS         OP_WRITE</span>

static int my_oops_init <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4000:       <span class="m">55</span>                      push   %ebp
<span class="c1">#else</span>
<span class="c1">#error &quot;Unknown op for oops!&quot;</span>
<span class="c1">#endif</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
c89d4001:       <span class="m">31</span> c0                   xor    %eax,%eax
<span class="c1">#define OP_READ         0</span>
<span class="c1">#define OP_WRITE        1</span>
<span class="c1">#define OP_OOPS         OP_WRITE</span>

static int my_oops_init <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4003:       <span class="m">89</span> e5                   mov    %esp,%ebp
        int *a<span class="p">;</span>

        <span class="nv">a</span> <span class="o">=</span> <span class="o">(</span>int *<span class="o">)</span> 0x00001234<span class="p">;</span>
<span class="c1">#if OP_OOPS == OP_WRITE</span>
        *a <span class="o">=</span> <span class="m">3</span><span class="p">;</span>
c89d4005:       c7 <span class="m">05</span> <span class="m">34</span> <span class="m">12</span> <span class="m">00</span> <span class="m">00</span> <span class="m">03</span>    movl   <span class="nv">$0</span>x3,0x1234
c89d400c:       <span class="m">00</span> <span class="m">00</span> <span class="m">00</span>
<span class="c1">#else</span>
<span class="c1">#error &quot;Unknown op for oops!&quot;</span>
<span class="c1">#endif</span>

        <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
<span class="o">}</span>
c89d400f:       5d                      pop    %ebp
c89d4010:       c3                      ret
c89d4011:       eb 0d                   jmp    c89c3020 &lt;cleanup_module&gt;
c89d4013:       <span class="m">90</span>                      nop
c89d4014:       <span class="m">90</span>                      nop
c89d4015:       <span class="m">90</span>                      nop
c89d4016:       <span class="m">90</span>                      nop
c89d4017:       <span class="m">90</span>                      nop
c89d4018:       <span class="m">90</span>                      nop
c89d4019:       <span class="m">90</span>                      nop
c89d401a:       <span class="m">90</span>                      nop
c89d401b:       <span class="m">90</span>                      nop
c89d401c:       <span class="m">90</span>                      nop
c89d401d:       <span class="m">90</span>                      nop
c89d401e:       <span class="m">90</span>                      nop
c89d401f:       <span class="m">90</span>                      nop

c89d4020 &lt;cleanup_module&gt;:

static void my_oops_exit <span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
c89d4020:       <span class="m">55</span>                      push   %ebp
c89d4021:       <span class="m">89</span> e5                   mov    %esp,%ebp
<span class="o">}</span>
c89d4023:       5d                      pop    %ebp
c89d4024:       c3                      ret
c89d4025:       <span class="m">90</span>                      nop
c89d4026:       <span class="m">90</span>                      nop
c89d4027:       <span class="m">90</span>                      nop
</pre></div>
</div>
<p>请注意，生成 oops 的指令（先前确定为 <code class="docutils literal"><span class="pre">c89d4005</span></code> ）是：</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">`C89d4005:</span> <span class="pre">c7</span> <span class="pre">05</span> <span class="pre">34</span> <span class="pre">12</span> <span class="pre">00</span> <span class="pre">00</span> <span class="pre">03</span> <span class="pre">movl</span> <span class="pre">$</span> <span class="pre">0x3,0x1234</span></code></div></blockquote>
<p>这正是预期的结果 - 将值 3 存储在地址 0x0001234 上。</p>
<p><code class="file docutils literal"><span class="pre">/proc/modules</span></code> 用于查找加载的内核模块的地址。<strong class="command">--adjust-vma</strong> 选项允许你相对于 <code class="docutils literal"><span class="pre">0xc89d4000</span></code> 位置显示指令。<strong class="command">-l</strong> 选项将显示源代码中每行的编号，源代码与汇编语言代码交错显示。</p>
</div>
<div class="section" id="addr2line">
<h3>addr2line<a class="headerlink" href="#addr2line" title="Permalink to this headline">¶</a></h3>
<p>寻找造成 oops 的代码的一种更简单的方法是使用 <strong class="command">addr2line</strong> 实用程序：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>faust:~/lab-01/modul-oops# addr2line -e oops.o 0x5
/root/lab-01/modul-oops/oops.c:23
</pre></div>
</div>
<p>其中``0x5``是生成 oops 的程序计数器的值（<code class="docutils literal"><span class="pre">EIP</span> <span class="pre">=</span> <span class="pre">c89d4005</span></code>），减去根据 <code class="file docutils literal"><span class="pre">/proc/modules</span></code> 的信息得出的模块的基地址（<code class="docutils literal"><span class="pre">0xc89d4000</span></code>），。</p>
</div>
<div class="section" id="minicom">
<h3>minicom<a class="headerlink" href="#minicom" title="Permalink to this headline">¶</a></h3>
<p><strong class="command">Minicom`（或其他等效程序，例如 :command:`picocom</strong> 以及 <strong class="command">screen</strong> ）是一种用于与串行端口（serial port）连接和交互的程序。串行端口是在开发阶段分析内核消息（kernel message）或与嵌入式系统进行交互的基本方法。有两种常见的连接方式：</p>
<ul class="simple">
<li>使用串行端口，设备路径为 <code class="file docutils literal"><span class="pre">/dev/ttyS0</span></code></li>
<li>使用串行 USB 端口（FTDI），在这种情况下，设备路径为 <code class="file docutils literal"><span class="pre">/dev/ttyUSB</span></code></li>
</ul>
<p>对于实验中使用的虚拟机，在虚拟机启动后，我们需要使用的设备路径将显示在屏幕上：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>char device redirected to /dev/pts/20 <span class="o">(</span>label virtiocon0<span class="o">)</span>
</pre></div>
</div>
<p>使用 Minicom：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 使用 COM1 连接，速率为 115,200 字符/秒</span>
minicom -b <span class="m">115200</span> -D /dev/ttyS0

<span class="c1"># 使用 USB 串行端口连接</span>
minicom -D /dev/ttyUSB0

<span class="c1"># 连接到虚拟机的串行端口</span>
minicom -D /dev/pts/20
</pre></div>
</div>
</div>
<div class="section" id="netconsole">
<h3>netconsole<a class="headerlink" href="#netconsole" title="Permalink to this headline">¶</a></h3>
<p><strong class="command">Netconsole</strong> 是允许通过网络记录内核调试消息的程序。当磁盘日志系统不起作用、串行端口不可用或终端不响应命令时，这非常有用。<strong class="command">Netconsole</strong> 是内核模块。</p>
<p>要想正常工作，它需要以下参数：</p>
<blockquote>
<div><ul class="simple">
<li>调试站点的端口、IP 地址和源接口名称</li>
<li>将调试消息发送到的机器的端口、MAC 地址和 IP 地址</li>
</ul>
</div></blockquote>
<p>这些参数可以在将模块插入内核时进行配置，甚至在模块插入后也可以配置，如果模块在编译时配置了 <code class="docutils literal"><span class="pre">CONFIG_NETCONSOLE_DYNAMIC</span></code> 选项。</p>
<p>插入 <strong class="command">netconsole</strong> 内核模块时的示例配置如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>alice:~# modprobe netconsole <span class="nv">netconsole</span><span class="o">=</span><span class="m">6666</span>@192.168.191.130/eth0,6000@192.168.191.1/00:50:56:c0:00:08
</pre></div>
</div>
<p>因此，在具有地址 <code class="docutils literal"><span class="pre">192.168.191.130</span></code> 的站点上，调试消息将被发送到 <code class="docutils literal"><span class="pre">eth0</span></code> 接口，源端口为``6666``。消息将被发送到``192.168.191.1``，使用 MAC 地址``00:50:56:c0:00:08``，至端口``6000``上。</p>
<p>可以在目标站点上使用 <strong class="command">netcat</strong> 显示消息：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>bob:~ <span class="c1"># nc -l -p 6000 -u</span>
</pre></div>
</div>
<p>或者，目标站点可以配置 <strong class="command">syslogd</strong> 来拦截这些消息。更多信息可以在 <code class="file docutils literal"><span class="pre">Documentation/networking/netconsole.txt</span></code> 中找到。</p>
</div>
<div class="section" id="printk">
<h3>Printk 调试<a class="headerlink" href="#printk" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">最古老且最有用的两种调试辅助工具是你的大脑和</span> <span class="pre">Printf</span></code>。</p>
<p>在调试过程中，通常会使用一种原始但非常有效的方法：<code class="code docutils literal"><span class="pre">printk</span></code> 调试。尽管也可以使用调试器，但通常并不是非常有用：简单的错误（未初始化的变量、内存管理问题等）可以通过控制消息和内核解码的 oops 消息轻松找到。</p>
<p>对于更复杂的错误，即使是调试器也无法提供太多帮助，除非你对操作系统的结构非常熟悉。在调试内核模块时，其中存在许多未知因素：多个上下文（我们同时运行多个进程和线程）、中断以及虚拟内存等等。</p>
<p>你可以使用 <code class="code docutils literal"><span class="pre">printk</span></code> 将内核消息显示到用户空间。它类似于 <code class="code docutils literal"><span class="pre">printf</span></code> 的功能；唯一的区别是传输的消息可以用 <code class="code docutils literal"><span class="pre">&quot;&lt;n&gt;&quot;</span></code> 字符串为前缀，其中 <code class="code docutils literal"><span class="pre">n</span></code> 表示错误级别（日志级别），取值范围为 <code class="docutils literal"><span class="pre">0</span></code> 到 <code class="docutils literal"><span class="pre">7</span></code> 。除了 <code class="code docutils literal"><span class="pre">&quot;&lt;n&gt;&quot;</span></code>，级别也可以用符号常量编码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span>KERN_EMERG——n = 0
KERN_ALERT——n = 1
KERN_CRIT——n = 2
KERN_ERR——n = 3
KERN_WARNING——n = 4
KERN_NOTICE——n = 5
KERN_INFO——n = 6
KERN_DEBUG——n = 7
</pre></div>
</div>
<p>所有日志级别的定义都可以在 <code class="file docutils literal"><span class="pre">linux/kern_levels.h</span></code> 中找到。基本上，系统凭借这些日志级别将消息发送到各种输出：控制台、位于 <code class="file docutils literal"><span class="pre">/var/log</span></code> 中的日志文件等等。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">要在用户空间显示 <code class="code docutils literal"><span class="pre">printk</span></code> 消息，<code class="code docutils literal"><span class="pre">printk</span></code> 日志级别必须比 <cite>console_loglevel</cite> 变量的优先级高。可以从 <code class="file docutils literal"><span class="pre">/proc/sys/kernel/printk</span></code> 配置默认的控制台日志级别。</p>
</div>
<p>例如，以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="m">8</span> &gt; /proc/sys/kernel/printk
</pre></div>
</div>
<p>将使所有内核日志消息在控制台上显示。也就是说，日志级别必须严格小于 <code class="code docutils literal"><span class="pre">console_loglevel</span></code> 变量。例如，如果 <code class="code docutils literal"><span class="pre">console_loglevel</span></code> 的值为 <code class="docutils literal"><span class="pre">5``（指定于</span> <span class="pre">:code:`KERN_NOTICE`），只有比</span> <span class="pre">``5</span></code> 更严格的日志级别的消息（即 <code class="code docutils literal"><span class="pre">KERN_EMERG</span></code> 、<code class="code docutils literal"><span class="pre">KERN_ALERT</span></code> 、<code class="code docutils literal"><span class="pre">KERN_CRIT</span></code> 、<code class="code docutils literal"><span class="pre">KERN_ERR</span></code> 以及 <code class="code docutils literal"><span class="pre">KERN_WARNING</span></code>）将显示。</p>
<p>想要快速查看执行内核代码的效果的话，控制台重定向的消息可能对你很有帮助，但如果内核遇到不可修复的错误并且系统冻结，则不再那么有用。在这种情况下，必须查看系统的日志，因为它们保留从一次系统启动到下一次系统重新启动之间的信息。这些日志文件位于 <code class="file docutils literal"><span class="pre">/var/log</span></code> 中，是由内核运行期间的 <code class="code docutils literal"><span class="pre">syslogd</span></code> 和 <code class="code docutils literal"><span class="pre">klogd</span></code> 填充的文本文件。<code class="code docutils literal"><span class="pre">syslogd</span></code> 和 <code class="code docutils literal"><span class="pre">klogd</span></code> 从挂载在 <code class="file docutils literal"><span class="pre">/proc</span></code> 中的虚拟文件系统中获取信息。原则上，打开 <code class="code docutils literal"><span class="pre">syslogd</span></code> 和 <code class="code docutils literal"><span class="pre">klogd</span></code> 后，来自内核的所有消息都将发送到 <code class="file docutils literal"><span class="pre">/var/log/kern.log</span></code>。</p>
<p>调试的更简单的方法是使用 <code class="file docutils literal"><span class="pre">/var/log/debug</span></code> 文件。它只包含具有 <code class="code docutils literal"><span class="pre">KERN_DEBUG</span></code> 日志级别的内核的 <code class="code docutils literal"><span class="pre">printk</span></code> 消息。</p>
<p>给定一个生产内核（production kernel）（类似于我们可能正在运行的内核），其只包含发布代码，我们的模块是少数几个带有以 KERN_DEBUG 为前缀的消息的模块之一。通过查找与我们的模块的调试会话对应的消息，我们可以轻松浏览 <code class="file docutils literal"><span class="pre">/var/log/debug</span></code> 中的信息。</p>
<p>一个示例如下：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 清除先前信息的调试文件（或可能是备份文件）</span>
$ <span class="nb">echo</span> <span class="s2">&quot;新调试会话&quot;</span> &gt; /var/log/debug
<span class="c1"># 运行测试</span>
<span class="c1"># 如果没有导致内核崩溃的关键错误，检查输出</span>
<span class="c1"># 如果发生关键错误且机器只能通过重新启动来响应，请重新启动系统并检查 /var/log/debug。</span>
</pre></div>
</div>
<p>消息的格式显然必须包含所有相关信息，以便检测错误，但插入代码 <code class="code docutils literal"><span class="pre">printk</span></code> 以提供详细信息可能会花费与编写代码解决问题一样多的时间。通常在使用 <code class="code docutils literal"><span class="pre">printk</span></code> 显示的调试消息的完整性与将这些消息插入文本中所需的时间之间需要有权衡。</p>
<p>一种非常简单、插入 <code class="code docutils literal"><span class="pre">printk</span></code> 更省时并使我们能够分析测试指令流的方法是使用预定义的常量 <code class="code docutils literal"><span class="pre">__FILE__</span></code> 、<code class="code docutils literal"><span class="pre">__LINE__</span></code> 和 <code class="code docutils literal"><span class="pre">__func__</span></code>：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">__FILE__</span></code> 会被编译器替换为当前正在编译的源文件的名称。</li>
<li><code class="docutils literal"><span class="pre">__LINE__</span></code> 会被编译器替换为当前源文件中当前指令所在的行号。</li>
<li><code class="docutils literal"><span class="pre">__func__</span></code> / <code class="docutils literal"><span class="pre">__FUNCTION__</span></code> 会被编译器替换为当前指令所在的函数的名称。</li>
</ul>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="code docutils literal"><span class="pre">__FILE__</span></code> 和 <code class="code docutils literal"><span class="pre">__LINE__</span></code> 是 ANSI C 规范的一部分，<code class="code docutils literal"><span class="pre">__func__</span></code> 是 C99 规范的一部分；<code class="code docutils literal"><span class="pre">__FUNCTION__</span></code> 是 GNU 的一个 C 扩展，不具有可移植性；然而，由于我们编写的代码是针对 Linux 内核的，所以可以毫无问题地使用它们。</p>
</div>
<p>可以在这种情况下使用以下宏定义：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define PRINT_DEBUG \</span>
<span class="cp">       printk (KERN_DEBUG &quot;[% s]: FUNC:% s: LINE:% d \ n&quot;, __FILE__,</span>
               <span class="n">__FUNCTION__</span><span class="p">,</span> <span class="n">__LINE__</span><span class="p">)</span>
</pre></div>
</div>
<p>然后，在每个想要查看执行是否“到达”的位置，插入 PRINT_DEBUG；这是一种简单快捷的方法，通过仔细分析输出可以得出结果。</p>
<p><strong class="command">dmesg</strong> 命令用于查看在控制台上不显示，需要使用 <code class="code docutils literal"><span class="pre">printk</span></code> 来打印的消息。</p>
<p>要删除日志文件中的所有先前消息，请运行：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>cat /dev/null &gt; /var/log/debug
</pre></div>
</div>
<p>要删除 <strong class="command">dmesg</strong> 命令显示的消息，请运行：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>dmesg -c
</pre></div>
</div>
</div>
<div class="section" id="section-8">
<h3>动态调试<a class="headerlink" href="#section-8" title="Permalink to this headline">¶</a></h3>
<p>动态调试（ <a class="reference external" href="https://www.kernel.org/doc/html/v4.15/admin-guide/dynamic-debug-howto.html">dyndbg</a> ）技术可以动态地激活/停用调试。与 <code class="code docutils literal"><span class="pre">printk</span></code> 不同，它提供了更高级的 <code class="code docutils literal"><span class="pre">printk</span></code> 选项，可以用于仅显示我们想要的消息；其对于复杂模块或故障排除子系统非常有用。这显著减少了显示的消息数量，只留下与调试上下文相关的消息。要启用 <code class="docutils literal"><span class="pre">dyndbg</span></code> ，内核必须编译时启用 <code class="docutils literal"><span class="pre">CONFIG_DYNAMIC_DEBUG</span></code> 选项。一旦配置了这个选项，就可以每次调用时动态启用 <code class="code docutils literal"><span class="pre">pr_debug()</span></code> 、 <code class="code docutils literal"><span class="pre">dev_dbg()</span></code> 和 <code class="code docutils literal"><span class="pre">print_hex_dump_debug()</span></code> 、 <code class="code docutils literal"><span class="pre">print_hex_dump_bytes()</span></code>。</p>
<p>debugfs 中的 <code class="file docutils literal"><span class="pre">/sys/kernel/debug/dynamic_debug/control</span></code> 文件可以用于过滤消息或查看现有过滤器。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">mount</span> <span class="o">-</span><span class="n">t</span> <span class="n">debugfs</span> <span class="n">none</span> <span class="o">/</span><span class="n">debug</span>
</pre></div>
</div>
<p><a class="reference external" href="http://opensourceforu.com/2010/10/debugging-linux-kernel-with-debugfs/">Debugfs</a> 是个简单的文件系统，用作内核空间接口和用户空间接口，以配置不同的调试选项。任何调试工具都可以在 debugfs 中创建和使用自己的文件/文件夹。</p>
<p>例如，要显示 <code class="docutils literal"><span class="pre">dyndbg</span></code> 中的现有过滤器，可以使用以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>cat /debug/dynamic_debug/control
</pre></div>
</div>
<p>要启用 <code class="file docutils literal"><span class="pre">svcsock.c</span></code> 文件中第 <code class="docutils literal"><span class="pre">1603</span></code> 行的调试消息：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line 1603 +p&#39;</span> &gt; /debug/dynamic_debug/control
</pre></div>
</div>
<p><code class="file docutils literal"><span class="pre">/debug/dynamic_debug/control</span></code> 文件不是普通文件。它显示了过滤器的 <code class="docutils literal"><span class="pre">dyndbg</span></code> 设置。使用 echo 在其中写入会更改这些设置（实际上不会进行写入）。请注意，该文件包含了 <code class="docutils literal"><span class="pre">dyndbg</span></code> 调试消息的设置。不要在该文件中进行日志记录。</p>
<div class="section" id="dyndbg-1">
<h4>Dyndbg 选项<a class="headerlink" href="#dyndbg-1" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">func</span></code> ——只显示与过滤器中定义的函数名称相同的函数的调试消息。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="s1">&#39;func svc_tcp_accept +p&#39;</span> &gt; /debug/dynamic_debug/control
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">file</span></code> ——要显示调试消息的文件名。可以只是源文件名，也可以是绝对路径或内核树路径。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>file svcsock.c
file kernel/freezer.c
file /usr/src/packages/BUILD/sgi-enhancednfs-1.4/default/net/sunrpc/svcsock.c
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">module</span></code> ——显示模块名称。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>module sunrpc
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">format</span></code> ——只显示显示格式包含指定字符串的消息。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>format <span class="s2">&quot;nfsd: SETATTR&quot;</span>
</pre></div>
</div>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">line</span></code> - 显示调试调用的行号或行号范围。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 在 svcsock.c 文件的第 1603 行到第 1605 行之间触发调试消息</span>
$ <span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line 1603-1605 +p&#39;</span> &gt; /sys/kernel/debug/dynamic_debug/control
<span class="c1"># 从文件开头到第 1605 行启用调试消息</span>
$ <span class="nb">echo</span> <span class="s1">&#39;file svcsock.c line -1605 +p&#39;</span> &gt; /sys/kernel/debug/dynamic_debug/control
</pre></div>
</div>
</li>
</ul>
<p>除了上述选项外，还可以使用操作符 <code class="docutils literal"><span class="pre">+</span></code>、 <code class="docutils literal"><span class="pre">-</span></code> 或 <code class="docutils literal"><span class="pre">=</span></code> 来添加、删除或设置一系列标志：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">p</span></code> 激活 pr_debug()。</li>
<li><code class="docutils literal"><span class="pre">f</span></code> 在打印的消息中包含函数名。</li>
<li><code class="docutils literal"><span class="pre">l</span></code> 在打印的消息中包含行号。</li>
<li><code class="docutils literal"><span class="pre">m</span></code> 在打印的消息中包含模块名称。</li>
<li><code class="docutils literal"><span class="pre">t</span></code> 如果不是从中断上下文调用，则包括线程 ID。</li>
<li><code class="docutils literal"><span class="pre">_</span></code> 不设置标志。</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="kdb">
<h3>KDB：内核调试器<a class="headerlink" href="#kdb" title="Permalink to this headline">¶</a></h3>
<p>内核调试器已被证明在开发和调试过程中非常有用。其主要优势之一是可以进行实时调试。这使得我们能够实时监视对内存的访问，甚至在调试过程中修改内存。内核调试器从版本 2.6.26-rc1 开始，已集成到主线内核中。KDB 不是一个*源代码调试器*，但在进行完整分析时，可以与 gdb 和符号文件并行使用——请参见 <a class="reference internal" href="../so2/lab1-intro.html#gdb-intro"><span class="std std-ref">GDB调试部分</span></a></p>
<p>要使用KDB，你有以下选项：</p>
<blockquote>
<div><ul class="simple">
<li>非 USB 键盘 + VGA 文本控制台</li>
<li>串口控制台</li>
<li>USB EHCI 调试端口</li>
</ul>
</div></blockquote>
<p>在实验中，我们将使用连接到主机的串口接口。以下命令将在串口上激活 GDB：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc
</pre></div>
</div>
<p>KDB 是一种*停止模式调试器*，这意味着在其活动期间，所有其他进程都将停止。可以使用 <a class="reference external" href="http://zh.wikipedia.org/wiki/Magic_SysRq組合鍵">SysRq</a> 命令强制内核在执行过程中进入 KDB</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> g &gt; /proc/sysrq-trigger
</pre></div>
</div>
<p>或者在连接到串口的终端中使用键盘组合键 <a href="#system-message-1"><span class="problematic" id="problematic-1">``</span></a>Ctrl+O g``（例如使用 <strong class="command">minicom</strong>）。</p>
<p>KDB 具有各种命令来控制和定义被调试系统的上下文：</p>
<blockquote>
<div><ul class="simple">
<li>lsmod, ps, kill, dmesg, env, bt（backtrace，回溯）</li>
<li>转储跟踪日志</li>
<li>硬件断点</li>
<li>修改内存</li>
</ul>
</div></blockquote>
<p>要获取有关可用命令的更详细描述，可以在 KDB shell 中使用 <code class="docutils literal"><span class="pre">help</span></code> 命令。在下一个示例中，你可以看到一个简单的 KDB 使用示例，它设置了一个硬件断点来监视 <code class="docutils literal"><span class="pre">mVar</span></code> 变量的更改。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="c1"># 触发 KDB</span>
<span class="nb">echo</span> g &gt; /proc/sysrq-trigger
<span class="c1"># 或者如果我们连接到串口，使用以下命令</span>
Ctrl-O g
<span class="c1"># 在对 mVar 变量进行写访问时设置断点</span>
kdb&gt; bph mVar dataw
<span class="c1"># 从KDB返回</span>
kdb&gt; go
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-9">
<h2>练习<a class="headerlink" href="#section-9" title="Permalink to this headline">¶</a></h2>
<div class="admonition important" id="exercises-summary">
<p class="first admonition-title">Important</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 kernel_modules。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/kernel_modules/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-9">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-10">
<h3>0. 引言<a class="headerlink" href="#section-10" title="Permalink to this headline">¶</a></h3>
<p>使用 <strong class="command">cscope</strong> 或 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 在 Linux 内核源代码中查找以下符号的定义：</p>
<ul class="simple">
<li><code class="xref c c-func docutils literal"><span class="pre">module_init()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">module_exit()</span></code><ul>
<li>这两个宏的作用是什么？ <code class="docutils literal"><span class="pre">init_module</span></code> 和 <code class="docutils literal"><span class="pre">cleanup_module</span></code> 是什么？</li>
</ul>
</li>
<li><code class="xref c c-data docutils literal"><span class="pre">ignore_loglevel</span></code><ul>
<li>这个变量用于什么？</li>
</ul>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>如果使用 <strong class="command">cscope</strong> 时遇到问题，可能是数据库没有生成。要生成数据库，请在内核目录中使用以下命令：</p>
<div class="last highlight-bash"><div class="highlight"><pre><span></span>make <span class="nv">ARCH</span><span class="o">=</span>x86 cscope
</pre></div>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>在使用 <strong class="command">cscope</strong> 搜索结构时，只使用结构名（不包括 <code class="code docutils literal"><span class="pre">struct</span></code>）。所以，要搜索结构 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">module</span></code>，可以使用以下命令：</p>
<blockquote>
<div><div class="highlight-bash"><div class="highlight"><pre><span></span>vim -t module
</pre></div>
</div>
</div></blockquote>
<p>或者在 <strong class="command">vim</strong> 中使用命令：</p>
<blockquote class="last">
<div><div class="highlight-bash"><div class="highlight"><pre><span></span>:cs f g module
</pre></div>
</div>
</div></blockquote>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">有关使用 <strong class="command">cscope</strong> 的更多信息，请阅读上一个实验的 <a class="reference internal" href="../so2/lab1-intro.html#cscope-intro"><span class="std std-ref">cscope 章节</span></a>。</p>
</div>
</div>
<div class="section" id="section-11">
<h3>1. 内核模块<a class="headerlink" href="#section-11" title="Permalink to this headline">¶</a></h3>
<p>为了使用内核模块，我们将按照 <span class="xref std std-ref">上述</span> 步骤进行操作。</p>
<p>首先在 <cite>tools/labs</cite> 目录下运行以下命令生成名为 <strong>1-2-test-mod</strong> 的任务骨架，然后构建并复制模块到虚拟机中。</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>$ <span class="nv">LABS</span><span class="o">=</span>kernel_modules make skels
$ make build
$ make copy
</pre></div>
</div>
<p>这些命令将构建并复制当前实验骨架中的所有模块。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在解决练习 3 之前，编译 <code class="docutils literal"><span class="pre">3-error-mod</span></code> 时会出现编译错误。为了避免此问题，删除 <code class="file docutils literal"><span class="pre">skels/kernel_modules/3-error-mod/</span></code> 目录，并从 <code class="docutils literal"><span class="pre">skels/Kbuild</span></code> 中删除相应的行。</p>
</div>
<p>使用 <strong class="command">make boot</strong> 启动虚拟机，使用 <cite>minicom -D serial.pts</cite> 连接到串行控制台，并执行以下任务：</p>
<ul class="simple">
<li>加载内核模块。</li>
<li>列出内核模块并检查当前模块是否存在。</li>
<li>卸载内核模块。</li>
<li>使用 <strong class="command">dmesg</strong> 命令查看加载/卸载内核模块时显示的消息。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">请阅读 <a class="reference internal" href="#section-6">加载/卸载内核模块</a> 部分。在卸载内核模块时，只需指定模块名称（不包括扩展名）。</p>
</div>
</div>
<div class="section" id="printk-1">
<h3>2. Printk<a class="headerlink" href="#printk-1" title="Permalink to this headline">¶</a></h3>
<p>观察虚拟机控制台。为什么消息直接显示在虚拟机控制台上？</p>
<p>配置系统，使消息不直接显示在串行控制台上，只能使用 <code class="docutils literal"><span class="pre">dmesg</span></code> 命令来查看。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">一种方法是通过将所需级别写入 <code class="docutils literal"><span class="pre">/proc/sys/kernel/printk</span></code> 来设置控制台日志级别。使用的值应小于模块源代码中用于打印消息的级别。</p>
</div>
<p>重新加载/卸载该模块。消息不应该打印到虚拟机控制台上，但是在运行 <code class="docutils literal"><span class="pre">dmesg</span></code> 命令时应该可见。</p>
</div>
<div class="section" id="section-12">
<h3>3. 错误<a class="headerlink" href="#section-12" title="Permalink to this headline">¶</a></h3>
<p>生成名为 <strong>3-error-mod</strong> 的任务的框架。编译源代码并得到相应的内核模块。</p>
<p>为什么会出现编译错误？<a href="#system-message-2"><span class="problematic" id="problematic-2">**</span></a>提示：<a href="#system-message-3"><span class="problematic" id="problematic-3">**</span></a>这个模块与前一个模块有什么不同？</p>
<p>修改该模块以解决这些错误的原因，然后编译和测试该模块。</p>
</div>
<div class="section" id="section-13">
<h3>4. 子模块<a class="headerlink" href="#section-13" title="Permalink to this headline">¶</a></h3>
<p>查看 <code class="file docutils literal"><span class="pre">4-multi-mod/</span></code> 目录中的 C 源代码文件 <code class="docutils literal"><span class="pre">mod1.c</span></code> 和 <code class="docutils literal"><span class="pre">mod2.c</span></code>。模块 2 仅包含模块 1 使用的函数的定义。</p>
<p>修改 <code class="file docutils literal"><span class="pre">Kbuild</span></code> 文件，从这两个 C 源文件创建 <code class="docutils literal"><span class="pre">multi_mod.ko</span></code> 模块。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验室中的 <a class="reference internal" href="#section-5">编译内核模块</a> 部分。</p>
</div>
<p>编译、复制、启动虚拟机、加载和卸载内核模块。确保消息在控制台上正确显示。</p>
</div>
<div class="section" id="oops-1">
<h3>5. 内核 oops<a class="headerlink" href="#oops-1" title="Permalink to this headline">¶</a></h3>
<p>进入任务目录 <strong>5-oops-mod</strong> 并检查 C 源代码文件。注意问题将在哪里发生。在 Kbuild 文件中添加编译标记 <code class="docutils literal"><span class="pre">-g</span></code>。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验中的 <a class="reference internal" href="#section-5">编译内核模块</a> 部分。</p>
</div>
<p>编译相应的模块并将其加载到内核中。识别 oops 出现的内存地址。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读实验中的 <a href="#system-message-4"><span class="problematic" id="problematic-4">`调试`_</span></a> 部分。要识别地址，请遵循 oops 消息并提取指令指针 (<code class="docutils literal"><span class="pre">EIP</span></code>) 寄存器的值。</p>
</div>
<p>确定是哪条指令触发了 oops。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">使用 <code class="file docutils literal"><span class="pre">proc/modules</span></code> 信息获取内核模块的加载地址。在物理机上使用 objdump 和/或 addr2line。Objdump 需要编译时开启调试支持！请阅读实验中的 <a class="reference internal" href="#objdump">objdump</a> 和 <a class="reference internal" href="#addr2line">addr2line</a> 部分。</p>
</div>
<p>尝试卸载内核模块。请注意，该操作无法成功，因为自 oops 发生以来，内核模块内部仍然存在对内核的引用；在释放这些引用之前（在 oops 的情况下几乎不可能），模块无法卸载。</p>
</div>
<div class="section" id="section-14">
<h3>6. 模块参数<a class="headerlink" href="#section-14" title="Permalink to this headline">¶</a></h3>
<p>进入任务目录 <strong>6-cmd-mod</strong> 并检查 C 源代码文件 <code class="docutils literal"><span class="pre">cmd_mod.c</span></code>。编译并复制相关的模块，然后加载内核模块以查看 printk 消息。然后从内核中卸载该模块。</p>
<p>在不修改源代码的情况下，加载内核模块以显示消息 <code class="docutils literal"><span class="pre">Early</span> <span class="pre">bird</span> <span class="pre">gets</span> <span class="pre">tired</span></code>。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">可以通过向模块传递参数来更改 str 变量。在 <a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x323.html">这里</a> 找到更多相关信息。</p>
</div>
<span class="target" id="proc-info"></span></div>
<div class="section" id="section-15">
<h3>7. 进程信息<a class="headerlink" href="#section-15" title="Permalink to this headline">¶</a></h3>
<p>检查名为 <strong>7-list-proc</strong> 的任务的框架。添加代码来显示当前进程的进程 ID（ <code class="docutils literal"><span class="pre">PID</span></code> ）和可执行文件名。</p>
<p>按照标记为 <code class="docutils literal"><span class="pre">TODO</span></code> 的命令进行操作。在加载和卸载模块时，必须显示这些信息。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>在Linux内核中，进程由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 描述。使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 或 <code class="docutils literal"><span class="pre">cscope</span></code> 来查找 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的定义。</li>
<li>要找到包含可执行文件名的结构字段，请查找“executable”的注释。</li>
<li>内核中给定时间运行的当前进程的结构指针由 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code> 变量（类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct*</span></code>）给出。</li>
</ul>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">要使用 <code class="xref c c-macro docutils literal"><span class="pre">current</span></code>，你需要包含定义 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code> 的头文件，即 <code class="docutils literal"><span class="pre">linux/sched.h</span></code>。</p>
</div>
<p>编译、复制、启动虚拟机并加载模块。卸载内核模块。</p>
<p>重复加载/卸载操作。注意显示的进程 PID 是不同的。这是因为在加载模块时，从可执行文件 <code class="file docutils literal"><span class="pre">/sbin/insmod</span></code> 创建了一个进程，而在卸载模块时，从可执行文件 <code class="file docutils literal"><span class="pre">/sbin/rmmod</span></code> 创建了一个进程。</p>
</div>
</div>
<div class="section" id="extra-exercises">
<h2>Extra Exercises<a class="headerlink" href="#extra-exercises" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="section-16">
<h2>额外练习<a class="headerlink" href="#section-16" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kdb-1">
<h3>1. KDB<a class="headerlink" href="#kdb-1" title="Permalink to this headline">¶</a></h3>
<p>进入 <strong>8-kdb</strong> 目录。使用 <strong class="command">SysRq</strong> 命令通过串口激活 KDB 并进入 KDB 模式。使用 <strong class="command">minicom</strong> 连接到与 virtiocon0 相链接的伪终端，配置 KDB 使用 hvc0 串口：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> hvc0 &gt; /sys/module/kgdboc/parameters/kgdboc
</pre></div>
</div>
<p>然后使用 SysRq 命令启用 KDB (<strong class="command">Ctrl + O g</strong>)。查看当前系统状态（使用 <strong class="command">help</strong> 命令查看可用的 KDB 命令）。使用 <strong class="command">go</strong> 命令继续内核执行。</p>
<p>加载 <code class="file docutils literal"><span class="pre">hello_kdb</span></code> 模块。该模块在写入 <code class="file docutils literal"><span class="pre">/proc/hello_kdb_bug</span></code> 文件时会模拟一个错误。使用以下命令模拟错误：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="m">1</span> &gt; /proc/hello_kdb_bug
</pre></div>
</div>
<p>运行上述命令后，每次出现 oops/内核崩溃 时，内核会停止执行并进入调试模式。</p>
<p>分析堆栈跟踪并确定导致错误的代码。我们如何从 KDB 中找到模块加载的地址？</p>
<p>同时，在一个新窗口中使用 GDB 并根据 KDB 提供的信息查看代码。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">加载符号文件。使用 <strong class="command">info line</strong> 命令。</p>
</div>
<p>当写入 <code class="file docutils literal"><span class="pre">/proc/hello_kdb_break</span></code> 时，模块将递增 <code class="xref c c-data docutils literal"><span class="pre">kdb_write_address</span></code> 变量。进入 KDB 并设置每次对 <code class="xref c c-data docutils literal"><span class="pre">kdb_write_address</span></code> 变量进行写入访问的断点。返回内核以触发写入，使用以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nb">echo</span> <span class="m">1</span> &gt; /proc/hello_kdb_break
</pre></div>
</div>
</div>
<div class="section" id="ps">
<h3>2. PS模块<a class="headerlink" href="#ps" title="Permalink to this headline">¶</a></h3>
<p>更新在 <span class="xref std std-ref">proc-info</span> 处创建的内核模块，以便在插入内核模块时显示有关系统中所有进程的信息，而不仅仅是当前进程的信息。然后，将获得的结果与 <strong class="command">ps</strong> 命令的输出进行比较。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<ul class="last simple">
<li>系统中的进程以循环列表的形式组织。</li>
<li><code class="xref c c-macro docutils literal"><span class="pre">for_each_...</span></code> 宏（例如 <code class="xref c c-macro docutils literal"><span class="pre">for_each_process</span></code>）在你希望遍历列表中的项目时非常有用。</li>
<li>要了解如何使用某个功能或宏，请使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a> 或 Vim 和 <strong class="command">cscope</strong> 进行搜索并查找使用场景。</li>
</ul>
</div>
</div>
<div class="section" id="section-17">
<h3>3. 内存信息<a class="headerlink" href="#section-17" title="Permalink to this headline">¶</a></h3>
<p>创建一个内核模块，显示当前进程的虚拟内存区域；对于每个内存区域，它将显示起始地址和结束地址。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<ul class="last simple">
<li>从现有的内核模块开始。</li>
<li>研究结构 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>、<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mm_struct</span></code> 和 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code>。内存区域由类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">vm_area_struct</span></code> 的结构表示。</li>
<li>不要忘记包含定义必要结构的头文件。</li>
</ul>
</div>
</div>
<div class="section" id="section-18">
<h3>4. 动态调试<a class="headerlink" href="#section-18" title="Permalink to this headline">¶</a></h3>
<p>进入 <strong>9-dyndbg</strong> 目录并编译 <code class="code docutils literal"><span class="pre">dyndbg.ko</span></code> 模块。</p>
<p>熟悉挂载在 <code class="file docutils literal"><span class="pre">/debug</span></code> 中的 <code class="code docutils literal"><span class="pre">debugfs</span></code> 文件系统，并分析文件 <code class="file docutils literal"><span class="pre">/debug/dynamic_debug/control</span></code> 的内容。插入 <code class="code docutils literal"><span class="pre">dyndbg.ko</span></code> 模块并注意 <code class="file docutils literal"><span class="pre">dynamic_debug/control</span></code> 文件的新内容。</p>
<p>在相应的文件中出现了什么额外内容？运行以下命令：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span>grep dyndbg /debug/dynamic_debug/control
</pre></div>
</div>
<p>配置 <strong class="command">dyndbg</strong>，以便在卸载模块时仅显示来自 <code class="xref c c-func docutils literal"><span class="pre">my_debug_func()</span></code> 的标记为“Important”的消息，本练习仅过滤掉 <code class="xref c c-func docutils literal"><span class="pre">pr_debug()</span></code> 调用；始终显示 <code class="xref c c-func docutils literal"><span class="pre">printk()</span></code> 调用。</p>
<p>请指定两种过滤方式。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读 <a href="#system-message-5"><span class="problematic" id="problematic-5">`Dynamic debugging`_</span></a> 部分并查看 <strong class="command">dyndbg</strong> 的选项（例如 <strong class="command">line</strong> 、<strong class="command">format</strong>）。</p>
</div>
<p>执行过滤操作并检查 <code class="file docutils literal"><span class="pre">dynamic_debug/control</span></code> 文件。发生了什么变化？如何知道哪些调用被激活了？</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">检查 <strong class="command">dyndbg</strong> 标志。卸载内核模块并观察日志消息。</p>
</div>
</div>
<div class="section" id="section-19">
<h3>5. 初始化期间的动态调试<a class="headerlink" href="#section-19" title="Permalink to this headline">¶</a></h3>
<p>正如你注意到的那样，只有在插入模块后才能激活/过滤 <code class="xref c c-func docutils literal"><span class="pre">pr_debug()</span></code> 调用。在某些情况下，查看模块初始化期间的消息可能会很有帮助。可以通过使用一个名为 <strong class="command">dyndbg</strong> 的默认（伪）参数作为初始化模块的参数来实现。使用此参数，你可以添加/删除 <strong class="command">dyndbg</strong> 标志。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">阅读 <a href="#system-message-6"><span class="problematic" id="problematic-6">`Dynamic debugging`_</span></a> 部分的最后一部分，查看可用的标志（例如： <strong class="command">+/- p</strong>）。</p>
</div>
<p>阅读 <a class="reference external" href="https://01.org/linuxgraphics/gfx-docs/drm/admin-guide/dynamic-debug-howto.html#debug-messages-at-module-initialization-time">模块初始化时的调试消息部分</a> ，并插入模块以便在初始化期间显示 <code class="xref c c-func docutils literal"><span class="pre">my_debug_func`（即</span> <span class="pre">:c:func:`dyndbg_init()</span></code>）中的消息。</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">在实验的虚拟机中，你需要使用 <strong class="command">insmod</strong> 而不是 <strong class="command">modprobe</strong>。</p>
</div>
<p>在不卸载模块的情况下，停用 <code class="xref c c-func docutils literal"><span class="pre">pr_debug()</span></code> 调用。</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">你可以删除设置的标志。卸载内核模块。</p>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="introduction.html" class="btn btn-neutral float-left" title="介绍" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kernel_api.html" class="btn btn-neutral float-right" title="内核 API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>