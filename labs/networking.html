<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta content="理解 Linux 内核网络架构，掌握使用数据包（packet）过滤器或防火墙进行 IP 数据包管理，熟悉在 Linux 内核级别使用套接字的方法" name="description" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>网络 &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="ARM 内核开发" href="arm_kernel_development.html" />
    <link rel="prev" title="文件系统驱动程序（第二部分）" href="filesystems_part2.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">操作系统 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">体系结构层</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">虚拟化</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">网络</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-2">实验目标</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-3">概述</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-4">用户空间中的网络编程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linux">Linux 网络编程</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#struct-socket"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#socket">对 socket 结构的操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-socket-1"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 字段</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#struct-sock"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-sk-buff"><code class="docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 结构体</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-8">转换</a></li>
<li class="toctree-l2"><a class="reference internal" href="#netfilter-1">netfilter</a></li>
<li class="toctree-l2"><a class="reference internal" href="#netcat">netcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-9">进一步阅读</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-10">练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-11">1. 在内核空间中显示数据包</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-12">2. 按目标地址进行过滤</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tcp-socket">3. 监听 TCP socket</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">4. 在内核空间接受连接</a></li>
<li class="toctree-l3"><a class="reference internal" href="#udp-1">5. UDP 套接字发送方</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">推荐配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html#section-2">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">向 Linux 内核实验项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">网络</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/networking.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="section-1">
<h1>网络<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-2">
<h2>实验目标<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li>理解 Linux 内核网络架构</li>
<li>掌握使用数据包（packet）过滤器或防火墙进行 IP 数据包管理</li>
<li>熟悉在 Linux 内核级别使用套接字的方法</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-3">
<h2>概述<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h2>
<p>互联网的发展导致网络应用程序呈指数增长，因此操作系统的网络子系统对速度和生产力的要求也在不断增加。网络子系统并非操作系统内核的必需组件（Linux 内核可以选择在编译时不包含网络支持）。然而，由于对连接的需要，计算机系统（甚至嵌入式设备）很少会使用不支持网络的操作系统。现代操作系统使用 <a class="reference external" href="https://zh.wikipedia.org/zh-cn/TCP/IP协议族">TCP/IP 协议栈</a>。它们的内核实现了传输层以下的协议，而应用层协议通常在用户空间实现（如 HTTP、FTP 以及 SSH 等）。</p>
<div class="section" id="section-4">
<h3>用户空间中的网络编程<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h3>
<p>套接字（socket）是在用户空间中，对于网络通信的抽象。套接字抽象了通信通道，也是基于内核的 TCP/IP 栈交互接口。IP 套接字与 IP 地址、所使用的传输层协议（如 TCP、UDP 等）和端口相关联。常用的使用套接字的函数调用有：创建 (<code class="docutils literal"><span class="pre">socket</span></code>)、初始化 (<code class="docutils literal"><span class="pre">bind</span></code>)、连接 (<code class="docutils literal"><span class="pre">connect</span></code>)、等待连接 (<code class="docutils literal"><span class="pre">listen</span></code>, <code class="docutils literal"><span class="pre">accept</span></code>) 以及关闭套接字 (<code class="docutils literal"><span class="pre">close</span></code>)。</p>
<p>我们通过 <code class="docutils literal"><span class="pre">read</span></code>/<code class="docutils literal"><span class="pre">write</span></code> 或 <code class="docutils literal"><span class="pre">recv</span></code>/<code class="docutils literal"><span class="pre">send</span></code> 调用实现 TCP 套接字的网络通信，通过 <code class="docutils literal"><span class="pre">recvfrom</span></code>/<code class="docutils literal"><span class="pre">sendto</span></code> 调用实现 UDP 套接字的网络通信。传输和接收操作对应用程序来说是透明的，封装和网络传输由内核自行决定。然而，也可以使用原始套接字（创建套接字时使用 <code class="docutils literal"><span class="pre">PF_PACKET</span></code> 选项）在用户空间中实现 TCP/IP 栈，或者在内核中实现应用层协议（例如 <a class="reference external" href="https://zh.wikipedia.org/zh-cn/TUX_Web服务器">TUX web 服务器</a>）。</p>
<p>有关使用套接字进行用户空间编程的更多详细信息，请参阅 <a class="reference external" href="https://www.beej.us/guide/bgnet/">Beej 的网络套接字编程指南</a>。</p>
</div>
</div>
<div class="section" id="linux">
<h2>Linux 网络编程<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h2>
<p>Linux 内核提供了三种基本的用于处理网络数据包的结构：<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code>、<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 和 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code>。</p>
<p>前两者是对套接字的抽象：</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 是非常接近用户空间的抽象，即用于编写网络应用程序的 <a class="reference external" href="http://zh.wikipedia.org/zh-cn/Berkeley套接字">BSD 套接字</a>；</li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 或 Linux 术语中的 <em>INET 套接字</em> 是套接字的网络表示。</li>
</ul>
</div></blockquote>
<p>这两个结构有关联: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 包含 INET 套接字字段，而每个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 都有一个 BSD 套接字持有它。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 结构是网络数据包及其状态的表示。当从用户空间或网络接口接收到内核数据包时，该结构被创建。</p>
<div class="section" id="struct-socket">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构<a class="headerlink" href="#struct-socket" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构是 BSD 套接字的内核表示，可以执行在它上面执行的操作类似于内核提供的操作（通过系统调用）。使用套接字的常见操作（创建、初始化/绑定、关闭等）会导致特定的系统调用；它们与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构一起工作。</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 的操作在 <code class="file docutils literal"><span class="pre">net/socket.c</span></code> 中进行描述，且与协议类型无关。因此, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构是特定网络操作实现的通用接口。通常，这些操作的名称以 <code class="docutils literal"><span class="pre">sock_</span></code> 前缀开头。</p>
<div class="section" id="socket">
<span id="socketstructops"></span><h4>对 socket 结构的操作<a class="headerlink" href="#socket" title="永久链接至标题">¶</a></h4>
<p>socket 相关操作包括：</p>
<div class="section" id="section-5">
<h5>创建<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h5>
<p>创建类似于在用户空间调用 <code class="xref c c-func docutils literal"><span class="pre">socket()</span></code> 函数，但创建的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 将存储在 <code class="docutils literal"><span class="pre">res</span></code> 参数中：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_create(int</span> <span class="pre">family,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">int</span> <span class="pre">protocol,</span> <span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res)</span></code>：在 <code class="xref c c-func docutils literal"><span class="pre">socket()</span></code> 系统调用之后创建 socket；</li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_create_kern(struct</span> <span class="pre">net</span> <span class="pre">*net,</span> <span class="pre">int</span> <span class="pre">family,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">int</span> <span class="pre">protocol,</span> <span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res)</span></code>：创建内核 socket；</li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_create_lite(int</span> <span class="pre">family,</span> <span class="pre">int</span> <span class="pre">type,</span> <span class="pre">int</span> <span class="pre">protocol,</span> <span class="pre">struct</span> <span class="pre">socket</span> <span class="pre">**res)</span></code>：创建内核 socket, 不经过参数完整性检查。</li>
</ul>
</div></blockquote>
<p>这些调用的参数如下：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">net</span></code> (如果存在)用作对所使用的网络命名空间的引用；通常我们会使用 <code class="docutils literal"><span class="pre">init_net</span></code> 进行初始化；</li>
<li><code class="docutils literal"><span class="pre">family</span></code> 表示在信息传输中使用的协议族；它们通常以 <code class="docutils literal"><span class="pre">PF_``(协议族)字符串开头；表示所使用的协议族的常量可以在</span> <span class="pre">:file:`linux/socket.h`</span> <span class="pre">中找到，其中最常用的是</span> <span class="pre">``PF_INET</span></code>，用于 TCP/IP 协议；</li>
<li><code class="docutils literal"><span class="pre">type</span></code> 是 socket 的类型；用于此参数的常量可以在 <code class="file docutils literal"><span class="pre">linux/net.h</span></code> 中找到，其中最常用的是 <code class="docutils literal"><span class="pre">SOCK_STREAM</span></code> (用于基于连接的源到目的地通信)以及 <code class="docutils literal"><span class="pre">SOCK_DGRAM</span></code> (用于无连接通信)；</li>
<li><code class="docutils literal"><span class="pre">protocol</span></code> 表示使用的协议，与 <code class="docutils literal"><span class="pre">type</span></code> 参数密切相关；用于此参数的常量可以在 <code class="file docutils literal"><span class="pre">linux/in.h</span></code> 中找到，其中最常用的是 <code class="docutils literal"><span class="pre">IPPROTO_TCP</span></code> (用于 TCP)， <code class="docutils literal"><span class="pre">IPPROTO_UDP</span></code> (用于 UDP)。</li>
</ul>
</div></blockquote>
<p>要在内核空间中创建 TCP socket，你需要调用：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create_kern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>要在内核空间中创建 UDP socket，你需要调用：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="n">err</span> <span class="o">=</span> <span class="n">sock_create_kern</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="n">IPPROTO_UDP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一个使用示例是 <code class="xref c c-func docutils literal"><span class="pre">sys_socket()</span></code> 系统调用处理程序的一部分：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">family</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">protocol</span><span class="p">)</span>
<span class="p">{</span>
      <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

      <span class="cm">/* 检查 SOCK_* 常量是否一致。 */</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">!=</span> <span class="n">O_CLOEXEC</span><span class="p">);</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">((</span><span class="n">SOCK_MAX</span> <span class="o">|</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">&amp;</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>
      <span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">&amp;</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">);</span>

      <span class="n">flags</span> <span class="o">=</span> <span class="n">type</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">SOCK_CLOEXEC</span> <span class="o">|</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
              <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
      <span class="n">type</span> <span class="o">&amp;=</span> <span class="n">SOCK_TYPE_MASK</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">SOCK_NONBLOCK</span> <span class="o">!=</span> <span class="n">O_NONBLOCK</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SOCK_NONBLOCK</span><span class="p">))</span>
              <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">SOCK_NONBLOCK</span><span class="p">)</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">;</span>

      <span class="n">retval</span> <span class="o">=</span> <span class="n">sock_create</span><span class="p">(</span><span class="n">family</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sock</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

      <span class="k">return</span> <span class="nf">sock_map_fd</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CLOEXEC</span> <span class="o">|</span> <span class="n">O_NONBLOCK</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h5>关闭连接<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h5>
<p>关闭连接（对于使用连接的 socket）并释放相关资源：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">void</span> <span class="pre">sock_release(struct</span> <span class="pre">socket</span> <span class="pre">*sock)</span></code> 调用 socket 结构 <code class="docutils literal"><span class="pre">ops</span></code> 字段中的 <code class="docutils literal"><span class="pre">release</span></code> 函数：</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">sock_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">;</span>

              <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">release</span><span class="p">(</span><span class="n">sock</span><span class="p">);</span>
              <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
              <span class="n">module_put</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-7">
<h5>发送/接收消息<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h5>
<p>使用以下函数来发送/接收消息：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_recvmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg,</span> <span class="pre">int</span> <span class="pre">flags);</span></code></li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">kernel_recvmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg,</span> <span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec,</span> <span class="pre">size_t</span> <span class="pre">num,</span> <span class="pre">size_t</span> <span class="pre">size,</span> <span class="pre">int</span> <span class="pre">flags);</span></code></li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">sock_sendmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg);</span></code></li>
<li><code class="docutils literal"><span class="pre">int</span> <span class="pre">kernel_sendmsg(struct</span> <span class="pre">socket</span> <span class="pre">*sock,</span> <span class="pre">struct</span> <span class="pre">msghdr</span> <span class="pre">*msg,</span> <span class="pre">struct</span> <span class="pre">kvec</span> <span class="pre">*vec,</span> <span class="pre">size_t</span> <span class="pre">num,</span> <span class="pre">size_t</span> <span class="pre">size);</span></code></li>
</ul>
</div></blockquote>
<p>消息的发送/接收函数将调用 socket <code class="docutils literal"><span class="pre">ops</span></code> 字段中的 <code class="docutils literal"><span class="pre">sendmsg</span></code>/<code class="docutils literal"><span class="pre">recvmsg</span></code> 函数。当 socket 在内核中使用时，应使用以 <code class="docutils literal"><span class="pre">kernel_</span></code> 为前缀的函数。</p>
<p>参数包括：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">msg</span></code>, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> 结构，包含要发送/接收的消息。该结构的重要组成部分包括 <code class="docutils literal"><span class="pre">msg_name</span></code> 和 <code class="docutils literal"><span class="pre">msg_namelen</span></code>，对于 UDP 套接字，必须使用目标地址填充 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code>)；</li>
<li><code class="docutils literal"><span class="pre">vec</span></code>, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> 结构，其中有一个指针指向缓冲区，缓冲区内包含该 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> 结构的数据和大小；正如所见，它的结构类似于 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></code> 结构 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></code> 结构对应用户空间数据，而 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> 结构对应内核空间数据)。</li>
</ul>
</div></blockquote>
<p>可以在 <code class="xref c c-func docutils literal"><span class="pre">sys_sendto()</span></code> 系统调用处理程序中看到用法示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">sendto</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
              <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span>
              <span class="kt">int</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">address</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">msghdr</span> <span class="n">msg</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">iovec</span> <span class="n">iov</span><span class="p">;</span>
      <span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

      <span class="n">err</span> <span class="o">=</span> <span class="n">import_single_range</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">.</span><span class="n">msg_iter</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
              <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
      <span class="n">sock</span> <span class="o">=</span> <span class="n">sockfd_lookup_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sock</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

      <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_control</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_controllen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">addr</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">err</span> <span class="o">=</span> <span class="n">move_addr_to_kernel</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">address</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                      <span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
              <span class="n">msg</span><span class="p">.</span><span class="n">msg_name</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">address</span><span class="p">;</span>
              <span class="n">msg</span><span class="p">.</span><span class="n">msg_namelen</span> <span class="o">=</span> <span class="n">addr_len</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">)</span>
              <span class="n">flags</span> <span class="o">|=</span> <span class="n">MSG_DONTWAIT</span><span class="p">;</span>
      <span class="n">msg</span><span class="p">.</span><span class="n">msg_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">sock_sendmsg</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span>

<span class="nl">out_put</span><span class="p">:</span>
      <span class="n">fput_light</span><span class="p">(</span><span class="n">sock</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="struct-socket-1">
<h4><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 字段<a class="headerlink" href="#struct-socket-1" title="永久链接至标题">¶</a></h4>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> *  struct socket——通用的 BSD socket</span>
<span class="cm"> *  @state: socket 状态（%SS_CONNECTED 等）</span>
<span class="cm"> *  @type: socket 类型（%SOCK_STREAM 等）</span>
<span class="cm"> *  @flags: socket 标志（%SOCK_NOSPACE 等）</span>
<span class="cm"> *  @ops: 协议特定的 socket 操作</span>
<span class="cm"> *  @file: 反向指向 file 的指针，用于垃圾回收</span>
<span class="cm"> *  @sk: 内部的网络协议无关 socket 表示</span>
<span class="cm"> *  @wq: 有多种用途的等待队列</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">socket</span> <span class="p">{</span>
      <span class="n">socket_state</span>            <span class="n">state</span><span class="p">;</span>

      <span class="kt">short</span>                   <span class="n">type</span><span class="p">;</span>

      <span class="kt">unsigned</span> <span class="kt">long</span>           <span class="n">flags</span><span class="p">;</span>

      <span class="k">struct</span> <span class="n">socket_wq</span> <span class="n">__rcu</span>  <span class="o">*</span><span class="n">wq</span><span class="p">;</span>

      <span class="k">struct</span> <span class="n">file</span>             <span class="o">*</span><span class="n">file</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sock</span>             <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">struct</span> <span class="n">proto_ops</span>  <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>值得注意的字段包括：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">ops</span></code>——该结构内部有指针，指针指向协议特定函数；</li>
<li><code class="docutils literal"><span class="pre">sk</span></code>——与之关联的 <code class="docutils literal"><span class="pre">INET</span> <span class="pre">socket</span></code>。</li>
</ul>
</div></blockquote>
<div class="section" id="struct-proto-ops">
<h5><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">proto_ops</span></code> 结构<a class="headerlink" href="#struct-proto-ops" title="永久链接至标题">¶</a></h5>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">proto_ops</span></code> 结构体包含了特定操作（TCP、UDP 等）的实现；这些函数将通过通用函数(如 <code class="xref c c-func docutils literal"><span class="pre">sock_release()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">sock_sendmsg()</span></code> 等)使用 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 为参数来调用。</p>
<p>因此, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">proto_ops</span></code> 结构体包含了一些特定协议实现的函数指针：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">proto_ops</span> <span class="p">{</span>
      <span class="kt">int</span>             <span class="n">family</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">module</span>   <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">bind</span><span class="p">)</span>      <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">myaddr</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">sockaddr_len</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">connect</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">vaddr</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">sockaddr_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">socketpair</span><span class="p">)(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock1</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock2</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">accept</span><span class="p">)</span>    <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">newsock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">kern</span><span class="p">);</span>
      <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">getname</span><span class="p">)</span>   <span class="p">(</span><span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span>
                                    <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
                                    <span class="kt">int</span> <span class="n">peer</span><span class="p">);</span>
      <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构体的 <code class="docutils literal"><span class="pre">ops</span></code> 字段的初始化是在 <code class="xref c c-func docutils literal"><span class="pre">__sock_create()</span></code> 函数中完成的，该函数通过调用针对每个协议的 <code class="xref c c-func docutils literal"><span class="pre">create()</span></code> 函数来实现；等效调用是 <code class="xref c c-func docutils literal"><span class="pre">__sock_create()</span></code> 函数的实现：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">//...</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">pf</span><span class="o">-&gt;</span><span class="n">create</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">sock</span><span class="p">,</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out_module_put</span><span class="p">;</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>这将使用与 socket 关联的协议类型特定的调用来实例化函数指针。 <code class="xref c c-func docutils literal"><span class="pre">sock_register()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">sock_unregister()</span></code> 调用用于填充 <code class="docutils literal"><span class="pre">net_families</span></code> 向量。</p>
<p>对于 socket 结构的其余操作（除了在 <a class="reference internal" href="#socket">对 socket 结构的操作</a> 部分中描述的创建、关闭和发送/接收消息之外），将调用通过这个结构中的指针传递的函数。例如，对于 <code class="docutils literal"><span class="pre">bind</span></code> 操作（它将一个 socket 与一个本地机器上的 socket 关联）有以下代码：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define MY_PORT 60000</span>

<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">,</span>
      <span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span> <span class="p">(</span><span class="n">MY_PORT</span><span class="p">),</span>
      <span class="p">.</span><span class="n">sin_addr</span> <span class="o">=</span> <span class="p">{</span> <span class="n">htonl</span> <span class="p">(</span><span class="n">INADDR_LOOPBACK</span><span class="p">)</span> <span class="p">}</span>
<span class="p">};</span>

<span class="c1">//...</span>
      <span class="n">err</span> <span class="o">=</span> <span class="n">sock</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">bind</span> <span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 处理错误 */</span>
      <span class="p">}</span>
<span class="c1">//...</span>
</pre></div>
</div>
<p>在以上代码中，用于传输与 socket 关联的地址和端口信息的是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr_in</span></code> 结构体。</p>
</div>
</div>
</div>
<div class="section" id="struct-sock">
<h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 结构<a class="headerlink" href="#struct-sock" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 结构描述了 <code class="docutils literal"><span class="pre">INET</span></code> 套接字。这样的结构与用户空间的 socket 相关联，并且与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构相关联，其中与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">socket</span></code> 结构的关联是隐式的。该结构用于存储关于连接状态的信息。结构体的字段和相关操作通常以 <code class="docutils literal"><span class="pre">sk_</span></code> 字符串开头。以下列出了一些字段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sock</span> <span class="p">{</span>
      <span class="c1">//...</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="nl">sk_padding</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="nl">sk_no_check_tx</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="nl">sk_no_check_rx</span> <span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="nl">sk_userlocks</span> <span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                              <span class="nl">sk_protocol</span>  <span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                              <span class="nl">sk_type</span>      <span class="p">:</span> <span class="mi">16</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="k">struct</span> <span class="n">socket</span>           <span class="o">*</span><span class="n">sk_socket</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="k">struct</span> <span class="n">sk_buff</span>          <span class="o">*</span><span class="n">sk_send_head</span><span class="p">;</span>
      <span class="c1">//...</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_state_change</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_data_ready</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_write_space</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_error_report</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
      <span class="kt">int</span>                     <span class="p">(</span><span class="o">*</span><span class="n">sk_backlog_rcv</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
                                                <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
      <span class="kt">void</span>                    <span class="p">(</span><span class="o">*</span><span class="n">sk_destruct</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">sk_protocol</span></code> 是套接字使用的协议类型；</li>
<li><code class="docutils literal"><span class="pre">sk_type</span></code> 是套接字类型 (<code class="docutils literal"><span class="pre">SOCK_STREAM</span></code>, <code class="docutils literal"><span class="pre">SOCK_DGRAM</span></code> 等)；</li>
<li><code class="docutils literal"><span class="pre">sk_socket</span></code> 是持有该套接字的 BSD 套接字；</li>
<li><code class="docutils literal"><span class="pre">sk_send_head</span></code> 是用于传输的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 结构列表；</li>
<li>最后的函数指针是用于不同情况的回调函数。</li>
</ul>
</div></blockquote>
<p>使用从 <code class="docutils literal"><span class="pre">net_families</span></code> 创建的回调函数(称为 <code class="xref c c-func docutils literal"><span class="pre">__sock_create()</span></code>) 来初始化 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 并将其附加到 BSD 套接字。以下是在 <code class="xref c c-func docutils literal"><span class="pre">inet_create()</span></code> 函数中初始化 IP 协议的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sock</span></code> 结构体的方法：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> *   创建 inet 套接字。</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inet_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">sock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">,</span>
                     <span class="kt">int</span> <span class="n">kern</span><span class="p">)</span>
<span class="p">{</span>

      <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

      <span class="c1">//...</span>
      <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
      <span class="n">sk</span> <span class="o">=</span> <span class="n">sk_alloc</span><span class="p">(</span><span class="n">net</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="n">answer_prot</span><span class="p">,</span> <span class="n">kern</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sk</span><span class="p">)</span>
              <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

      <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">INET_PROTOSW_REUSE</span> <span class="o">&amp;</span> <span class="n">answer_flags</span><span class="p">)</span>
              <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_reuse</span> <span class="o">=</span> <span class="n">SK_CAN_REUSE</span><span class="p">;</span>


      <span class="c1">//...</span>
      <span class="n">sock_init_data</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">sk</span><span class="p">);</span>

      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_destruct</span>    <span class="o">=</span> <span class="n">inet_sock_destruct</span><span class="p">;</span>
      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_protocol</span>    <span class="o">=</span> <span class="n">protocol</span><span class="p">;</span>
      <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_backlog_rcv</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">sk_prot</span><span class="o">-&gt;</span><span class="n">backlog_rcv</span><span class="p">;</span>
      <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="struct-sk-buff">
<span id="structskbuff"></span><h3><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 结构体<a class="headerlink" href="#struct-sk-buff" title="永久链接至标题">¶</a></h3>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> (套接字缓冲区)描述了一个网络数据包。该结构的字段包含有关报头和数据包内容、使用的协议、使用的网络设备以及指向其他 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 的指针的信息。下面是该结构体的内容的概要描述：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="p">{</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="cm">/* 这两个成员必须放在最前面。 */</span>
      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>

      <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
        <span class="cm">/* 一些协议可能会使用此空间来存储信息，此种情形下设备指针为 NULL。</span>
<span class="cm">         * UDP 接收路径就是其中之一。</span>
<span class="cm">         */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dev_scratch</span><span class="p">;</span>
      <span class="p">};</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rbnode</span><span class="p">;</span> <span class="cm">/* 在 netem 和 tcp 栈中使用 */</span>
  <span class="p">};</span>
  <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="n">ktime_t</span> <span class="n">tstamp</span><span class="p">;</span>
    <span class="n">u64</span> <span class="n">skb_mstamp</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="cm">/*</span>
<span class="cm">   * 这是控制缓冲区。每一层都可以自由使用它。</span>
<span class="cm">   * 请将你的私有变量放在这里。如果要在多个层之间保留这些变量，首先必须进行 skb_clone()。</span>
<span class="cm">   * 此缓冲区由当前此 skb 的队列的所有者拥有。</span>
<span class="cm">   */</span>
  <span class="kt">char</span> <span class="n">cb</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_skb_refdst</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">_skb_refdst</span><span class="p">;</span>
      <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">destructor</span><span class="p">)(</span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">tcp_tsorted_anchor</span><span class="p">;</span>
  <span class="p">};</span>
  <span class="cm">/* ... */</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
               <span class="n">data_len</span><span class="p">;</span>
  <span class="n">__u16</span> <span class="n">mac_len</span><span class="p">,</span>
        <span class="n">hdr_len</span><span class="p">;</span>

  <span class="cm">/* ... */</span>

  <span class="n">__be16</span> <span class="n">protocol</span><span class="p">;</span>
  <span class="n">__u16</span> <span class="n">transport_header</span><span class="p">;</span>
  <span class="n">__u16</span> <span class="n">network_header</span><span class="p">;</span>
  <span class="n">__u16</span> <span class="n">mac_header</span><span class="p">;</span>

  <span class="cm">/* 私有：*/</span>
  <span class="n">__u32</span> <span class="n">headers_end</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="cm">/* 公有：*/</span>

  <span class="cm">/* 这些元素必须放在最后。有关详细信息，请参阅 alloc_skb()。*/</span>
  <span class="n">sk_buff_data_t</span> <span class="n">tail</span><span class="p">;</span>
  <span class="n">sk_buff_data_t</span> <span class="n">end</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
                <span class="o">*</span><span class="n">data</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">truesize</span><span class="p">;</span>
  <span class="n">refcount_t</span> <span class="n">users</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">next</span></code> 和 <code class="docutils literal"><span class="pre">prev</span></code> 是指向缓冲区列表中下一个和前一个元素的指针；</li>
<li><code class="docutils literal"><span class="pre">dev</span></code> 是发送或接收缓冲区内容的设备；</li>
<li><code class="docutils literal"><span class="pre">sk</span></code> 是与缓冲区相关联的套接字；</li>
<li><code class="docutils literal"><span class="pre">destructor</span></code> 是负责释放缓冲区的回调函数；</li>
<li><code class="docutils literal"><span class="pre">transport_header</span></code>, <code class="docutils literal"><span class="pre">network_header</span></code> 和 <code class="docutils literal"><span class="pre">mac_header</span></code> 是数据包起始位置和各个头部起始位置之间的偏移量。它们由数据包经过的各个处理层内部维护。要获取指向头部的指针，请使用以下函数之一: <code class="xref c c-func docutils literal"><span class="pre">tcp_hdr()</span></code>, <code class="xref c c-func docutils literal"><span class="pre">udp_hdr()</span></code> 以及 <code class="xref c c-func docutils literal"><span class="pre">ip_hdr()</span></code> 等。原则上，每个协议都对应一个函数。这些函数用于在接收到的数据包中，获取对该协议的头部的引用。请注意，当数据包到达网络层时, <code class="docutils literal"><span class="pre">network_header</span></code> 字段才被设置；而当数据包到达传输层时, <code class="docutils literal"><span class="pre">transport_header</span></code> 字段才被设置。</li>
</ul>
</div></blockquote>
<p><a class="reference external" href="https://zh.wikipedia.org/zh-cn/IPv4#首部">IP 头部</a> 的结构 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iphdr</span></code>) 包含以下字段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">iphdr</span> <span class="p">{</span>
<span class="cp">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
      <span class="n">__u8</span>    <span class="nl">ihl</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">version</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#elif defined (__BIG_ENDIAN_BITFIELD)</span>
      <span class="n">__u8</span>    <span class="nl">version</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">ihl</span><span class="p">:</span><span class="mi">4</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#error        &quot;Please fix &lt;asm/byteorder.h&gt;&quot;</span>
<span class="cp">#endif</span>
      <span class="n">__u8</span>    <span class="n">tos</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">tot_len</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">id</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">frag_off</span><span class="p">;</span>
      <span class="n">__u8</span>    <span class="n">ttl</span><span class="p">;</span>
      <span class="n">__u8</span>    <span class="n">protocol</span><span class="p">;</span>
      <span class="n">__sum16</span> <span class="n">check</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">saddr</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">daddr</span><span class="p">;</span>
      <span class="cm">/* 可选项由此开始 */</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">protocol</span></code> 是使用的传输层协议；</li>
<li><code class="docutils literal"><span class="pre">saddr</span></code> 是源 IP 地址；</li>
<li><code class="docutils literal"><span class="pre">daddr</span></code> 是目标 IP 地址。</li>
</ul>
</div></blockquote>
<p><a class="reference external" href="https://zh.wikipedia.org/zh-cn/传输控制协议#封包結構">TCP 头部</a> 的结构 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">tcphdr</span></code>) 具有以下字段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">tcphdr</span> <span class="p">{</span>
      <span class="n">__be16</span>  <span class="n">source</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">dest</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">seq</span><span class="p">;</span>
      <span class="n">__be32</span>  <span class="n">ack_seq</span><span class="p">;</span>
<span class="cp">#if defined(__LITTLE_ENDIAN_BITFIELD)</span>
      <span class="n">__u16</span>   <span class="nl">res1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">doff</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">fin</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">syn</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">rst</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">psh</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ack</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">urg</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ece</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">cwr</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#elif defined(__BIG_ENDIAN_BITFIELD)</span>
      <span class="n">__u16</span>   <span class="nl">doff</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">res1</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span>
              <span class="nl">cwr</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ece</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">urg</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">ack</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">psh</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">rst</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">syn</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
              <span class="nl">fin</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="cp">#error        &quot;Adjust your &lt;asm/byteorder.h&gt; defines&quot;</span>
<span class="cp">#endif</span>
      <span class="n">__be16</span>  <span class="n">window</span><span class="p">;</span>
      <span class="n">__sum16</span> <span class="n">check</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">urg_ptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">source</span></code> 是源端口；</li>
<li><code class="docutils literal"><span class="pre">dest</span></code> 是目标端口；</li>
<li>常使用的 TCP 标志包括 <code class="docutils literal"><span class="pre">syn</span></code>, <code class="docutils literal"><span class="pre">ack</span></code> 以及 <code class="docutils literal"><span class="pre">fin</span></code>；要想对其有更详细地了解，请参见此 <a class="reference external" href="http://www.eventhelix.com/Realtimemantra/Networking/Tcp.pdf">图表</a>。</li>
</ul>
</div></blockquote>
<p><a class="reference external" href="https://zh.wikipedia.org/zh-cn/用户数据报协议#UDP的分组结构">UDP 头部</a> 的结构（<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">udphdr</span></code>）具有以下字段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">udphdr</span> <span class="p">{</span>
      <span class="n">__be16</span>  <span class="n">source</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">dest</span><span class="p">;</span>
      <span class="n">__be16</span>  <span class="n">len</span><span class="p">;</span>
      <span class="n">__sum16</span> <span class="n">check</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">source</span></code> 是源端口；</li>
<li><code class="docutils literal"><span class="pre">dest</span></code> 是目标端口。</li>
</ul>
</div></blockquote>
<p>访问网络数据包头部中的信息的示例如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">iph</span> <span class="o">=</span> <span class="n">ip_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>                 <span class="cm">/* IP 头部 */</span>
<span class="cm">/* iph-&gt;saddr  - 源 IP 地址 */</span>
<span class="cm">/* iph-&gt;daddr  - 目标 IP 地址 */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_TCP</span><span class="p">)</span> <span class="p">{</span>              <span class="cm">/* TCP 协议 */</span>
        <span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcph</span> <span class="o">=</span> <span class="n">tcp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>      <span class="cm">/* TCP 头部 */</span>
        <span class="cm">/* tcph-&gt;source —— 源 TCP 端口 */</span>
        <span class="cm">/* tcph-&gt;dest   —— 目标 TCP 端口 */</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">protocol</span> <span class="o">==</span> <span class="n">IPPROTO_UDP</span><span class="p">)</span> <span class="p">{</span>       <span class="cm">/* UDP 协议 */</span>
        <span class="k">struct</span> <span class="n">udphdr</span> <span class="o">*</span><span class="n">udph</span> <span class="o">=</span> <span class="n">udp_hdr</span><span class="p">(</span><span class="n">skb</span><span class="p">);</span>      <span class="cm">/* UDP 头部 */</span>
        <span class="cm">/* udph-&gt;source —— 源 UDP 端口 */</span>
        <span class="cm">/* udph-&gt;dest   —— 目标 UDP 端口 */</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-8">
<span id="conversions"></span><h2>转换<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h2>
<p>不同系统的字，有多种字节的顺序方式 (<a class="reference external" href="http://zh.wikipedia.org/zh-cn/字节序">字节序</a>)，包括: <a class="reference external" href="http://zh.wikipedia.org/zh-cn/字节序#大端序">大端序</a> (最高位字节在前) 和 <a class="reference external" href="http://zh.wikipedia.org/zh-cn/字节序#小端序">小端序</a> (最低位字节在前)。由于网络连接了具有不同平台的系统，因此互联网对于数值数据的存储已经强加了一种标准序列，称为 <a class="reference external" href="http://zh.wikipedia.org/zh-cn/字节序#网络序">网络字节序</a>。相反，主机计算机上，表示数值数据的字节序列称为主机字节序。从网络接收/发送的数据采用网络字节序格式，并且应该在该格式和主机字节序之间进行转换。</p>
<p>为了进行转换，我们使用以下宏：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">u16</span> <span class="pre">htons(u16</span> <span class="pre">x)</span></code> 将 16 位整数从主机字节序转换为网络字节序（主机到网络短整数）；</li>
<li><code class="docutils literal"><span class="pre">u32</span> <span class="pre">htonl(u32</span> <span class="pre">x)</span></code> 将 32 位整数从主机字节序转换为网络字节序（主机到网络长整数）；</li>
<li><code class="docutils literal"><span class="pre">u16</span> <span class="pre">ntohs(u16</span> <span class="pre">x)</span></code> 将 16 位整数从网络字节序转换为主机字节序（网络到主机短整数）；</li>
<li><code class="docutils literal"><span class="pre">u32</span> <span class="pre">ntohl(u32</span> <span class="pre">x)</span></code> 将 32 位整数从网络字节序转换为主机字节序（网络到主机长整数）。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="netfilter-1">
<span id="netfilter"></span><h2>netfilter<a class="headerlink" href="#netfilter-1" title="永久链接至标题">¶</a></h2>
<p>Netfilter 是一个内核接口，用于捕获网络数据包以对其进行修改/分析（用于过滤、NAT 等）。在用户空间中，由 <a class="reference external" href="http://www.frozentux.net/documents/iptables-tutorial/">iptables</a> 使用 <a class="reference external" href="http://www.netfilter.org/">netfilter</a> 接口。</p>
<p>在 Linux 内核中，使用 netfilter 进行数据包捕获是通过附加钩子（hook）来实现的。钩子可以在内核网络数据包所经过的路径的不同位置指定，你可以根据需要进行配置。你可以在 <a class="reference external" href="http://linux-ip.net/nf/nfk-traversal.png">这里</a> 找到一张组织图，组织图上显示数据包所经过的路径以及钩子可能出现的区域。</p>
<p>使用 netfilter 时包含的头文件是 <code class="file docutils literal"><span class="pre">linux/netfilter.h</span></code>。</p>
<p>钩子通过 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nf_hook_ops</span></code> 结构体进行定义：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="p">{</span>
      <span class="cm">/* 用户从这里开始填写。*/</span>
      <span class="n">nf_hookfn</span>               <span class="o">*</span><span class="n">hook</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net_device</span>       <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
      <span class="kt">void</span>                    <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
      <span class="n">u_int8_t</span>                <span class="n">pf</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span>            <span class="n">hooknum</span><span class="p">;</span>
      <span class="cm">/* 钩子按优先级升序排列。*/</span>
      <span class="kt">int</span>                     <span class="n">priority</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>其中：</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">pf</span></code> 是数据包类型 (<code class="docutils literal"><span class="pre">PF_INET</span></code> 等)；</li>
<li><code class="docutils literal"><span class="pre">priority</span></code> 是优先级；优先级在 <code class="file docutils literal"><span class="pre">uapi/linux/netfilter_ipv4.h</span></code> 中定义如下：</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">nf_ip_hook_priorities</span> <span class="p">{</span>
      <span class="n">NF_IP_PRI_FIRST</span> <span class="o">=</span> <span class="n">INT_MIN</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK_DEFRAG</span> <span class="o">=</span> <span class="o">-</span><span class="mi">400</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_RAW</span> <span class="o">=</span> <span class="o">-</span><span class="mi">300</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_SELINUX_FIRST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">225</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK</span> <span class="o">=</span> <span class="o">-</span><span class="mi">200</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_MANGLE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">150</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_NAT_DST</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_FILTER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_SECURITY</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_NAT_SRC</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_SELINUX_LAST</span> <span class="o">=</span> <span class="mi">225</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK_HELPER</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_CONNTRACK_CONFIRM</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
      <span class="n">NF_IP_PRI_LAST</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">dev</span></code> 是捕获操作针对的设备（网络接口）；</li>
<li><code class="docutils literal"><span class="pre">hooknum</span></code> 是我们使用的钩子类型。当捕获到数据包时，处理模式由 <code class="docutils literal"><span class="pre">hooknum</span></code> 和 <code class="docutils literal"><span class="pre">hook</span></code> 字段定义。对于 IP，钩子类型在 <code class="file docutils literal"><span class="pre">linux/netfilter.h</span></code> 中定义：</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="n">nf_inet_hooks</span> <span class="p">{</span>
      <span class="n">NF_INET_PRE_ROUTING</span><span class="p">,</span>
      <span class="n">NF_INET_LOCAL_IN</span><span class="p">,</span>
      <span class="n">NF_INET_FORWARD</span><span class="p">,</span>
      <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
      <span class="n">NF_INET_POST_ROUTING</span><span class="p">,</span>
      <span class="n">NF_INET_NUMHOOKS</span>
<span class="p">};</span>
</pre></div>
</div>
<p></p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">hook</span></code> 是在捕获网络数据包时调用的处理程序（数据包以 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 结构体形式发送）。 <code class="docutils literal"><span class="pre">private</span></code> 字段是传递给处理程序的私有信息。捕获处理程序的原型由 <code class="xref c c-type docutils literal"><span class="pre">nf_hookfn</span></code> 类型定义：</li>
</ul>
</div></blockquote>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hook</span><span class="p">;</span>
      <span class="n">u_int8_t</span> <span class="n">pf</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">in</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net_device</span> <span class="o">*</span><span class="n">out</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="n">sk</span><span class="p">;</span>
      <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
      <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">okfn</span><span class="p">)(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sock</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">nf_hookfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
                             <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
                             <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
</pre></div>
</div>
<p>捕获函数 <code class="xref c c-func docutils literal"><span class="pre">nf_hookfn()</span></code> 中, <code class="docutils literal"><span class="pre">priv</span></code> 参数是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">nf_hook_ops</span></code> 初始化时传递的私有信息。 <code class="docutils literal"><span class="pre">skb</span></code> 是指向捕获的网络数据包的指针。根据 <code class="docutils literal"><span class="pre">skb</span></code> 的信息，可以进行数据包过滤决策。函数的 <code class="docutils literal"><span class="pre">state</span></code> 参数是与数据包捕获相关的状态信息，包括输入接口、输出接口、优先级和钩子号。优先级和钩子号可使同一个函数被多个钩子调用。</p>
<p>捕获处理程序可以返回以下常量之一 (<code class="docutils literal"><span class="pre">NF_*</span></code>)：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* hook 函数的响应结果 */</span>
<span class="cp">#define NF_DROP 0</span>
<span class="cp">#define NF_ACCEPT 1</span>
<span class="cp">#define NF_STOLEN 2</span>
<span class="cp">#define NF_QUEUE 3</span>
<span class="cp">#define NF_REPEAT 4</span>
<span class="cp">#define NF_STOP 5</span>
<span class="cp">#define NF_MAX_VERDICT NF_STOP</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">NF_DROP</span></code> 用于过滤（忽略）数据包, <code class="docutils literal"><span class="pre">NF_ACCEPT</span></code> 用于接受数据包并将其转发。</p>
<p>通过使用在 <code class="file docutils literal"><span class="pre">linux/netfilter.h</span></code> 中定义的函数来注册/注销一个 hook：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* 注册/注销 hook 点的函数 */</span>
<span class="kt">int</span> <span class="nf">nf_register_net_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">nf_unregister_net_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">nf_register_net_hooks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">nf_unregister_net_hooks</span><span class="p">(</span><span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="o">*</span><span class="n">reg</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>在 Linux 内核 3.11-rc2 版本之前，作为 netfilter 钩子参数的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sk_buff</span></code> 结构，内部的头部提取函数有一些限制。虽然每次都可以使用 <code class="xref c c-func docutils literal"><span class="pre">ip_hdr()</span></code> 获取 IP 头部，但是用于获取 TCP 和 UDP 头部的 <code class="xref c c-func docutils literal"><span class="pre">tcp_hdr()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">udp_hdr()</span></code> 函数，却只能对从系统内部，而非外部接收的数据包使用。对于后者的情况，需要手动计算数据包中的头部偏移量：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// TCP 数据包 (iph-&gt;protocol == IPPROTO_TCP)</span>
<span class="n">tcph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="o">*</span><span class="p">)((</span><span class="n">__u32</span><span class="o">*</span><span class="p">)</span><span class="n">iph</span> <span class="o">+</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>
<span class="c1">// UDP 数据包 (iph-&gt;protocol == IPPROTO_UDP)</span>
<span class="n">udph</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">udphdr</span><span class="o">*</span><span class="p">)((</span><span class="n">__u32</span><span class="o">*</span><span class="p">)</span><span class="n">iph</span> <span class="o">+</span> <span class="n">iph</span><span class="o">-&gt;</span><span class="n">ihl</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">这段代码适用于所有过滤场景，因此建议使用它来替代头部访问函数。</p>
</div>
<p>下面是一个 netfilter hook 的使用示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/netfilter.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/netfilter_ipv4.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/net.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/in.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/skbuff.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/ip.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/tcp.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">my_nf_hookfn</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">,</span>
              <span class="k">struct</span> <span class="n">sk_buff</span> <span class="o">*</span><span class="n">skb</span><span class="p">,</span>
              <span class="k">const</span> <span class="k">struct</span> <span class="n">nf_hook_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
      <span class="cm">/* 处理数据包 */</span>
      <span class="c1">//...</span>

      <span class="k">return</span> <span class="n">NF_ACCEPT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nf_hook_ops</span> <span class="n">my_nfho</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">.</span><span class="n">hook</span>        <span class="o">=</span> <span class="n">my_nf_hookfn</span><span class="p">,</span>
      <span class="p">.</span><span class="n">hooknum</span>     <span class="o">=</span> <span class="n">NF_INET_LOCAL_OUT</span><span class="p">,</span>
      <span class="p">.</span><span class="n">pf</span>          <span class="o">=</span> <span class="n">PF_INET</span><span class="p">,</span>
      <span class="p">.</span><span class="n">priority</span>    <span class="o">=</span> <span class="n">NF_IP_PRI_FIRST</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_hook_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="k">return</span> <span class="n">nf_register_net_hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_nfho</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_hook_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
      <span class="n">nf_unregister_net_hook</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_net</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_nfho</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">my_hook_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">my_hook_exit</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="netcat">
<h2>netcat<a class="headerlink" href="#netcat" title="永久链接至标题">¶</a></h2>
<p>在开发包含网络编程的应用程序时，常用的工具包括 netcat。它也被昵称为“TCP/IP 的瑞士军刀”。它可以用于以下功能：</p>
<blockquote>
<div><ul class="simple">
<li>发起 TCP 连接；</li>
<li>等待 TCP 连接；</li>
<li>发送和接收 UDP 数据包；</li>
<li>以十六进制转储（hexdump）格式显示流量；</li>
<li>在建立连接后运行程序（例如，一个 shell）；</li>
<li>在发送的数据包中设置特殊选项。</li>
</ul>
</div></blockquote>
<p>发起 TCP 连接：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">nc 主机名 端口号</span>
</pre></div>
</div>
<p>监听 TCP 端口：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">nc -l -p 端口号</span>
</pre></div>
</div>
<p>发送和接收 UDP 数据包，需要添加 <code class="docutils literal"><span class="pre">-u</span></code> 命令行选项。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">命令是 <strong class="command">nc</strong>；通常 <strong class="command">netcat</strong> 是此命令的别名。还有其他实现 netcat 命令的版本，其中一些与经典实现参数略有不同。运行 <strong class="command">man nc</strong> 或 <strong class="command">nc -h</strong> 以查看如何使用它。</p>
</div>
<p>有关 netcat 的更多信息，请参阅以下 <a class="reference external" href="https://www.win.tue.nl/~aeb/linux/hh/netcat_tutorial.pdf">教程</a>。</p>
</div>
<div class="section" id="section-9">
<h2>进一步阅读<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>了解 Linux 网络内部</li>
<li><a class="reference external" href="http://www.cs.unh.edu/cnrg/gherrin/">Linux IP 网络</a></li>
<li><a href="#system-message-1"><span class="problematic" id="problematic-1">`TUX Web 服务器`_</span></a></li>
<li><a class="reference external" href="https://www.beej.us/guide/bgnet/">Beej 的互联网套接字网络编程指南</a></li>
<li><a class="reference external" href="http://www.linuxjournal.com/article/7660">内核中的网络编程——Kernel Korner</a></li>
<li><a class="reference external" href="http://phrack.org/issues/61/13.html">深入 Linux 内核网络堆栈</a></li>
<li><a class="reference external" href="http://www.netfilter.org/">netfilter.org 项目</a></li>
<li><a class="reference external" href="https://www.digitalocean.com/community/tutorials/a-deep-dive-into-iptables-and-netfilter-architecture">深入了解 Iptables 和 Netfilter 架构</a></li>
<li><a class="reference external" href="http://www.linuxfoundation.org/en/Net:Main_Page">Linux 基金会网络页面</a></li>
</ol>
</div>
<div class="section" id="section-10">
<h2>练习<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>我们强烈建议你使用 <a class="reference external" href="https://github.com/linux-kernel-labs-zh/so2-labs">这个仓库</a> 中的配置。</p>
<p>要解决练习问题，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 networking。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;实验名称&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;实验名称&gt;/&lt;任务名称&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make console
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/networking/&lt;任务名称&gt; 目录中。</p>
<p>重新构建模块时，无需停止虚拟机！本地 <cite>skels</cite> 目录与虚拟机共享。</p>
<p class="last">请查看 <a class="reference internal" href="#section-10">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p class="last">你需要确保内核支持 <code class="docutils literal"><span class="pre">netfilter</span></code>。可以通过 <code class="docutils literal"><span class="pre">CONFIG_NETFILTER</span></code> 来启用它。要激活它，请在 <code class="file docutils literal"><span class="pre">linux</span></code> 目录中运行 <strong class="command">make menuconfig</strong>，并在 <code class="docutils literal"><span class="pre">Networking</span> <span class="pre">support</span> <span class="pre">-&gt;</span> <span class="pre">Networking</span> <span class="pre">options</span></code> 中勾选 <code class="docutils literal"><span class="pre">Network</span> <span class="pre">packet</span> <span class="pre">filtering</span> <span class="pre">framework</span> <span class="pre">(Netfilter)</span></code> 选项。如果它未启用，请启用它（作为内置功能，而不是外部模块——必须带有 <code class="docutils literal"><span class="pre">*</span></code> 标记）。</p>
</div>
<div class="section" id="section-11">
<h3>1. 在内核空间中显示数据包<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h3>
<p>编写一个内核模块，显示发起出站连接的 TCP 数据包的源地址和端口。从 <code class="file docutils literal"><span class="pre">1-2-netfilter</span></code> 中的代码开始，并填写标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> 的区域，同时考虑下面的注释。</p>
<p>你需要注册一个类型为 <code class="docutils literal"><span class="pre">NF_INET_LOCAL_OUT</span></code> 的 netfilter 钩子，如 <a href="#system-message-2"><span class="problematic" id="problematic-2">`netfilter`_</span></a> 部分所述。</p>
<p>借助 <a href="#system-message-3"><span class="problematic" id="problematic-3">`struct sk_buff 结构`_</span></a>, 你可以使用特定的函数访问数据包头部。<code class="xref c c-func docutils literal"><span class="pre">ip_hdr()</span></code> 函数以返回指向 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iphdr</span></code> 结构的指针的形式，返回 IP 头部。<code class="xref c c-func docutils literal"><span class="pre">tcp_hdr()</span></code> 函数以返回指向 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">tcphdr</span></code> 结构的指针的形式，返回 TCP 头部。</p>
<p><a class="reference external" href="http://www.eventhelix.com/Realtimemantra/Networking/Tcp.pdf">图表</a> 解释了如何建立 TCP 连接。连接初始化数据包在 TCP 头部中设置了 <code class="docutils literal"><span class="pre">SYN</span></code> 标志，并清除了 <code class="docutils literal"><span class="pre">ACK</span></code> 标志。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>要显示源 IP 地址，请使用 printk 函数的 <code class="docutils literal"><span class="pre">%pI4</span></code> 格式。详细信息可以在 <a class="reference external" href="https://www.kernel.org/doc/Documentation/printk-formats.txt">内核文档</a> (<code class="docutils literal"><span class="pre">IPv4</span> <span class="pre">addresses</span></code> 部分)中找到。以下是使用 <code class="docutils literal"><span class="pre">%pI4</span></code> 的示例代码片段：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">printk</span><span class="p">(</span><span class="s">&quot;IP address is %pI4</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">saddr</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">在使用 <code class="docutils literal"><span class="pre">%pI4</span></code> 格式时，printk 的实参是指针。因此，构造应为 <code class="docutils literal"><span class="pre">&amp;iph-&gt;saddr</span></code> （带有 &amp; 运算符）而不是 <code class="docutils literal"><span class="pre">iph-&gt;saddr</span></code>。</p>
</div>
<p>在 TCP 头部中，源 TCP 端口以 <a class="reference external" href="http://zh.wikipedia.org/zh-cn/字节序#网络序">网络字节序</a> 格式表示。请阅读 <span class="xref std std-ref">转换</span> 部分。使用 <code class="xref c c-func docutils literal"><span class="pre">ntohs()</span></code> 进行转换。</p>
<p>为了进行测试，请使用 <code class="file docutils literal"><span class="pre">1-2-netfilter/user/test-1.sh</span></code> 文件。该测试创建一个到本地主机的连接，然后由内核模块拦截和显示该连接。 <strong class="command">make copy</strong> 命令仅会在该脚本标记为可执行的情况下，才会将该脚本复制到虚拟机上。该脚本使用静态编译得到的 <strong class="command">netcat</strong> 工具，该工具的路径是 <code class="file docutils literal"><span class="pre">skels/networking/netcat</span></code>；此程序必须具有执行权限。</p>
<p>运行检查器后，输出应类似于下面的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp"># ./test-1.sh</span>
<span class="p">[</span>  <span class="mf">229.783512</span><span class="p">]</span> <span class="n">TCP</span> <span class="n">connection</span> <span class="n">initiated</span> <span class="n">from</span> <span class="mf">127.0.0.1</span><span class="o">:</span><span class="mi">44716</span>
<span class="n">Should</span> <span class="n">show</span> <span class="n">up</span> <span class="n">in</span> <span class="n">filter</span><span class="p">.</span>
<span class="n">Check</span> <span class="n">dmesg</span> <span class="n">output</span><span class="p">.</span>
</pre></div>
</div>
</div>
<div class="section" id="section-12">
<h3>2. 按目标地址进行过滤<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h3>
<p>扩展练习 1 中的模块，以便你可以通过 <code class="docutils literal"><span class="pre">MY_IOCTL_FILTER_ADDRESS</span></code> ioctl 调用指定目标地址。注意只显示包含指定目标地址的数据包。为了解决这个任务，填写标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> 的区域，并按照以下规范进行操作。</p>
<p>要实现 ioctl 例程，你必须填写 <code class="docutils literal"><span class="pre">my_ioctl</span></code> 函数。请查看 <a class="reference internal" href="../so2/lab3-device-drivers.html#ioctl"><span class="std std-ref">ioctl</span></a> 部分的内容。从用户空间发送的地址使用 <a class="reference external" href="http://zh.wikipedia.org/zh-cn/字节序#网络序">网络字节序</a>, 因此 <strong>无需</strong> 进行转换。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">通过 <code class="docutils literal"><span class="pre">ioctl</span></code> 发送的 IP 地址是通过地址发送的，而不是通过值发送的。地址必须存储在 <code class="docutils literal"><span class="pre">ioctl_set_addr</span></code> 变量中。可以使用 <code class="xref c c-func docutils literal"><span class="pre">copy_from_user()</span></code> 进行复制。</p>
</div>
<p>要比较地址，请填写 <code class="docutils literal"><span class="pre">test_daddr</span></code> 函数。这里我们无需转换地址，即可将（使用网络字节序的）地址进行比较（如果从左到右相等，则反转后也相等）。</p>
<p>如果要显示按目标地址过滤出的连接初始化数据包（这些过滤出的数据包，其目标地址与我们通过 ioctl 例程发送的地址相符），那么 <code class="docutils literal"><span class="pre">test_daddr</span></code> 函数必须在 netfilter 钩子中调用。连接初始化数据包在 TCP 头部中设置了 <code class="docutils literal"><span class="pre">SYN</span></code> 标志，并清除了 <code class="docutils literal"><span class="pre">ACK</span></code> 标志。你需要检查两件事情：</p>
<blockquote>
<div><ul class="simple">
<li>TCP 标志；</li>
<li>数据包的目标地址（使用 <code class="docutils literal"><span class="pre">test_addr</span></code>）。</li>
</ul>
</div></blockquote>
<p>为了进行测试，请使用 <code class="file docutils literal"><span class="pre">1-2-netfilter/user/test-2.sh</span></code> 脚本。此脚本需要编译 <code class="file docutils literal"><span class="pre">1-2-netfilter/user/test.c</span></code> 文件以生成测试可执行文件。在物理系统上运行 <strong class="command">make build</strong> 命令时，会自动进行编译。只有标记为可执行，该测试脚本才会复制到虚拟机上。该脚本使用静态编译的 <strong class="command">netcat</strong> 工具（在 <code class="file docutils literal"><span class="pre">skels/networking/netcat</span></code> 中）；该可执行文件必须具有执行权限。</p>
<p>运行检查器后，输出应类似于下面的示例：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">#</span> ./test-2.sh
<span class="go">[  797.673535] TCP connection initiated from 127.0.0.1:44721</span>
<span class="go">Should show up in filter.</span>
<span class="go">Should NOT show up in filter.</span>
<span class="go">Check dmesg output.</span>
</pre></div>
</div>
<p>测试首先要求对 <code class="docutils literal"><span class="pre">127.0.0.1</span></code> IP 地址进行数据包过滤，然后对 <code class="docutils literal"><span class="pre">127.0.0.2</span></code> IP 地址进行过滤。第一个连接初始化数据包（到 <code class="docutils literal"><span class="pre">127.0.0.1</span></code>）被过滤器拦截并显示，而第二个数据包（到 <code class="docutils literal"><span class="pre">127.0.0.2</span></code>）则未被拦截。</p>
</div>
<div class="section" id="tcp-socket">
<h3>3. 监听 TCP socket<a class="headerlink" href="#tcp-socket" title="永久链接至标题">¶</a></h3>
<p>编写一个内核模块，在回环接口（loopback interface）（在 <code class="docutils literal"><span class="pre">init_module</span></code> 中）上创建监听连接的 TCP 套接字，监听端口为 <code class="docutils literal"><span class="pre">60000</span></code>。从 <code class="file docutils literal"><span class="pre">3-4-tcp-sock</span></code> 中的代码开始，填写标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">1</span></code> 的区域，同时考虑以下观察结果。</p>
<p>请阅读 <a class="reference internal" href="#socket">对 socket 结构的操作</a> 和 <a class="reference internal" href="#struct-proto-ops">struct proto_ops 结构</a> 部分。</p>
<p><code class="docutils literal"><span class="pre">sock</span></code> socket 是 <code class="docutils literal"><span class="pre">服务器套接字</span></code>，因此必须处于监听状态。也就是说，必须对该 socket 执行 <code class="docutils literal"><span class="pre">bind</span></code> 和 <code class="docutils literal"><span class="pre">listen</span></code> 操作。在内核空间中，要执行类似于 <code class="docutils literal"><span class="pre">bind</span></code> 和 <code class="docutils literal"><span class="pre">listen</span></code> 的操作，你需要调用类似 <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;...;</span></code> 的函数。你可以调用的示例函数包括 <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;bind</span></code>, <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;listen</span></code> 等。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>例如，调用 <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;bind</span></code> 或 <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;listen</span></code> 函数，查看在 <code class="xref c c-func docutils literal"><span class="pre">sys_bind()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">sys_listen()</span></code> 系统调用处理程序中调用它们的方式。</p>
<p class="last">在 Linux 内核源代码树的 <code class="docutils literal"><span class="pre">net/socket.c</span></code> 文件中，查找系统调用处理程序。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">对于 <code class="docutils literal"><span class="pre">listen</span></code> 的第二个参数（backlog），请使用 <code class="docutils literal"><span class="pre">LISTEN_BACKLOG</span></code>。</p>
</div>
<p>在模块的退出函数和标有错误标签的区域中记得释放 socket；可以使用 <code class="xref c c-func docutils literal"><span class="pre">sock_release()</span></code> 来释放。</p>
<p>要进行测试，请运行 <strong class="command">3-4-tcp_sock/test-3.sh</strong> 脚本。只有在标记为可执行时，该脚本才会通过 <strong class="command">make copy</strong> 复制到虚拟机上。</p>
<p>运行测试后，将显示一个 TCP 套接字，通过监听端口 <code class="docutils literal"><span class="pre">60000</span></code> 进行连接。</p>
</div>
<div class="section" id="section-13">
<h3>4. 在内核空间接受连接<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h3>
<p>扩展上一个练习中的模块，以允许外部连接（无需发送任何消息，只需接受新连接）。填写标有 <code class="docutils literal"><span class="pre">TODO</span> <span class="pre">2</span></code> 的区域。</p>
<p>请阅读 <a class="reference internal" href="#socket">对 socket 结构的操作</a> 和 <a class="reference internal" href="#struct-proto-ops">struct proto_ops 结构</a> 部分。</p>
<p>对于内核空间的 <code class="docutils literal"><span class="pre">accept</span></code> 等效操作，请参阅 <code class="xref c c-func docutils literal"><span class="pre">sys_accept4()</span></code> 系统调用处理程序。请查看 <a class="reference external" href="https://elixir.bootlin.com/linux/v4.17/source/drivers/staging/lustre/lnet/lnet/lib-socket.c#L511">lnet_sock_accept</a> 实现，以及如何使用 <code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;accept</span></code> 调用。将倒数第二个参数 (<code class="docutils literal"><span class="pre">flags</span></code>) 的值设为 <code class="docutils literal"><span class="pre">0</span></code>，将最后一个参数 (<code class="docutils literal"><span class="pre">kern</span></code>) 的值设为 <code class="docutils literal"><span class="pre">true</span></code>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在 Linux 内核源代码树的 <code class="docutils literal"><span class="pre">net/socket.c</span></code> 文件中查找系统调用处理程序。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>必须使用 <code class="xref c c-func docutils literal"><span class="pre">sock_create_lite()</span></code> 函数创建新套接字 (<code class="docutils literal"><span class="pre">new_sock</span></code>)，然后使用以下方式配置其操作：</p>
<div class="last highlight-console"><div class="highlight"><pre><span></span><span class="go">newsock-&gt;ops = sock-&gt;ops;</span>
</pre></div>
</div>
</div>
<p>打印目标 socket 的地址和端口。要查找 socket 的对等名称（即地址），请参考 <code class="xref c c-func docutils literal"><span class="pre">sys_getpeername()</span></code> 系统调用处理程序。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p><code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;getname</span></code> 函数的第一个参数是连接套接字，即通过 <code class="docutils literal"><span class="pre">accept</span></code> 调用初始化的 <code class="docutils literal"><span class="pre">new_sock</span></code>。</p>
<p><code class="docutils literal"><span class="pre">sock-&gt;ops-&gt;getname</span></code> 函数的最后一个参数是 <code class="docutils literal"><span class="pre">1</span></code>，表示我们想要了解有关端点或对等点 (<em>远程端</em> 或 <em>对等点</em>) 的信息。</p>
<p class="last">使用文件中定义的 <code class="docutils literal"><span class="pre">print_sock_address</span></code> 宏显示对等地址（由 <code class="docutils literal"><span class="pre">raddr</span></code> 变量指示）。</p>
</div>
<p>在模块的退出函数中，以及在错误标签之后，释放新创建的套接字（接受连接后）。在将 <code class="docutils literal"><span class="pre">accept</span></code> 代码添加到模块初始化函数之后，<strong class="command">insmod</strong> 操作将会阻塞，直到建立连接。你可以使用 <strong class="command">netcat</strong> 在该端口上解锁。因此，上一个练习中的测试脚本将无法工作。</p>
<p>要进行测试，请运行 <code class="file docutils literal"><span class="pre">3-4-tcp_sock/test-4.sh</span></code> 脚本。只有在标记为可执行时，该脚本才会通过 <strong class="command">make copy</strong> 复制到虚拟机上。</p>
<p>不会显示任何特殊内容（在内核缓冲区中）。测试的成功将由连接的建立来确定。然后使用 <code class="docutils literal"><span class="pre">Ctrl+c</span></code> 停止测试脚本，然后可以移除内核模块。</p>
</div>
<div class="section" id="udp-1">
<h3>5. UDP 套接字发送方<a class="headerlink" href="#udp-1" title="永久链接至标题">¶</a></h3>
<p>编写一个内核模块，其创建一个 UDP socket，并将来自 socket 的 <code class="docutils literal"><span class="pre">MY_TEST_MESSAGE</span></code> 宏的消息发送到回环地址的端口 <code class="docutils literal"><span class="pre">60001</span></code>。</p>
<p>从 <code class="file docutils literal"><span class="pre">5-udp-sock</span></code> 中的代码开始。</p>
<p>请阅读 <a class="reference internal" href="#socket">对 socket 结构的操作</a> 和 <a class="reference internal" href="#struct-proto-ops">struct proto_ops 结构</a> 部分。</p>
<p>要了解如何在内核空间中发送消息，请参阅 <code class="xref c c-func docutils literal"><span class="pre">sys_send()</span></code> 系统调用处理程序或 <a class="reference internal" href="#section-7">发送/接收消息</a>。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> 结构的 <code class="docutils literal"><span class="pre">msg_name</span></code> 字段必须初始化为目标地址（指向 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">sockaddr</span></code> 的指针）, <code class="docutils literal"><span class="pre">msg_namelen</span></code> 字段必须初始化为地址大小。</p>
<p>将 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> 结构的 <code class="docutils literal"><span class="pre">msg_flags</span></code> 字段初始化为 <code class="docutils literal"><span class="pre">0</span></code>。</p>
<p class="last">将 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">msghdr</span></code> 结构的 <code class="docutils literal"><span class="pre">msg_control</span></code> 和 <code class="docutils literal"><span class="pre">msg_controllen</span></code> 字段分别初始化为 <code class="docutils literal"><span class="pre">NULL</span></code> 和 <code class="docutils literal"><span class="pre">0</span></code>。</p>
</div>
<p>要发送消息，请使用 <code class="xref c c-func docutils literal"><span class="pre">kernel_sendmsg()</span></code>。</p>
<p>消息传输参数从内核空间中检索。在 <code class="xref c c-func docutils literal"><span class="pre">kernel_sendmsg()</span></code> 调用中，将 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">iovec</span></code> 结构指针转换为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kvec</span></code> 指针。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last"><code class="xref c c-func docutils literal"><span class="pre">kernel_sendmsg()</span></code> 的最后两个参数分别为 <code class="docutils literal"><span class="pre">1</span></code> (I/O 向量的数量) 和 <code class="docutils literal"><span class="pre">len</span></code> (消息大小)。</p>
</div>
<p>要进行测试，请使用 <code class="file docutils literal"><span class="pre">test-5.sh</span></code> 脚本。只有在标记为可执行时，该脚本才会通过 <strong class="command">make copy</strong> 复制到虚拟机上。该脚本使用存储在 <code class="file docutils literal"><span class="pre">skels/networking/netcat</span></code> 中的静态编译的 <code class="docutils literal"><span class="pre">netcat</span></code> 工具；该可执行文件必须具有执行权限。</p>
<p>如果正确实现，运行 <code class="file docutils literal"><span class="pre">test-5.sh</span></code> 脚本后，将显示类似下面的输出中的 <code class="docutils literal"><span class="pre">kernelsocket</span></code> 消息：</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">/root # ./test-5.sh</span>
<span class="go">+ pid=1059</span>
<span class="go">+ sleep 1</span>
<span class="go">+ nc -l -u -p 60001</span>
<span class="go">+ insmod udp_sock.ko</span>
<span class="go">kernelsocket</span>
<span class="go">+ rmmod udp_sock</span>
<span class="go">+ kill 1059</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="filesystems_part2.html" class="btn btn-neutral float-left" title="文件系统驱动程序（第二部分）" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="arm_kernel_development.html" class="btn btn-neutral float-right" title="ARM 内核开发" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>