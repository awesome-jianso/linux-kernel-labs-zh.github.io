<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" /><meta content="理解延迟工作（即在稍后时间执行的代码），实现使用延迟工作的常见任务，理解延迟工作的同步特性" name="description" />
<meta content="softirq, tasklet, struct tasklet_struct, 下半部处理程序, jiffies, HZ, timer, struct timer_list, spin_lock_bh, spin_unlock_bh, workqueue, struct work_struct, 内核线程, events/x" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>延迟工作 &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="块设备驱动程序" href="block_device_drivers.html" />
    <link rel="prev" title="I/O 访问和中断" href="interrupts.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">操作系统 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">体系结构层</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">虚拟化</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">延迟工作</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-2">实验目标</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-3">背景信息</a></li>
<li class="toctree-l2"><a class="reference internal" href="#softirqs">软中断（Softirqs）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tasklet">tasklet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timer">定时器（Timer）</a></li>
<li class="toctree-l3"><a class="reference internal" href="#locking">锁定（Locking）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-4">工作队列</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-5">内核线程</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-6">进一步阅读</a></li>
<li class="toctree-l2"><a class="reference internal" href="#section-7">练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-8">0. 简介</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-9">1. 定时器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-10">2. 周期性定时器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#ioctl">3. 使用 ioctl 控制定时器</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-11">4. 阻塞操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-12">5. 工作队列</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-13">6. 内核线程</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-14">7. 定时器和进程之间共享的缓冲区</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">内存映射</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_model.html">Linux 设备模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">向 Linux 内核实验项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">延迟工作</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/deferred_work.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="section-1">
<h1>延迟工作<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-2">
<h2>实验目标<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>理解延迟工作（即在稍后时间执行的代码）</li>
<li>实现使用延迟工作的常见任务</li>
<li>理解延迟工作的同步特性</li>
</ul>
<p>关键词：softirq、tasklet、struct tasklet_struct、下半部处理程序、jiffies、HZ、timer、struct timer_list、spin_lock_bh、spin_unlock_bh、workqueue、struct work_struct、内核线程、events/x</p>
</div>
<div class="section" id="section-3">
<h2>背景信息<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h2>
<p>延迟工作是一类内核功能，允许我们安排代码在稍后的时间执行。这些安排的代码可以在进程上下文或中断上下文中运行，具体取决于延迟工作的类型。延迟工作用于补充中断处理程序的功能，因为中断具有重要的要求和限制：</p>
<ul class="simple">
<li>中断处理程序的执行时间必须尽可能短</li>
<li>在中断上下文中，我们不能使用阻塞调用</li>
</ul>
<p>使用延迟工作，我们可以在中断处理程序中执行最小所需的工作，并安排一个异步操作在稍后的时间运行，以执行其余的操作。</p>
<p>在中断上下文中运行的延迟工作也称为下半部（bottom-half），因为其目的是执行中断处理程序（top-half）之外所剩余的操作。</p>
<p>定时器（timer）是另一种类型的延迟工作，用于调度在经过一定时间后未来操作的执行。</p>
<p>内核线程本身并不是延迟工作，但可以用来补充延迟工作机制。通常，内核线程用作处理包含阻塞调用的事件的“工作线程（workers）”。</p>
<p>所有类型的延迟工作都使用三种典型的操作：</p>
<ol class="arabic simple">
<li><strong>初始化</strong>。每种类型都由一个结构描述，其字段需要进行初始化。在此时还设置要调度的处理程序。</li>
<li><strong>调度</strong>。尽快安排处理程序的执行（或在超时后）。</li>
<li><strong>屏蔽</strong> 或 <strong>取消</strong>。禁用处理程序的执行。此操作可以是同步的（可保证在取消完成后不再运行处理程序）或异步的。</li>
</ol>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">在进行延迟工作的清理工作（例如释放与延迟工作相关的结构或从内核中删除模块及其处理程序代码），始终使用同步类型的延迟工作取消。</p>
</div>
<p>主要的延迟工作类型包括内核线程和软中断（softirq）。工作队列是在内核线程之上实现的，而 tasklet 和定时器是在软中断之上实现的。下半部（bottom-half）处理程序是 Linux 中最早的延迟工作实现，但后来被软中断所取代。这就是某些函数名称中含有 <em>bh</em> 的原因（译注：bh 即 bottom-half 的首字母缩写）。</p>
</div>
<div class="section" id="softirqs">
<h2>软中断（Softirqs）<a class="headerlink" href="#softirqs" title="永久链接至标题">¶</a></h2>
<p>设备驱动程序不能使用软中断，软中断专门为各种内核子系统保留。因此，在编译时定义的软中断的数量是固定的。针对当前内核版本，定义了以下类型：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="p">{</span>
    <span class="n">HI_SOFTIRQ</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">TIMER_SOFTIRQ</span><span class="p">,</span>
    <span class="n">NET_TX_SOFTIRQ</span><span class="p">,</span>
    <span class="n">NET_RX_SOFTIRQ</span><span class="p">,</span>
    <span class="n">BLOCK_SOFTIRQ</span><span class="p">,</span>
    <span class="n">IRQ_POLL_SOFTIRQ</span><span class="p">,</span>
    <span class="n">TASKLET_SOFTIRQ</span><span class="p">,</span>
    <span class="n">SCHED_SOFTIRQ</span><span class="p">,</span>
    <span class="n">HRTIMER_SOFTIRQ</span><span class="p">,</span>
    <span class="n">RCU_SOFTIRQ</span><span class="p">,</span>
    <span class="n">NR_SOFTIRQS</span>
<span class="p">};</span>
</pre></div>
</div>
<p>每种类型都有特定的用途：</p>
<ul class="simple">
<li><em>HI_SOFTIRQ</em> 和 <em>TASKLET_SOFTIRQ</em> ——运行任务（tasklet）</li>
<li><em>TIMER_SOFTIRQ</em> ——运行定时器</li>
<li><em>NET_TX_SOFTIRQ</em> 和 <em>NET_RX_SOFTIRQ</em> ——由网络子系统使用</li>
<li><em>BLOCK_SOFTIRQ</em> ——由 IO 子系统使用</li>
<li><em>BLOCK_IOPOLL_SOFTIRQ</em> ——当调用 iopoll 处理程序时，由 IO 子系统使用以提高性能</li>
<li><em>SCHED_SOFTIRQ</em> ——负载均衡</li>
<li><em>HRTIMER_SOFTIRQ</em> ——高精度定时器的实现</li>
<li><em>RCU_SOFTIRQ</em> ——RCU 类型机制的实现 <a class="footnote-reference" href="#footnote-1" id="footnote-reference-1">[1]</a></li>
</ul>
<table class="docutils footnote" frame="void" id="footnote-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#footnote-reference-1">[1]</a></td><td>RCU 是一种机制，用于按照两个步骤执行破坏性操作（例如从链表中删除元素）：（1）移除对已删除数据的引用（2）释放元素的内存。只有在确保没有人再使用该元素后，才执行第二个步骤。此机制的优点是可以无需同步地读取数据。有关更多信息，请参阅 Documentation/RCU/rcu.txt。</td></tr>
</tbody>
</table>
<p><em>HI_SOFTIRQ</em> 类型的软中断优先级最高，其次是其他定义的软中断。<em>RCU_SOFTIRQ</em> 具有最低优先级。</p>
<p>软中断在中断上下文中运行，这意味着它们不能调用阻塞函数。如果软中断处理程序需要调用此类函数，可以调度工作队列来执行这些阻塞调用。</p>
<div class="section" id="tasklet">
<h3>tasklet<a class="headerlink" href="#tasklet" title="永久链接至标题">¶</a></h3>
<p>与软中断类似，任务（tasklet）是一种在中断上下文中运行的延迟工作。任务（tasklet）与软中断之间的主要区别在于，任务（tasklet）可以动态分配，并且因此可以被设备驱动程序使用。任务（tasklet）由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">tasklet</span></code> 表示，与许多其他内核结构一样，需要在使用之前进行初始化。预初始化的任务（tasklet）可以以如下方式定义：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="n">DECLARE_TASKLET</span><span class="p">(</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="n">DECLARE_TASKLET_DISABLED</span><span class="p">(</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>如果我们想手动初始化任务（tasklet），可以使用以下方法：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">handler</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="n">tasklet</span><span class="p">;</span>

<span class="n">tasklet_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tasklet</span><span class="p">,</span> <span class="n">handler</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>当执行任务（tasklet）时，<em>data</em> 参数将发送给处理程序。</p>
<p>可以使用调度操作来安排任务（tasklet）的运行。任务（tasklet）是在软中断的基础上执行的。可以使用以下函数进行任务（tasklet）的调度：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">tasklet_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">tasklet</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">tasklet_hi_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">tasklet</span><span class="p">);</span>
</pre></div>
</div>
<p>使用 <em>tasklet_schedule</em> 函数，将调度一个 <em>TASKLET_SOFTIRQ</em> 软中断，并运行所有调度的任务（tasklet）。对于 <em>tasklet_hi_schedule</em> 函数，将调度一个 <em>HI_SOFTIRQ</em> 软中断。</p>
<p>如果一个任务（tasklet）被多次调度，并且在多个调度之间这个任务（tasklet）没有运行，它将只运行一次。任务（tasklet）运行后，可以重新调度它，以便在稍后的时间再次运行。任务（tasklet）可以被其处理程序重新安排。</p>
<p>任务（tasklet）可以被屏蔽，可以使用以下函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">tasklet_enable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">tasklet</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">tasklet_disable</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">tasklet</span><span class="p">);</span>
</pre></div>
</div>
<p>请记住，由于任务（tasklet）是在软中断的基础上执行的，因此不能在处理程序函数中使用阻塞调用。</p>
</div>
<div class="section" id="timer">
<h3>定时器（Timer）<a class="headerlink" href="#timer" title="永久链接至标题">¶</a></h3>
<p>定时器是一种特殊类型的延迟工作。它们由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span></code> 定义，并在中断上下文中运行，是基于软中断实现的。</p>
<p>要使用定时器，首先必须调用 <code class="xref c c-func docutils literal"><span class="pre">timer_setup()</span></code> 函数进行初始化：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">timer_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span>
       <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="p">),</span>
       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
</pre></div>
</div>
<p>上述函数初始化了结构体的内部字段，并将 <em>function</em> 关联为定时器处理程序。由于定时器是通过软中断计划的，因此在与处理函数相关的代码中不能使用阻塞调用。</p>
<p>使用 <code class="xref c c-func docutils literal"><span class="pre">mod_timer()</span></code> 函数进行定时器的调度：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">mod_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expires</span><span class="p">);</span>
</pre></div>
</div>
<p>其中 <em>expires</em> 是要运行处理函数的时间（未来的时间）。该函数可用于调度或重新调度定时器。</p>
<p>时间单位为 <em>jiffie</em>。一 jiffie 的绝对值取决于平台，并且可以使用 <code class="xref c c-type docutils literal"><span class="pre">HZ</span></code> 宏找到，该宏定义了 1 秒内的 jiffies 数。要在 jiffies (<em>jiffies_value</em>) 和秒 (<em>seconds_value</em>) 之间进行转换，使用以下公式：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">jiffies_value</span> <span class="o">=</span> <span class="n">seconds_value</span> <span class="o">*</span> <span class="n">HZ</span> <span class="p">;</span>
<span class="n">seconds_value</span> <span class="o">=</span> <span class="n">jiffies_value</span> <span class="o">/</span> <span class="n">HZ</span> <span class="p">;</span>
</pre></div>
</div>
<p>内核维护一个计数器，其中包含自上次引导（boot）以来的 jiffies 数，可以通过全局变量或宏 <code class="xref c c-macro docutils literal"><span class="pre">jiffies</span></code> 访问。我们可以使用它来为定时器计算未来的时间：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/jiffies.h&gt;</span><span class="cp"></span>

<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">current_jiffies</span><span class="p">,</span> <span class="n">next_jiffies</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seconds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">current_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="n">next_jiffies</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">seconds</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
</pre></div>
</div>
<p>要停止定时器，请使用 <code class="xref c c-func docutils literal"><span class="pre">del_timer()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">del_timer_sync()</span></code> 函数：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">del_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">del_timer_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="n">timer</span><span class="p">);</span>
</pre></div>
</div>
<p>这些函数可以用于已调度的定时器和未计划的定时器。<code class="xref c c-func docutils literal"><span class="pre">del_timer_sync()</span></code> 用于消除在多处理器系统上可能出现的竞态条件，因为在调用结束时，可以保证定时器处理函数不会在任何处理器上运行。</p>
<p>在使用定时器时，常见的错误是忘记关闭定时器。例如，在移除模块之前，我们必须停止定时器，因为如果定时器在模块被移除后过期，处理函数将不再加载到内核中，从而导致内核出错。</p>
<p>通常用于初始化和调度一秒钟超时的代码是：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">timer_function</span><span class="p">(</span><span class="k">struct</span> <span class="n">timer_list</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">timer_list</span> <span class="n">timer</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seconds</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">timer_setup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="n">timer_function</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">mod_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">,</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">seconds</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">);</span>
</pre></div>
</div>
<p>停止定时器的方法如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">timer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="locking">
<h3>锁定（Locking）<a class="headerlink" href="#locking" title="永久链接至标题">¶</a></h3>
<p>为了在运行在进程上下文（A）的代码和运行在软中断上下文（B）的代码之间进行同步，我们需要使用特殊的锁原语。我们必须在（A）中使用自旋锁操作，并禁用底半部处理程序，在（B）中只使用基本的自旋锁操作。使用自旋锁可以确保在禁用软中断后，多个 CPU 之间不会发生竞争，而禁用软中断可以确保在已经获取自旋锁的 CPU 上调度软中断时不会发生死锁。</p>
<p>我们可以使用 <code class="xref c c-func docutils literal"><span class="pre">local_bh_disable()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">local_bh_enable()</span></code> 来禁用和启用软中断处理程序（并且由于定时器和任务（tasklet）在软中断之上运行，还包括它们）：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">local_bh_disable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">local_bh_enable</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>允许嵌套调用，当所有的 local_bh_disable() 调用都有相应的 local_bh_enable() 调用时，才会实际重新启用软中断：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* 假设软中断已启用 */</span>
<span class="n">local_bh_disable</span><span class="p">();</span>  <span class="cm">/* 现在禁用了软中断 */</span>
<span class="n">local_bh_disable</span><span class="p">();</span>  <span class="cm">/* 软中断仍处于禁用状态 */</span>

<span class="n">local_bh_enable</span><span class="p">();</span>  <span class="cm">/* 软中断仍处于禁用状态 */</span>
<span class="n">local_bh_enable</span><span class="p">();</span>  <span class="cm">/* 现在启用了软中断 */</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">上述调用只会在本地处理器上禁用软中断，通常不安全，必须与自旋锁配合使用。</p>
</div>
<p>大多数情况下，设备驱动程序将使用用于同步的特殊版本的自旋锁调用，如 <code class="xref c c-func docutils literal"><span class="pre">spin_lock_bh()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">spin_unlock_bh()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">spin_lock_bh</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">spin_unlock_bh</span><span class="p">(</span><span class="n">spinlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="section-4">
<h2>工作队列<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h2>
<p>工作队列（workqueue）用于在进程上下文中调度要执行的操作。它们所处理的基本单元称为工作项（work）。有两种类型的工作项：</p>
<ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span></code> ——它安排一个任务在稍后的时间运行</li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">delayed_work</span></code> ——它安排一个任务在至少给定的时间间隔之后运行</li>
</ul>
<p>延迟工作项使用定时器在指定的时间间隔后运行。这种类型的工作项的调用方式与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span></code> 类似，但在函数名称中有 <strong>_delayed</strong>。</p>
<p>在使用工作项之前，必须对其进行初始化。有两种可以使用的宏类型，一种在同时声明和初始化工作项，另一种仅初始化工作项（声明必须单独进行）：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/workqueue.h&gt;</span><span class="cp"></span>

<span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">name</span> <span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">));</span>
<span class="n">DECLARE_DELAYED_WORK</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">));</span>

<span class="n">INIT_WORK</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">));</span>
<span class="n">INIT_DELAYED_WORK</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">));</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">DECLARE_WORK()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">DECLARE_DELAYED_WORK()</span></code> 声明并初始化工作项，而 <code class="xref c c-func docutils literal"><span class="pre">INIT_WORK()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">INIT_DELAYED_WORK()</span></code> 则初始化已经声明的工作项。</p>
<p>以下代码声明并初始化工作项：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/workqueue.h&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>
</pre></div>
</div>
<p>或者，如果我们想要单独初始化工作项：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span> <span class="n">work</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">my_work</span><span class="p">;</span>

<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>
</pre></div>
</div>
<p>一旦声明并初始化完成，我们就可以使用 <code class="xref c c-func docutils literal"><span class="pre">schedule_work()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">schedule_delayed_work()</span></code> 来安排任务：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">schedule_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="n">schedule_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">schedule_delayed_work()</span></code> 可以用于计划在给定延迟后执行工作项。延迟时间的单位是 jiffies。</p>
<p>工作项无法被屏蔽，但可以通过调用 <code class="xref c c-func docutils literal"><span class="pre">cancel_delayed_work_sync()</span></code> 或 <code class="xref c c-func docutils literal"><span class="pre">cancel_work_sync()</span></code> 来取消它们：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">cancel_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">cancel_delayed_work_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
</pre></div>
</div>
<p>这些调用只会停止工作项的后续执行。如果在调用时工作项已经在运行，它将继续运行。无论如何，当这些调用返回时，可以确保该任务不再运行。</p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">尽管这些函数也有非同步版本（例如 <code class="xref c c-func docutils literal"><span class="pre">cancel_work()</span></code>），但在执行清理工作时不要使用它们，否则可能会出现竞态条件。</p>
</div>
<p>我们可以通过调用 <code class="xref c c-func docutils literal"><span class="pre">flush_scheduled_work()</span></code> 来等待工作队列完成所有工作项的运行：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">flush_scheduled_work</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p>此函数是阻塞的，因此不能在中断上下文中使用。该函数将等待所有工作项完成。对于延迟工作项，在调用 <code class="xref c c-func docutils literal"><span class="pre">flush_scheduled_work()</span></code> 之前必须调用 <code class="xref c c-type docutils literal"><span class="pre">cancel_delayed_work</span></code>。</p>
<p>最后，以下函数可用于在特定处理器上调度工作项 (<code class="xref c c-func docutils literal"><span class="pre">schedule_delayed_work_on()</span></code>)，或在所有处理器上调度工作项 (<code class="xref c c-func docutils literal"><span class="pre">schedule_on_each_cpu()</span></code>)：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">schedule_delayed_work_on</span><span class="p">(</span><span class="kt">int</span> <span class="n">cpu</span><span class="p">,</span> <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">schedule_on_each_cpu</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">function</span><span class="p">)(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="p">));</span>
</pre></div>
</div>
<p>初始化和调度工作项的常用代码如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">my_work</span><span class="p">;</span>

<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>

<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">);</span>
</pre></div>
</div>
<p>等待工作项终止的方法如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">flush_scheduled_work</span><span class="p">();</span>
</pre></div>
</div>
<p>正如你所见，<em>my_work_handler</em> 函数接收任务项作为参数。为了能够访问模块的私有数据，可以使用 <code class="xref c c-func docutils literal"><span class="pre">container_of()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">my_device_data</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">work_struct</span> <span class="n">my_work</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
   <span class="k">struct</span> <span class="n">my_device_data</span> <span class="o">*</span> <span class="n">my_data</span><span class="p">;</span>

   <span class="n">my_data</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">my_device_data</span><span class="p">,</span>  <span class="n">my_work</span><span class="p">);</span>
   <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>使用上述函数调度工作项将在内核线程的上下文中运行处理程序，该线程称为 <em>events/x</em>，其中 x 是处理器编号。内核将为系统中每个处理器初始化一个内核线程（或工作池）：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>$ ps -e
PID TTY TIME CMD
<span class="m">1</span>?  <span class="m">00</span>:00:00 init
<span class="m">2</span> ?  <span class="m">00</span>:00:00 ksoftirqd / <span class="m">0</span>
<span class="m">3</span> ?  <span class="m">00</span>:00:00 events / <span class="m">0</span> &lt;--- 运行工作项的内核线程
<span class="m">4</span> ?  <span class="m">00</span>:00:00 khelper
<span class="m">5</span> ?  <span class="m">00</span>:00:00 kthread
<span class="m">7</span>?  <span class="m">00</span>:00:00 kblockd / <span class="m">0</span>
<span class="m">8</span>?  <span class="m">00</span>:00:00 kacpid
</pre></div>
</div>
<p>上述函数使用预定义的工作队列（称为 events），它们在 <em>events/x</em> 线程的上下文中运行，如上所述。尽管在大多数情况下这已经足够，但它是一个共享资源，在工作项处理程序中出现较长的延迟可能会导致其他队列使用者的延迟。因此，有一些函数用于创建额外的队列。</p>
<p>工作队列由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">workqueue_struct</span></code> 表示。可以使用以下函数创建一个新的工作队列：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="nf">create_workqueue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="nf">create_singlethread_workqueue</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">create_workqueue()</span></code> 为系统中的每个处理器使用一个线程，而 <code class="xref c c-func docutils literal"><span class="pre">create_singlethread_workqueue()</span></code> 则使用单个线程。</p>
<p>要将任务添加到新队列中，请使用 <code class="xref c c-func docutils literal"><span class="pre">queue_work()</span></code> 或 <code class="xref c c-func docutils literal"><span class="pre">queue_delayed_work()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span> <span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">queue_delayed_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">queue</span><span class="p">,</span>
                       <span class="k">struct</span> <span class="n">delayed_work</span> <span class="o">*</span><span class="n">work</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delay</span><span class="p">);</span>
</pre></div>
</div>
<p><code class="xref c c-func docutils literal"><span class="pre">queue_delayed_work()</span></code> 可以用于计划延迟执行的工作项。延迟的时间单位是 jiffies。</p>
<p>要等待所有工作项完成，请调用 <code class="xref c c-func docutils literal"><span class="pre">flush_workqueue()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">flush_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>
</pre></div>
</div>
<p>要销毁工作队列，请调用 <code class="xref c c-func docutils literal"><span class="pre">destroy_workqueue()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">destroy_workqueue</span><span class="p">(</span><span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">queue</span><span class="p">);</span>
</pre></div>
</div>
<p>下面的示例代码声明并初始化一个额外的工作队列，声明并初始化一个工作项，并将其添加到队列中：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">my_work_handler</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">my_work</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">my_workqueue</span><span class="p">;</span>

<span class="n">my_workqueue</span> <span class="o">=</span> <span class="n">create_singlethread_workqueue</span><span class="p">(</span><span class="s">&quot;my_workqueue&quot;</span><span class="p">);</span>
<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_work</span><span class="p">,</span> <span class="n">my_work_handler</span><span class="p">);</span>

<span class="n">queue_work</span><span class="p">(</span><span class="n">my_workqueue</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_work</span><span class="p">);</span>
</pre></div>
</div>
<p>下面的代码示例显示了如何移除工作队列：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">flush_workqueue</span><span class="p">(</span><span class="n">my_workqueue</span><span class="p">);</span>
<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">my_workqueue</span><span class="p">);</span>
</pre></div>
</div>
<p>使用这些函数计划的工作项将在一个名为 <em>my_workqueue</em> 的新内核线程的上下文中运行，该名称是传递给 <code class="xref c c-func docutils literal"><span class="pre">create_singlethread_workqueue()</span></code> 函数的参数。</p>
</div>
<div class="section" id="section-5">
<h2>内核线程<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h2>
<p>内核线程之所以出现，是为了在进程上下文中运行内核代码。内核线程是工作队列机制的基础。实质上，内核线程是一种只在内核态下运行，并且没有用户地址空间或其他用户属性的线程。</p>
<p>要创建内核线程，请使用函数 <code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kthread.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">kthread_create</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">threadfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
             <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">namefmt</span><span class="p">[],</span> <span class="p">...);</span>
</pre></div>
</div>
<ul class="simple">
<li><em>threadfn</em> 是将由内核线程运行的函数</li>
<li><em>data</em> 是要传递给函数的参数</li>
<li><em>namefmt</em> 表示内核线程的名称，如在 ps/top 中显示的那样；可以包含 %d、%s 等序列，它们将根据标准 printf 语法进行替换。</li>
</ul>
<p>例如，以下调用：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">kthread_create</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;%skthread%d&quot;</span><span class="p">,</span> <span class="s">&quot;my&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>将创建一个名为 mykthread0 的内核线程。</p>
<p>使用此函数创建的内核线程将被停止（处于 <em>TASK_INTERRUPTIBLE</em> 状态）。要启动内核线程，请调用 <code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/sched.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">wake_up_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
<p>或者，你可以使用 <code class="xref c c-func docutils literal"><span class="pre">kthread_run()</span></code> 来创建并运行内核线程：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">kthread_run</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">threadfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
             <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">namefmt</span><span class="p">[],</span> <span class="p">...);</span>
</pre></div>
</div>
<p>尽管在内核线程中运行的函数的编程限制更宽松，并且调度更接近用户空间的调度，但仍然有一些限制需要考虑。下面列出可以或不能从内核线程中执行的操作：</p>
<ul class="simple">
<li>不能访问用户地址空间（即使使用 copy_from_user、copy_to_user），因为内核线程没有用户地址空间</li>
<li>不能实现长时间运行的忙等待代码；如果内核没有启用抢占选项，那么该代码将在不会被其他内核线程或用户进程抢占的情况下运行，从而占用系统资源</li>
<li>可以调用阻塞操作</li>
<li>可以使用自旋锁，但如果锁的保持时间很长，建议使用互斥锁（mutex）</li>
</ul>
<p>内核线程的终止是在内核线程中运行的函数自愿进行的，通过调用 <code class="xref c c-func docutils literal"><span class="pre">do_exit()</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="n">fastcall</span> <span class="n">NORET_TYPE</span> <span class="kt">void</span> <span class="nf">do_exit</span><span class="p">(</span><span class="kt">long</span> <span class="n">code</span><span class="p">);</span>
</pre></div>
</div>
<p>大多数内核线程处理程序的实现都使用相同的模型，建议开始使用相同的模型以避免常见错误：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kthread.h&gt;</span><span class="cp"></span>

<span class="n">DECLARE_WAIT_QUEUE_HEAD</span><span class="p">(</span><span class="n">wq</span><span class="p">);</span>

<span class="c1">// 列出内核线程要处理的事件</span>
<span class="k">struct</span> <span class="n">list_head</span> <span class="n">events_list</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">spin_lock</span> <span class="n">events_lock</span><span class="p">;</span>


<span class="c1">// 描述要处理的事件的结构体</span>
<span class="k">struct</span> <span class="n">event</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lh</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">stop</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">event</span><span class="o">*</span> <span class="nf">get_next_event</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events_lock</span><span class="p">);</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">event</span><span class="o">*</span><span class="p">,</span> <span class="n">lh</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events_lock</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">e</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">my_thread_f</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">wait_event</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="p">(</span><span class="n">e</span> <span class="o">=</span> <span class="n">get_next_event</span><span class="p">()));</span>

        <span class="cm">/* 处理事件 */</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">-&gt;</span><span class="n">stop</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">do_exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 启动并运行内核线程 */</span>
<span class="n">kthread_run</span><span class="p">(</span><span class="n">my_thread_f</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;%skthread%d&quot;</span><span class="p">,</span> <span class="s">&quot;my&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>使用上述模板，可以使用以下代码触发内核线程请求：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">send_event</span><span class="p">(</span><span class="k">struct</span> <span class="n">event</span> <span class="o">*</span><span class="n">ev</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events_lock</span><span class="p">);</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ev</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">events_list</span><span class="p">);</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">events_lock</span><span class="p">);</span>
    <span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wq</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="section-6">
<h2>进一步阅读<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li><a class="reference external" href="http://lwn.net/images/pdf/LDD3/ch07.pdf">Linux 设备驱动程序（第 3 版），第 7 章：时间、延迟和延迟工作</a></li>
<li><a class="reference external" href="http://tldp.org/LDP/lkmpg/2.6/html/x1211.html">调度任务</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/23634/">驱动程序移植：工作队列接口</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/211279/">工作队列重新工作</a></li>
<li><a class="reference external" href="http://lwn.net/Articles/65178/">简化内核线程</a></li>
<li><a class="reference external" href="http://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html">不可靠的锁指南</a></li>
</ul>
</div>
<div class="section" id="section-7">
<h2>练习<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 延迟工作。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/延迟工作/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-7">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-8">
<h3>0. 简介<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p>使用 <a class="reference external" href="http://elixir.free-electrons.com/linux/latest/source">LXR</a>，找到以下符号的定义：</p>
<ul class="simple">
<li><code class="xref c c-macro docutils literal"><span class="pre">jiffies</span></code></li>
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">timer_list</span></code></li>
<li><code class="xref c c-func docutils literal"><span class="pre">spin_lock_bh</span> <span class="pre">function()</span></code></li>
</ul>
</div>
<div class="section" id="section-9">
<h3>1. 定时器<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h3>
<p>我们将创建一个简单的内核模块，在模块的内核加载后的第 <em>TIMER_TIMEOUT</em> 秒显示一条消息。</p>
<p>生成名为 <strong>1-2-timer</strong> 的任务骨架，并按照标有 <strong>TODO 1</strong> 的部分来完成任务。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <cite>pr_info(...)</cite>。消息将显示在控制台上，并且还可以使用 dmesg 查看。在调度定时器时，我们需要使用系统的（未来）绝对时间并且以滴答数表示。系统的当前时间（以滴答数表示）由 <code class="xref c c-type docutils literal"><span class="pre">jiffies</span></code> 给出。因此，我们需要将 <code class="docutils literal"><span class="pre">jiffies</span> <span class="pre">+</span> <span class="pre">TIMER_TIMEOUT</span> <span class="pre">*</span> <span class="pre">HZ</span></code> 作为绝对时间传递给定时器。</p>
</div>
<p>有关更多信息，请查阅 <a class="reference internal" href="#timer">定时器（Timer）</a> 部分。</p>
</div>
<div class="section" id="section-10">
<h3>2. 周期性定时器<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h3>
<p>修改前面的模块，使消息每隔 TIMER_TIMEOUT 秒显示一次。按照骨架中标有 <strong>TODO 2</strong> 的部分进行修改。</p>
</div>
<div class="section" id="ioctl">
<h3>3. 使用 ioctl 控制定时器<a class="headerlink" href="#ioctl" title="永久链接至标题">¶</a></h3>
<p>我们计划在从用户空间接收到 ioctl 调用后的第 N 秒显示有关当前进程的信息。N 作为 ioctl 参数传递。</p>
<p>生成名为 <strong>3-4-5-deferred</strong> 的任务骨架，并按照骨架中标有 <strong>TODO 1</strong> 的部分进行修改。</p>
<p>你需要实现以下 ioctl 操作。</p>
<ul class="simple">
<li>MY_IOCTL_TIMER_SET：安排定时器在接收到的秒数之后运行，该秒数作为 ioctl 的参数。该定时器并不周期运行。
* 此命令直接接收一个值，而不是指针。</li>
<li>MY_IOCTL_TIMER_CANCEL：停用定时器。</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">请查阅 <a class="reference internal" href="../so2/lab3-device-drivers.html#ioctl"><span class="std std-ref">ioctl</span></a> 了解如何访问 ioctl 参数。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">请查阅 <a class="reference internal" href="#timer">定时器（Timer）</a> 部分，了解如何启用/禁用定时器。在定时器处理程序中，显示当前进程标识符（PID）和进程执行镜像名称。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">你可以使用当前进程的 <em>pid</em> 和 <em>comm</em> 字段来查找当前进程标识符。有关详细信息，请查阅 <span class="xref std std-ref">proc-info</span>。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">要从用户空间使用设备驱动程序，你必须使用 mknod 程序创建设备字符文件 <em>/dev/deferred</em>。或者，你可以运行 <em>3-4-5-deferred/kernel/makenode</em> 脚本来执行此操作。</p>
</div>
<p>通过调用用户空间的 ioctl 操作来启用和禁用定时器。使用 <em>3-4-5-deferred/user/test</em> 程序来测试定时器的计划和取消。该程序在命令行上接收 ioctl 类型操作及其参数（如果有）。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>运行测试可执行文件时不带参数，以观察它接受的命令行选项。</p>
<p>要在 3 秒后启用定时器，请使用：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">test</span> <span class="n">s</span> <span class="mi">3</span>
</pre></div>
</div>
<p>要停用定时器，请使用：</p>
<div class="last highlight-c"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">test</span> <span class="n">c</span>
</pre></div>
</div>
</div>
<p>注意，定时器运行所基于的当前进程每次都是 PID 为 0 的 <em>swapper/0</em>。这个进程是空闲进程，当没有其他任务可运行时，它会一直运行。由于虚拟机非常轻量级且没有太多操作，大部分时间都会看到这个进程。</p>
</div>
<div class="section" id="section-11">
<h3>4. 阻塞操作<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h3>
<p>接下来，我们将尝试在定时器例程中执行阻塞操作，以查看会发生什么情况。为此，我们尝试在定时器处理例程中调用一个名为 alloc_io() 的模拟阻塞操作的函数。</p>
<p>修改模块，使得当接收到 <em>MY_IOCTL_TIMER_ALLOC</em> 命令时，定时器处理程序将调用 <code class="xref c c-func docutils literal"><span class="pre">alloc_io()</span></code>。按照骨架中标有 <strong>TODO 2</strong> 的部分进行修改。</p>
<p>使用相同的定时器。为了区分定时器处理程序中的功能，可以在设备结构中使用一个标志。使用代码骨架中定义的 <em>TIMER_TYPE_ALLOC</em> 和 <em>TIMER_TYPE_SET</em> 宏。对于初始化，请使用 TIMER_TYPE_NONE。</p>
<p>运行测试程序以验证任务 3 的功能。再次运行测试程序以调用 <code class="xref c c-func docutils literal"><span class="pre">alloc_io()</span></code>。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">该驱动程序会导致错误，因为在原子上下文（定时器处理程序运行在中断上下文中）中调用了阻塞函数。</p>
</div>
</div>
<div class="section" id="section-12">
<h3>5. 工作队列<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h3>
<p>我们将修改模块，以解决上一个任务中观察到的错误。</p>
<p>为此，让我们使用工作队列调用 <code class="xref c c-func docutils literal"><span class="pre">alloc_io()</span></code>。从定时器处理程序中安排一个工作项。在工作项处理程序中（在进程上下文中运行），调用 <code class="xref c c-func docutils literal"><span class="pre">alloc_io()</span></code>。按照骨架中标有 <strong>TODO 3</strong> 的部分进行修改，并在需要时查阅 <a class="reference internal" href="#section-4">工作队列</a> 部分。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">在设备结构中添加一个类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">work_struct</span></code> 的新字段。初始化此字段。使用 <code class="xref c c-func docutils literal"><span class="pre">schedule_work()</span></code> 从定时器处理程序中调度工作项。从 ioctl 后的 N 秒开始调度定时器处理程序。</p>
</div>
</div>
<div class="section" id="section-13">
<h3>6. 内核线程<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h3>
<p>实现一个简单的模块，创建一个显示当前进程标识符的内核线程。</p>
<p>生成名为 <strong>6-kthread</strong> 的任务骨架，并按照骨架中标有 <strong>TODO</strong> 的部分进行修改。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>创建和运行线程有两种选择：</p>
<ul class="simple">
<li>使用 <code class="xref c c-func docutils literal"><span class="pre">kthread_run()</span></code> 创建并运行线程</li>
<li>使用 <code class="xref c c-func docutils literal"><span class="pre">kthread_create()</span></code> 创建一个挂起的线程，然后使用 <code class="xref c c-func docutils literal"><span class="pre">wake_up_process()</span></code> 启动它。</li>
</ul>
<p class="last">如果需要，请查阅 <a class="reference internal" href="#section-5">内核线程</a> 部分。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p>将线程终止与模块卸载进行同步：</p>
<ul class="last simple">
<li>线程应在模块卸载时结束</li>
<li>在卸载之前，请等待内核线程退出</li>
</ul>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>为了同步，使用两个等待队列和两个标志。</p>
<p>请查阅 <span class="xref std std-ref">waiting-queues</span> 了解如何使用等待队列。</p>
<p class="last">使用原子变量作为标志。请查阅 <a class="reference internal" href="../so2/lab2-kernel-api.html#atomic-variables"><span class="std std-ref">原子变量</span></a>。</p>
</div>
</div>
<div class="section" id="section-14">
<h3>7. 定时器和进程之间共享的缓冲区<a class="headerlink" href="#section-14" title="永久链接至标题">¶</a></h3>
<p>该任务的目的是在延迟操作（定时器）和进程上下文之间进行同步。设置一个周期性定时器，监视进程列表。如果其中一个进程终止，将打印一条消息。可以动态添加进程到列表中。请使用 <em>3-4-5-deferred/kernel/</em> 骨架作为基础，并按照标有 <strong>TODO 4</strong> 的部分完成任务。</p>
<p>当接收到 <em>MY_IOCTL_TIMER_MON</em> 命令时，检查给定的进程是否存在，如果存在，则将其添加到监视的进程列表中，并在设置了类型后启用定时器。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">get_proc()</span></code> 检查 pid，找到关联的 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">task_struct</span></code>，并分配一个 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mon_proc</span></code> 项目，可以将其添加到列表中。请注意，该函数还会增加任务的引用计数，以便在任务终止时不会释放其内存。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">使用自旋锁保护对列表的访问。请注意，由于我们与定时器处理程序共享数据，因此除了获取锁之外，还需要禁用底半部处理程序。请查阅 <a href="#system-message-1"><span class="problematic" id="problematic-1">`锁定`_</span></a> 部分。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">每秒钟从定时器中收集信息。使用现有的定时器，并通过 TIMER_TYPE_ACCT 添加新的行为。要设置标志，请使用测试程序的 <em>t</em> 参数。</p>
</div>
<p>在定时器处理程序中，遍历监视的进程列表，并检查它们是否已终止。如果是，则打印进程名称和 PID，然后从列表中删除该进程，递减任务使用计数器，以便可以释放其内存，最后释放 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">mon_proc</span></code> 结构。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">struct</span> <span class="pre">task_struct()</span></code> 的 <em>state</em> 字段。如果任务的状态为 <em>TASK_DEAD</em>，则表示任务已终止。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">put_task_struct()</span></code> 递减任务使用计数器。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">确保使用自旋锁保护列表访问。简单的变体就足够了。</p>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">确保使用安全迭代器遍历列表，因为我们可能需要从列表中删除项目。</p>
</div>
<p>在检查完列表后，重新启用定时器。</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="interrupts.html" class="btn btn-neutral float-left" title="I/O 访问和中断" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="block_device_drivers.html" class="btn btn-neutral float-right" title="块设备驱动程序" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>