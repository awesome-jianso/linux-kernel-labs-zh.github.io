<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux Device Model &mdash; Linux 系统内核  documentation</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Kernel Profiling" href="kernel_profiling.html" />
    <link rel="prev" title="Memory mapping" href="memory_mapping.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">Operating Systems 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">Symmetric Multi-Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">Address Space</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">Memory Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">Filesystem Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">Network Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">Infrastructure</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">Kernel modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">Kernel API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">Character device drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O access and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">Deferred work</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">Block Device Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">File system drivers (Part 1)</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">File system drivers (Part 2)</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">Networking</a></li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">Kernel Development on ARM</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">Memory mapping</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linux Device Model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sysfs">sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#basic-structures-in-linux-devices">Basic Structures in Linux Devices</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-kobject-structure">The kobject structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#buses">Buses</a></li>
<li class="toctree-l3"><a class="reference internal" href="#devices">Devices</a></li>
<li class="toctree-l3"><a class="reference internal" href="#drivers">Drivers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hotplug">Hotplug</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#plug-and-play">Plug and Play</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pnp-bus">PNP bus</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pnp-operations">PNP operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-driver">Adding a driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#removing-a-driver">Removing a driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#adding-a-new-device">Adding a new device</a></li>
<li class="toctree-l3"><a class="reference internal" href="#removing-a-device">Removing a device</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exercises">Exercises</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#intro">0. Intro</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bus-implementation">1. Bus implementation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#add-type-and-version-device-attributes">2. Add type and version device attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#add-del-and-add-bus-attributes">3. Add del and add bus attributes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-the-bex-misc-driver">4. Register the bex misc driver</a></li>
<li class="toctree-l3"><a class="reference internal" href="#register-misc-device-in-the-bex-misc-probe-function">5. Register misc device in the bex_misc probe function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monitor-uevent-notifications">6. Monitor uevent notifications</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">Kernel Profiling</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Linux Device Model</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/device_model.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="linux-device-model">
<h1>Linux Device Model<a class="headerlink" href="#linux-device-model" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>Plug and Play is a technology that offers support for automatically adding and
removing devices to the system. This reduces conflicts with the resources they
use by automatically configuring them at system startup. In order to achieve
these goals, the following features are required:</p>
<blockquote>
<div><ul class="simple">
<li>Automatic detection of adding and removing devices in the system (the device
and its bus must notify the appropriate driver that a configuration change
occurred).</li>
<li>Resource management (addresses, irq lines, DMA channels, memory areas),
including resource allocation to devices and solving conflicts that may arise.</li>
<li>Devices must allow for software configuration (device resources - ports,
interrupts, DMA resources - must allow for driver assignment).</li>
<li>The drivers required for new devices must be loaded automatically by the
operating system when needed.</li>
<li>When the device and its bus allow, the system should be able to add or
remove the device from the system while it is running, without having to reboot
the system (hotplug).</li>
</ul>
</div></blockquote>
<p>For a system to support plug and play, the BIOS, operating system and the device
must support this technology. The device must have an ID that will provide to the
driver for identification, and the operating system must be able to identify
these configuration changes as they appear.</p>
<p>Plug and play devices are: PCI devices (network cards), USB (keyboard, mouse,
printer), etc.</p>
<p>Prior to version 2.6, the kernel did not have a unified model to get
information about devices.
For this reason, a model for Linux devices, Linux Device Model, was developed.</p>
<p>The primary purpose of this model is to maintain internal data structures that
reflect the state and structure of the system. Such information includes what
devices are in the system, how they are in terms of power management, what bus
they are attached to, what drivers they have, along with the structure of the
buses, devices, drivers in the system.</p>
<p>To maintain this information, the kernel uses the following entities:</p>
<blockquote>
<div><ul class="simple">
<li>device - a physical device that is attached to a bus</li>
<li>driver - a software entity that can be associated with a device and performs
operations with it</li>
<li>bus - a device to which other devices can be attached</li>
<li>class - a type of device that has a similar behavior; There is a class for
disks, partitions, serial ports, etc.</li>
<li>subsystem - a view on the structure of the system; Kernel subsystems
include devices (hierarchical view of all devices in the system), buses (bus
view of devices according to how they are attached to buses), classes, etc.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="sysfs">
<h2>sysfs<a class="headerlink" href="#sysfs" title="Permalink to this headline">¶</a></h2>
<p>The kernel provides a representation of its model in userspace through the
sysfs virtual file system. It is usually mounted in the /sys directory and
contains the following subdirectories:</p>
<blockquote>
<div><ul class="simple">
<li>block - all block devices available in the system (disks, partitions)</li>
<li>bus - types of bus to which physical devices are connected (pci, ide, usb)</li>
<li>class - drivers classes that are available in the system (net, sound, usb)</li>
<li>devices - the hierarchical structure of devices connected to the system</li>
<li>firmware - information from system firmware (ACPI)</li>
<li>fs - information about mounted file systems</li>
<li>kernel - kernel status information (logged-in users, hotplug)</li>
<li>module - the list of modules currently loaded</li>
<li>power - information related to the power management subsystem</li>
</ul>
</div></blockquote>
<p>As you can see, there is a correlation between the kernel data structures
within the described model and the subdirectories in the sysfs virtual file
system. Although this likeness may lead to confusion between the two concepts,
they are different. The kernel device model can work without the sysfs file
system, but the reciprocal is not true.</p>
<p>The sysfs information is found in files that contain an attribute. Some
standard attributes (represented by files or directories with the same name)
are as follows:</p>
<blockquote>
<div><ul class="simple">
<li>dev - Major and minor device identifier. It can be used to automatically
create entries in the /dev directory</li>
<li>device - a symbolic link to the directory containing devices; It can be
used to discover the hardware devices that provide a particular service (for
example, the ethi PCI card)</li>
<li>driver - a symbolic link to the driver directory (located in
/sys/bus/*/drivers )</li>
</ul>
</div></blockquote>
<p>Other attributes are available, depending on the bus and driver used.</p>
<img alt="../_images/ditaa-a5f399cb84561893770eb45ceeb827ce6d4a2336.png" src="../_images/ditaa-a5f399cb84561893770eb45ceeb827ce6d4a2336.png" />
</div>
<div class="section" id="basic-structures-in-linux-devices">
<h2>Basic Structures in Linux Devices<a class="headerlink" href="#basic-structures-in-linux-devices" title="Permalink to this headline">¶</a></h2>
<p>Linux Device Model provides a number of structures to ensure the interaction
between a hardware device and a device driver. The whole model is based on
kobject structure. Hierarchies are built using this structure and the following
structures are implemented:</p>
<blockquote>
<div><ul class="simple">
<li>struct bus_type</li>
<li>struct device</li>
<li>struct device_driver</li>
</ul>
</div></blockquote>
<img alt="../_images/ditaa-f7ee56960e76c3e80fcbe59fafa38c3d93eac261.png" src="../_images/ditaa-f7ee56960e76c3e80fcbe59fafa38c3d93eac261.png" />
<div class="section" id="the-kobject-structure">
<h3>The kobject structure<a class="headerlink" href="#the-kobject-structure" title="Permalink to this headline">¶</a></h3>
<p>A kobject structure does not perform a single function. This structure is
usually integrated into a larger one. A kobject structure actually
incorporates a set of features that will be offered to a higher abstraction
object in the Linux Device Model hierarchy.</p>
<p>For example, the cdev structure has the following definition:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">cdev</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kob</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
        <span class="kt">dev_t</span> <span class="n">dev</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that this structure includes a <code class="docutils literal"><span class="pre">kobject</span></code> structure field.</p>
<p>A kobject structure is defined as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kobject</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">entry</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span>          <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kset</span>             <span class="o">*</span><span class="n">kset</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobj_type</span>        <span class="o">*</span><span class="n">ktype</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sysfs_dirent</span>     <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kref</span>             <span class="n">kref</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_initialized</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_in_sysfs</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_add_uevent_sent</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_remove_uevent_sent</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">uevent_suppress</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As we can see, the kobject structures are in a hierarchy: an object has a
parent and holds a kset member, which contains objects on the same level.</p>
<p>Working with the structure involves initializing it with the
<code class="xref c c-func docutils literal"><span class="pre">kobject_init()</span></code> function.
Also in the initialization process it is necessary to set the name of the
<code class="docutils literal"><span class="pre">kobject</span></code> structure, which will appear in sysfs, using the
<code class="xref c c-func docutils literal"><span class="pre">kobject_set_name()</span></code> function.</p>
<p>Any operation on a kobject is done by incrementing its internal counter using
<code class="xref c c-func docutils literal"><span class="pre">kobject_get()</span></code>, or decrementing if it is no longer used using
<code class="xref c c-func docutils literal"><span class="pre">kobject_put()</span></code>.
Thus, a kobject object will only be released when its internal counter reaches 0.
A method of notifying this is needed so that the resources associated with the
device structure which included the kobject structure are released
(for example, cdev).
The method is called <code class="docutils literal"><span class="pre">release</span></code> and is associated with the object via the ktype
field (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kobj_type</span></code>).</p>
<p>The kobject structure is the basic structure of the Linux Device Model.
The structures in the higher levels of the model are <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code>,
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> and <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code>.</p>
</div>
<div class="section" id="buses">
<h3>Buses<a class="headerlink" href="#buses" title="Permalink to this headline">¶</a></h3>
<p>A bus is a communication channel between the processor and an input/output
device. To ensure that the model is generic, all input/output devices are
connected to the processor via such a bus (even if it can be a virtual one
without a physical hardware correspondent).</p>
<p>When adding a system bus, it will appear in the sysfs file system in
<code class="docutils literal"><span class="pre">/sys/bus</span></code>.
As with kobjects, buses can be organized into hierarchies and will be represented
in sysfs.</p>
<p>In the Linux Device Model, a bus is represented by the structure
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bus_type</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span>           <span class="o">*</span><span class="n">dev_root</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">bus_attribute</span>    <span class="o">*</span><span class="n">bus_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">drv_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>It can be noticed that a bus has a name, lists of default attributes, a number
of specific functions, and the driver's private data.
The <code class="docutils literal"><span class="pre">uevent</span></code> function (formerly <code class="docutils literal"><span class="pre">hotplug</span></code>) is used with hotplug devices.</p>
<p>Bus operations are the registration, the implementation of the operations
described in the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code> structure and the iteration and
inspection of the devices connected to the bus.</p>
<p>A bus is registered using <code class="xref c c-func docutils literal"><span class="pre">bus_register()</span></code>, and unregistered using
<code class="xref c c-func docutils literal"><span class="pre">bus_unregister()</span></code>.</p>
<p>Implementation example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp"></span>
<span class="cm">/* mybus.c */</span>

<span class="c1">//bus type</span>
<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">my_bus_type</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;mybus&quot;</span><span class="p">,</span>
  <span class="p">.</span><span class="n">match</span>  <span class="o">=</span> <span class="n">my_match</span><span class="p">,</span>
  <span class="p">.</span><span class="n">uevent</span> <span class="o">=</span> <span class="n">my_uevent</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="c1">//...</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
  <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_bus_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">);</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The functions that will normally be initialized within a bus_type structure are
<code class="docutils literal"><span class="pre">match</span></code> and <code class="docutils literal"><span class="pre">uevent</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/string.h&gt;</span><span class="cp"></span>
<span class="cm">/* mybus.c */</span>

<span class="c1">// match devices to drivers; just do a simple name test</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// respond to hotplug user events; add environment variable DEV_NAME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;DEV_NAME=%s&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">match</span></code> function is used when a new device or a new driver is added to the
bus. Its role is to make a comparison between the device ID and the driver ID.
The <code class="docutils literal"><span class="pre">uevent</span></code> function is called before generating a hotplug in user-space and
has the role of adding environment variables.</p>
<p>Other possible operations on a bus are iterating over the drivers or devices
attached to it.
Although we can not directly access them (lists of drivers and devices
being stored in the private data of the driver, the <code class="docutils literal"><span class="pre">subsys_private</span> <span class="pre">*p</span></code> field),
these can be iterated using the <code class="xref c c-macro docutils literal"><span class="pre">bus_for_each_dev</span></code> and
<code class="xref c c-macro docutils literal"><span class="pre">bus_for_each_drv</span></code> macros.</p>
<p>The Linux Device Model interface allows you to create attributes for the
associated objects. These attributes will have a corresponding file in the
bus subdirectory in sysfs. The attributes associated with a bus are
described by the bus_attribute structure :</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bus_attribute</span> <span class="p">{</span>
         <span class="k">struct</span> <span class="n">attribute</span>        <span class="n">attr</span><span class="p">;</span>
         <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
         <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Typically, an attribute is defined by the <code class="xref c c-macro docutils literal"><span class="pre">BUS_ATTR</span></code> macro.
The <code class="xref c c-func docutils literal"><span class="pre">bus_create_file()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">bus_remove_file()</span></code> functions can be
used to add/delete an attribute within the bus structure.</p>
<p>An example of defining an attribute for <code class="docutils literal"><span class="pre">my_bus</span></code> is shown below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mybus.c */</span>

<span class="cp">#define MY_BUS_DESCR     &quot;SO2 rules forever&quot;</span>

<span class="c1">// export a simple bus attribute</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">my_show_bus_descr</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MY_BUS_DESCR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * define attribute - attribute name is descr;</span>
<span class="cm"> * full name is bus_attr_descr;</span>
<span class="cm"> * sysfs entry should be /sys/bus/mybus/descr</span>
<span class="cm"> */</span>
<span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">my_show_bus_descr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// specify attribute - in module init function</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        <span class="c1">//...</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_descr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* handle error */</span>
        <span class="p">}</span>
        <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_bus_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">//...</span>
        <span class="n">bus_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_descr</span><span class="p">);</span>
        <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The bus is represented by both a <code class="docutils literal"><span class="pre">bus_type</span></code> object and a <code class="docutils literal"><span class="pre">device</span></code> object,
as we will see later (the bus is also a device).</p>
</div>
<div class="section" id="devices">
<h3>Devices<a class="headerlink" href="#devices" title="Permalink to this headline">¶</a></h3>
<p>Any device in the system has a <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> structure associated
with it.
Devices are discovered by different kernel methods (hotplug, device drivers,
system initialization) and are registered in the system. Each device present in
the kernel has an entry in <code class="docutils literal"><span class="pre">/sys/devices</span></code>.</p>
<p>At the lowest level, a device in Linux Device Model is represented by a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">struct</span> <span class="n">device</span>           <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span>          <span class="n">kobj</span><span class="p">;</span>

        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">init_name</span><span class="p">;</span> <span class="cm">/* initial name of the device */</span>
        <span class="c1">//...</span>
        <span class="k">struct</span> <span class="n">bus_type</span>         <span class="o">*</span><span class="n">bus</span><span class="p">;</span>       <span class="cm">/* type of bus device is on */</span>
        <span class="k">struct</span> <span class="n">device_driver</span>    <span class="o">*</span><span class="n">driver</span><span class="p">;</span>    <span class="cm">/* which driver has allocated this</span>
<span class="cm">                                             device */</span>
        <span class="c1">//...</span>
        <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Structure fields include the parent device that is usually a controller, the
associated <code class="docutils literal"><span class="pre">kobject</span></code>, the bus it is connected to, the device driver, and a
function called when the device counter reaches 0 (<code class="docutils literal"><span class="pre">release</span></code>).</p>
<p>As usual, we have the registration/unregistration functions
<code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">device_unregister()</span></code>.</p>
<p>To work with attributes, we have structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_attribute</span></code>,
the macro <code class="xref c c-macro docutils literal"><span class="pre">DEVICE_ATTR</span></code> for definition, and the functions
<code class="xref c c-func docutils literal"><span class="pre">device_create_file()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">device_remove_file()</span></code> for adding/removing
the attribute to/from the device.</p>
<p>One important thing to note is that the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> structure is
usually not used directly, but it is added to another structure. For example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// my device type</span>
<span class="k">struct</span> <span class="n">my_device</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Typically, a bus driver will export functions to add or remove such a
device, as shown below:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mybus.c */</span>

<span class="cm">/* BUS DEVICE (parent) */</span>

<span class="c1">// parent device release</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_bus_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">// parent device</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">my_bus_device</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">init_name</span>   <span class="o">=</span> <span class="s">&quot;mybus0&quot;</span><span class="p">,</span>
  <span class="p">.</span><span class="n">release</span>     <span class="o">=</span> <span class="n">my_bus_device_release</span>
<span class="p">};</span>

<span class="cm">/* DEVICE */</span>

<span class="cm">/*</span>
<span class="cm"> * as we are not using the reference count, we use a no-op</span>
<span class="cm"> * release function</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">my_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">mydev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">;</span>
  <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_bus_device</span><span class="p">;</span>
  <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_dev_release</span><span class="p">;</span>
  <span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">mydev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* export register/unregister device functions */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_register_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_unregister_device</span><span class="p">);</span>
</pre></div>
</div>
<p>As seen, the functions <code class="docutils literal"><span class="pre">my_register_device</span></code> and <code class="docutils literal"><span class="pre">my_unregister_device</span></code>, used
to add/remove a device to/from a bus, are defined in the same file where the
bus is defined. Device structures are not initialized; they will be initialized
when the devices are discovered by the system (by hotplug or direct registration
from driver) and the function <code class="docutils literal"><span class="pre">my_register_device</span></code> will be called to add a
device to the bus.</p>
<p>To use the bus defined above in the driver implementation, we must define a
structure of type <code class="docutils literal"><span class="pre">my_device</span></code>, initialize it and register it using the function
exported by the bus (<code class="docutils literal"><span class="pre">my_register_device</span></code>).</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mydriver.c */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_device</span> <span class="n">mydev</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">devname</span><span class="p">[</span><span class="n">NAME_SIZE</span><span class="p">];</span>
<span class="c1">//...</span>

<span class="c1">//register</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="n">sprintf</span><span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="s">&quot;mydev0&quot;</span><span class="p">);</span>
<span class="n">mydev</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">devname</span><span class="p">;</span>
<span class="n">mydev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mydriver</span><span class="p">;</span>
<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mydev</span><span class="p">);</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">my_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/*handle error */</span>
<span class="p">}</span>

<span class="c1">//..</span>

<span class="c1">//unregister</span>
<span class="n">my_unregister_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="drivers">
<h3>Drivers<a class="headerlink" href="#drivers" title="Permalink to this headline">¶</a></h3>
<p>Linux Device Model is used to allow simple association between system
devices and drivers. Drivers can export information independent of the physical
device.</p>
<p>In sysfs, driver information has no single subdirectory associated; They can be
found in the directory structure in different places: the loaded module is in
<code class="docutils literal"><span class="pre">/sys/module</span></code>, in <code class="docutils literal"><span class="pre">/sys/devices</span></code> you can find the driver associated with
each device, in <code class="docutils literal"><span class="pre">/sys/class</span></code> the drivers belonging to a class, in
<code class="docutils literal"><span class="pre">/sys/bus</span></code> the drivers associated to each bus.</p>
<p>A device driver is identified by the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device_driver</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">bus_type</span>         <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">driver_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">module</span>           <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
         <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>     <span class="cm">/* used for built-in modules */</span>

         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span>        <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span>       <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span>     <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span>      <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span>       <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Among the structure fields we find the name of the driver (appears in <code class="docutils literal"><span class="pre">sysfs</span></code>),
the bus with which the driver works, and functions called at various times in a
device's operation.</p>
<p>As before, we have the functions <code class="xref c c-func docutils literal"><span class="pre">driver_register()</span></code> and
<code class="xref c c-func docutils literal"><span class="pre">driver_unregister()</span></code> to register/unregister a driver.</p>
<p>To work with attributes, we have the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">driver_attribute</span></code> structure,
the macro <code class="xref c c-type docutils literal"><span class="pre">DRIVER_ATTR</span></code> for definition, and the functions
<code class="xref c c-func docutils literal"><span class="pre">driver_create_file()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">driver_remove_file()</span></code> functions for
adding the attribute to the device.</p>
<p>As with devices, the structure <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code> is usually
incorporated into another structure specific to a particular bus (PCI, USB, etc.):</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mybus.c */</span>

<span class="c1">// my driver type</span>
<span class="k">struct</span> <span class="n">my_driver</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_my_driver(drv) container_of(drv, struct my_driver, driver);</span>

<span class="kt">int</span> <span class="nf">my_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">;</span>
  <span class="n">err</span><span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* export register/unregister driver functions */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_register_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_unregister_driver</span><span class="p">);</span>
</pre></div>
</div>
<p>Driver registration/unregistration operations are exported for use in
other modules.</p>
<p>As for devices, the operations for drivers are defined when the bus is
initialized and they are exported to be used by drivers. When implementing a
driver that works with devices attached to the bus, we will call the functions
<code class="docutils literal"><span class="pre">my_register_driver</span></code> and <code class="docutils literal"><span class="pre">my_unregister_driver</span></code> to associate with the bus.</p>
<p>To use the functions (in the driver implementation), we must declare a structure
of type <code class="docutils literal"><span class="pre">my_driver</span></code>, initialize it and register using the function exported
by the bus.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mydriver.c */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_driver</span> <span class="n">mydriver</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
  <span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mydriver&quot;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
<span class="c1">//...</span>

<span class="c1">//register</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">my_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydriver</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/*handle error */</span>
<span class="p">}</span>
<span class="c1">//..</span>

<span class="c1">//unregister</span>
<span class="n">my_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydriver</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<p>A class is a high-level view of the Linux Device Model, which abstracts
implementation details. For example, there are drivers for SCSI and ATA
drivers, but all belong to the class of disks. Classes provide a grouping of
devices based on functionality, not how they are connected or how they work.
Classes have a correspondent in <code class="docutils literal"><span class="pre">/sys/classes</span></code>.</p>
<p>There are two main structures that describe the classes: <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code>
and <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code>.
The class structure describes a generic class, while the structure
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> describes a class associated with a device.
There are functions for initializing/deinitiating and adding attributes for each
of these, described in <code class="docutils literal"><span class="pre">include/linux/device.h</span></code>.</p>
<p>The advantage of using classes is that the <code class="docutils literal"><span class="pre">udev</span></code> program in userspace, which we
will discuss later, allows the automatic creation of devices in the <code class="docutils literal"><span class="pre">/dev</span></code>
directory based on class information.</p>
<p>For this reason, we will continue to present a small set of functions that work
with classes to simplify the use of the plug and play mechanism.</p>
<p>A generic class is described by structure class structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">class</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">module</span>           <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">kobject</span>          <span class="o">*</span><span class="n">dev_kobj</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">subsys_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">class_attribute</span>          <span class="o">*</span><span class="n">class_attrs</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">class_device_attribute</span>   <span class="o">*</span><span class="n">class_dev_attrs</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">device_attribute</span>         <span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>

         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">dev_uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
         <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">class_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">);</span>
         <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">dev_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="xref c c-func docutils literal"><span class="pre">class_register()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">class_unregister()</span></code> functions can be
used for initialization/deinitialization.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">my_class</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;myclass&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        <span class="c1">//...</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* handle error */</span>
        <span class="p">}</span>
        <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">//...</span>
        <span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">);</span>
        <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A class associated with a device is described by the <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code>
structure.
The <code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">device_destroy()</span></code> functions can be used
for initialization/deinitialization.
The <code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code> function initializes the <code class="docutils literal"><span class="pre">device</span></code> structure,
and assigns the generic <code class="docutils literal"><span class="pre">class</span></code> structure and the device received as a
parameter to it;
In addition, it will create an attribute of the class, <code class="docutils literal"><span class="pre">dev</span></code>, which contains
the minor and major of the device (<code class="docutils literal"><span class="pre">minor:major</span></code>).
Thus, udev utility in usermode can read the necessary data from this attribute
file to create a node in the <code class="docutils literal"><span class="pre">/dev</span></code> directory by calling <code class="docutils literal"><span class="pre">makenod</span></code>.</p>
<p>An example of initialization:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device</span><span class="o">*</span> <span class="n">my_classdev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

<span class="c1">//init class for device cdev.dev</span>
<span class="n">my_classdev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;myclass0&quot;</span><span class="p">);</span>

<span class="c1">//destroy class for device cdev.dev</span>
<span class="n">device_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">,</span> <span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<p>When a new device is discovered, a class and a node will be assigned to it and
a node will be created in the <code class="docutils literal"><span class="pre">/dev</span></code> directory.
For the example above, the node <code class="docutils literal"><span class="pre">/dev/myclass0</span></code> will be generated.</p>
</div>
<div class="section" id="hotplug">
<h3>Hotplug<a class="headerlink" href="#hotplug" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Hotplug</span></code> describes the mechanism for adding or removing a device from the
system while it is running without having to reboot the system.</p>
<p>A hotplug event is a notification from the kernel to the user-space when something
changes in the system configuration. These events are generated when creating
or removing a kobject from the kernel. Since these objects are the basis of the
Linux Device Model, being included in all structures (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code>,
<code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code>, <code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code>, <code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code>, etc.), a hotplug event
will be generated when any of these structures is created or removed (<code class="docutils literal"><span class="pre">uevent</span></code>).</p>
<p>When a device is discovered in the system, an event is generated.  Depending on
the point where it resides in Linux Device Model, the functions corresponding
to the event will be called (usually, the <code class="docutils literal"><span class="pre">uevent</span></code> function associated to the
bus or the class). Using these functions, the driver has the ability to set
system variables for the user-space.
The generated event then reaches the user-space. Here is the <code class="docutils literal"><span class="pre">udev</span></code>
utility that captures these events. There are configuration files for this
utility in the <code class="docutils literal"><span class="pre">/etc/udev/</span></code> directory. Different rules can be specified to
capture only certain events and perform certain actions, depending on the
system variables set in the kernel or in <code class="docutils literal"><span class="pre">uevent</span></code> functions.</p>
<p>An important consequence is that in this way the plug and play mechanism can be
achieved; with the help of <code class="docutils literal"><span class="pre">udev</span></code> and the classes (described above), entries
in the <code class="docutils literal"><span class="pre">/dev/</span></code> directories can be automatically created for devices, and using
<code class="docutils literal"><span class="pre">udev</span></code> drivers can be automatically loaded for a device.</p>
<p>Rules for <code class="docutils literal"><span class="pre">udev</span></code> are located <code class="docutils literal"><span class="pre">/etc/udev/rules.d</span></code>.
Any file that ends with <code class="docutils literal"><span class="pre">.rules</span></code> in this directory will be parsed when an
event occurs. For more details on how to write rules in these files see
<a class="reference external" href="http://www.reactivated.net/writing_udev_rules.html">Writing udev rules</a>.
For testing, there are utilities such as <code class="docutils literal"><span class="pre">udevmonitor</span></code>, <code class="docutils literal"><span class="pre">udevinfo</span></code> and
<code class="docutils literal"><span class="pre">udevtest</span></code>.</p>
<p>For a quick example, consider the situation where we want to automatically load
a driver for a device when an event occurs. We can create a new file
/etc/udev/rules.d/myrules.rules, we will have the following line:</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;pnp&quot;</span>, ATTRS<span class="o">{</span>id<span class="o">}==</span><span class="s2">&quot;PNP0400&quot;</span>, <span class="nv">RUN</span><span class="o">+=</span><span class="s2">&quot;/sbin/insmod /root/mydriver.ko&quot;</span>
</pre></div>
</div>
<p>This will choose from the events generated only those belonging to the <code class="docutils literal"><span class="pre">pnp</span></code>
subsystem (connected to <code class="docutils literal"><span class="pre">PNP</span></code> bus) and having an id attribute with the value
<code class="docutils literal"><span class="pre">PNP0400</span></code>.</p>
<p>When this rule will be found, the command specified under <code class="docutils literal"><span class="pre">RUN</span></code> will be
executed to insert the appropriate driver in the kernel.</p>
</div>
</div>
<div class="section" id="plug-and-play">
<h2>Plug and Play<a class="headerlink" href="#plug-and-play" title="Permalink to this headline">¶</a></h2>
<p>As noted above, in Linux Device Model all devices are connected by a bus, even if
it has a corresponding physical hardware or it is virtual.</p>
<p>The kernel already has implemented most buses using a <code class="docutils literal"><span class="pre">bus_type</span></code> structure
and functions to register/unregister drivers and devices.
To implement a driver, we must first determine the bus to which the supported
devices are connected and use the structures and functions exported by this bus.
The main buses are <code class="docutils literal"><span class="pre">PCI</span></code>, <code class="docutils literal"><span class="pre">USB</span></code>, <code class="docutils literal"><span class="pre">PNP</span></code>, <code class="docutils literal"><span class="pre">IDE</span></code>, <code class="docutils literal"><span class="pre">SCSI</span></code>, <code class="docutils literal"><span class="pre">platform</span></code>,
<code class="docutils literal"><span class="pre">ACPI</span></code>, etc.</p>
<div class="section" id="pnp-bus">
<h3>PNP bus<a class="headerlink" href="#pnp-bus" title="Permalink to this headline">¶</a></h3>
<p>The plug and play mechanism provides a means of detecting and setting the resources
for legacy driver that may not be configured or otherwise. All plug and play
drivers, protocols, services are based on Plug and Play level. It is responsible
for the exchange of information between drivers and protocols. The following
protocols are available:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal"><span class="pre">PNPBIOS</span></code> - used for systems such as serial and parallel ports</li>
<li><code class="docutils literal"><span class="pre">ISAPNP</span></code> - offers support for the ISA bus</li>
<li><code class="docutils literal"><span class="pre">ACPI</span></code> - offering, among other things, information about system-level devices</li>
</ul>
</div></blockquote>
<p>The kernel contains a bus, called <code class="docutils literal"><span class="pre">pnp_bus</span></code>, that is used for connecting by
many drivers.
The implementation and working with the bus follow the Linux Device Model and
is very similar to what we discussed above.</p>
<p>The main functions and structures exported by the bus, which can be used by
drivers, are:</p>
<blockquote>
<div><ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pnp_driver</span></code> - driver type associated to the bus</li>
<li><code class="xref c c-func docutils literal"><span class="pre">pnp_register_driver()</span></code> - function used to register a PNP driver in the system</li>
<li><code class="xref c c-func docutils literal"><span class="pre">pnp_unregister_driver()</span></code> - function used to unregister a PNP driver from the system</li>
</ul>
</div></blockquote>
<p>As noted in previous sections, the bus has a function called <code class="docutils literal"><span class="pre">match</span></code> used to
associate the devices with the appropriate drivers.
For example, when discovering a new device, a driver which meets the condition
given by the <code class="docutils literal"><span class="pre">match</span></code> function regarding to the new device. Usually, this
condition is a comparation of IDs (driver id and device id).
A common approach is using a static table in each driver, which holds information
about the devices supported by the driver, which will be used by the bus
when verifying the condition. For example, for a parallel port device we have
the table <code class="docutils literal"><span class="pre">parport_pc_pnp_tbl</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="cm">/* Standard LPT Printer Port */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0400&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="cm">/* ECP Printer Port */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0401&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">);</span>
</pre></div>
</div>
<p>Each driver declares and initializes a structure <code class="docutils literal"><span class="pre">pnp_driver</span></code>, such as
<code class="docutils literal"><span class="pre">parport_pc_pnp_driver</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">parport_pc_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">card_id</span><span class="p">,</span>
                                                     <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_pc_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span><span class="o">*</span> <span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">parport_pc_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">&quot;parport_pc&quot;</span><span class="p">,</span>
         <span class="p">.</span><span class="n">id_table</span>       <span class="o">=</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">,</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">parport_pc_pnp_probe</span><span class="p">,</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">parport_pc_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>We can notice that the structure has as fields a pointer to the table declared
above and two functions, which are called when a new device is detected and when
it is removed from the system.
As all the structures presented above, the driver must be registered to the
system:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parport_pc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_pc_pnp_driver</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* handle error */</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">parport_pc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_pc_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pnp-operations">
<h3>PNP operations<a class="headerlink" href="#pnp-operations" title="Permalink to this headline">¶</a></h3>
<p>So far we have discussed the Linux Device Model and its API. To
implement a plug and play driver, we must respect the Linux Device Model model.</p>
<p>Most often, adding a bus in the kernel is not necessary, as most of the existing
buses are already implemented (PCI, USB, etc.). Thus, we must first identify the
bus to which the device is attached.
In the examples below, we will consider that this bus is bus PNP and we will
use the structures and functions described above.</p>
<img alt="../_images/ditaa-4e1f9758808dba9e61bc0e48faf4365d377f9d32.png" src="../_images/ditaa-4e1f9758808dba9e61bc0e48faf4365d377f9d32.png" />
</div>
<div class="section" id="adding-a-driver">
<h3>Adding a driver<a class="headerlink" href="#adding-a-driver" title="Permalink to this headline">¶</a></h3>
<p>In addition to the usual operations, a driver must follow the Linux Device Model.
Thus, it will be registered in the system using the functions provided by
the bus for this purpose.
Usually, the bus provides a particular driver structure containing a
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code> structure, that the driver must initialize and
register using a function <code class="docutils literal"><span class="pre">*_register_driver</span></code>.
For example, for the <code class="docutils literal"><span class="pre">PNP</span></code> bus, the driver must declare and initialize a
structure of type <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pnp_driver</span></code> and register it using
<code class="docutils literal"><span class="pre">pnp_register_drvier</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">&quot;mydriver&quot;</span><span class="p">,</span>
         <span class="p">.</span><span class="n">id_table</span>       <span class="o">=</span> <span class="n">my_pnp_tbl</span><span class="p">,</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">my_pnp_probe</span><span class="p">,</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">my_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unlike legacy drivers, plug and play drivers don't register devices at
initialization in the init function (<code class="docutils literal"><span class="pre">my_init</span></code> in the example above) using
<code class="xref c c-func docutils literal"><span class="pre">register_device()</span></code>.</p>
<p>As described above, each bus has a <cite>match</cite> function which is called when a new
device is detected in the system to determine the associated driver.
Thus, there must be a way for each driver to export information about the
devices it supports, to allow this check to pass and have its functions further
called.
In the examples presented in this lab, the match function does a simple
comparison between the device name and the driver name. Most drivers use a table
containing information devices and store a pointer to this table in the
driver structure.
For example, a driver associated to a <code class="docutils literal"><span class="pre">PNP</span></code> bus defines a table of type
<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pnp_device_id</span></code> and initializes the field <code class="docutils literal"><span class="pre">id_table</span></code> from the
structure <code class="docutils literal"><span class="pre">pnp_driver</span> <span class="pre">my_pnp_driver</span></code> with a pointer to it:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">my_pnp_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="cm">/* Standard LPT Printer Port */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0400&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="cm">/* ECP Printer Port */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0401&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span><span class="n">my_pnp_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">id_table</span>       <span class="o">=</span> <span class="n">my_pnp_tbl</span><span class="p">,</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the example above, the driver supports multiple parallel port devices,
defined in the table <code class="docutils literal"><span class="pre">my_pnp_tbl</span></code>.  This information is used by the bus in
the <code class="docutils literal"><span class="pre">match_device</span></code> function.
When adding a driver, the bus driver will be associated to it and new entires
in <code class="docutils literal"><span class="pre">sysfs</span></code> will be created based on the driver name.
Then the bus <code class="docutils literal"><span class="pre">match</span></code> function will be called for every supported device,
to associate the driver with any connected device that it supports.</p>
</div>
<div class="section" id="removing-a-driver">
<h3>Removing a driver<a class="headerlink" href="#removing-a-driver" title="Permalink to this headline">¶</a></h3>
<p>To remove a driver from the kernel, in addition to operations required for a
legacy driver, we must unregister the <code class="docutils literal"><span class="pre">device_driver</span></code> structure.
For a driver associated with the <code class="docutils literal"><span class="pre">PNP</span></code> bus, we must unregister the <code class="docutils literal"><span class="pre">pnp_driver</span></code>
structure using the <code class="xref c c-func docutils literal"><span class="pre">pnp_unregister_driver()</span></code> function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unlike legacy drivers, plug and play drivers don't unregister devices in the
module unload function (<code class="docutils literal"><span class="pre">my_exit</span></code>). When a driver is removed, all the
references to it will be removed for all the devices it supports, and entries
from <code class="docutils literal"><span class="pre">sysfs</span></code> will also be removed.</p>
</div>
<div class="section" id="adding-a-new-device">
<h3>Adding a new device<a class="headerlink" href="#adding-a-new-device" title="Permalink to this headline">¶</a></h3>
<p>As we saw above, plug and play drivers do not register devices at initialization.
This operation will take place in the <code class="docutils literal"><span class="pre">probe</span></code> function, which is called when
a new device is detected. A device attached to the <code class="docutils literal"><span class="pre">PNP</span></code> bus will be added to
the system by the function <code class="docutils literal"><span class="pre">probe</span></code> from the <code class="docutils literal"><span class="pre">pnp_driver</span></code> structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">card_id</span><span class="p">,</span>
                                             <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">nr_ports</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>

        <span class="c1">//get irq &amp; ports</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pnp_port_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">iobase</span> <span class="o">=</span> <span class="n">pnp_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
        <span class="n">nr_ports</span> <span class="o">=</span> <span class="n">pnp_port_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="cm">/* register device dev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">my_pnp_probe</span><span class="p">,</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Upon detection of a device in the kernel (at boot or by the insertion of the
device through <code class="docutils literal"><span class="pre">hotplug</span></code>), an interrupt is generated and reaches the bus
driver.
The device is registered using the function <code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code> and it is
attached to the bus. A call to the user space will also be generated, and the
event can be treated by <code class="docutils literal"><span class="pre">udev</span></code>. Then, the list of drivers associated with the
bus is iterated and the <code class="docutils literal"><span class="pre">match</span></code> function is called for each of them.
The <code class="docutils literal"><span class="pre">match</span></code> function tries to find a driver for the new device. After a
suitable driver is found for the device, the <code class="docutils literal"><span class="pre">probe</span></code> function of the driver
is called. If the function ends successfully, the device is added to the driver's
list of devices and new entries are created in <code class="docutils literal"><span class="pre">sysfs</span></code> based on the device name.</p>
</div>
<div class="section" id="removing-a-device">
<h3>Removing a device<a class="headerlink" href="#removing-a-device" title="Permalink to this headline">¶</a></h3>
<p>As we saw above, the plug and play drivers don't unregister devices when the
driver is unloaded. This operation is done in the <code class="docutils literal"><span class="pre">remove</span></code> function, which
is called when a device is removed from the system.
In case of a device attached to the <code class="docutils literal"><span class="pre">PNP</span></code> bus, the unregister will be done
in the <code class="docutils literal"><span class="pre">remove</span></code> function specified in the <code class="docutils literal"><span class="pre">pnp_driver</span></code> structure:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
         <span class="cm">/* unregister device dev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">my_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>As seen in the example above, when the removal of a device is detected, the
<code class="docutils literal"><span class="pre">my_pnp_remove</span></code> function is called. A user-space call is also generated, which
can be detected by <code class="docutils literal"><span class="pre">udev</span></code>, and entries are removed from <code class="docutils literal"><span class="pre">sysfs</span></code>.</p>
</div>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">Important</p>
<p>To solve exercises, you need to perform these steps:</p>
<blockquote>
<div><ul class="simple">
<li>prepare skeletons from templates</li>
<li>build modules</li>
<li>copy modules to the VM</li>
<li>start the VM and test the module in the VM.</li>
</ul>
</div></blockquote>
<p>The current lab name is device_model. See the exercises for the task name.</p>
<p>The skeleton code is generated from full source examples located in
<code class="file docutils literal"><span class="pre">tools/labs/templates</span></code>. To solve the tasks, start by generating
the skeleton code for a complete lab:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>You can also generate the skeleton for a single task, using</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>Once the skeleton drivers are generated, build the source:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>Then, copy the modules and start the VM:</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>The modules are placed in /home/root/skels/device_model/&lt;task_name&gt;.</p>
<p>Alternatively, we can copy files via <strong class="command">scp</strong>, in order to avoid restarting the VM.
For additional details about connecting to the VM via the network, please check <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>.</p>
<p class="last">Review the <a class="reference internal" href="#exercises">Exercises</a> section for more detailed information.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Before starting the exercises or generating the skeletons, please run <strong>git pull</strong> inside the Linux repo,
to make sure you have the latest version of the exercises.</p>
<p>If you have local changes, the pull command will fail. Check for local changes using <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code>.
If you want to keep them, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code> before <code class="docutils literal"><span class="pre">pull</span></code> and <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code> after.
To discard the changes, run <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>.</p>
<p class="last">If you already generated the skeleton before <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> you will need to generate it again.</p>
</div>
<div class="section" id="intro">
<h3>0. Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h3>
<p>Find the definitions of the following symbols in the Linux kernel:</p>
<blockquote>
<div><ul class="simple">
<li>functions <code class="docutils literal"><span class="pre">dev_name</span></code>, <code class="docutils literal"><span class="pre">dev_set_name</span></code>.</li>
<li>functions <code class="docutils literal"><span class="pre">pnp_device_probe</span></code>, <code class="docutils literal"><span class="pre">pnp_bus_match</span></code>, <code class="docutils literal"><span class="pre">pnp_register_driver</span></code>
and the <code class="docutils literal"><span class="pre">pnp_bus_type</span></code> variable.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="bus-implementation">
<h3>1. Bus implementation<a class="headerlink" href="#bus-implementation" title="Permalink to this headline">¶</a></h3>
<p>Analyze the contents of the <code class="docutils literal"><span class="pre">bex.c</span></code>, a module that implements a bus
driver. Follow the comments marked with <strong>TODO 1</strong> and implement the missing
functionality: register the bus driver and add a new device named <code class="docutils literal"><span class="pre">root</span></code>
with type <code class="docutils literal"><span class="pre">none</span></code> and version 1.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">See <code class="xref c c-func docutils literal"><span class="pre">bex_add_dev()</span></code>.</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The register and unregister must be done using <code class="xref c c-func docutils literal"><span class="pre">bus_register()</span></code>
and <code class="xref c c-func docutils literal"><span class="pre">bus_unregister()</span></code>.</p>
</div>
<p>Load the module and verify that the bus is visible in <code class="docutils literal"><span class="pre">/sys/bus</span></code>. Verify
that the device is visible in <code class="docutils literal"><span class="pre">/sys/bus/bex/devices</span></code>.</p>
<p>Remove the module and notice that the <code class="docutils literal"><span class="pre">sysfs</span></code> entries are removed.</p>
</div>
<div class="section" id="add-type-and-version-device-attributes">
<h3>2. Add type and version device attributes<a class="headerlink" href="#add-type-and-version-device-attributes" title="Permalink to this headline">¶</a></h3>
<p>Add two read-only device attributes, <code class="docutils literal"><span class="pre">type</span></code> and <code class="docutils literal"><span class="pre">version</span></code>. Follow the
<strong>TODO 2</strong> markings.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>You will need to add the two attributes in the structure
<code class="docutils literal"><span class="pre">bex_dev_attrs</span></code>, as follows:</p>
<p class="last"><code class="docutils literal"><span class="pre">&amp;dev_attr_&lt;insert-attribute-type-here&gt;.attr,</span></code></p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>A possible implementation for the show function is the following:</p>
<div class="last highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">bex_device</span> <span class="o">*</span><span class="n">bex_dev</span> <span class="o">=</span> <span class="n">to_bex_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR_RO</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>Observe that two new attributes are visible in
/sys/bus/bex/devices/root. Check the contents of these attributes.</p>
</div>
<div class="section" id="add-del-and-add-bus-attributes">
<h3>3. Add del and add bus attributes<a class="headerlink" href="#add-del-and-add-bus-attributes" title="Permalink to this headline">¶</a></h3>
<p>Add two write-only bus attributes, <code class="docutils literal"><span class="pre">del</span></code> and <code class="docutils literal"><span class="pre">add</span></code>. del expects the name
of a device to delete, while add expects the name, type and version to
create a new device. Follow the <strong>TODO 3</strong> markings and review
<a class="reference internal" href="#buses">Buses</a>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use <code class="xref c c-func docutils literal"><span class="pre">sscanf()</span></code> to parse the input from sysfs and
<code class="xref c c-func docutils literal"><span class="pre">bex_del_dev()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">bex_add_dev()</span></code> to delete
and create a new device.</p>
</div>
<p>An example for the store function is the following:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">add_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">ret</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%31s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

  <span class="p">...</span>
<span class="p">}</span>
<span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">add_store</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The store functions should return <code class="docutils literal"><span class="pre">0</span></code> if
<code class="docutils literal"><span class="pre">bex_add_dev</span></code>/<code class="docutils literal"><span class="pre">bex_del_dev</span></code> fail and <code class="docutils literal"><span class="pre">count</span></code> otherwise.</p>
</div>
<p>Create a new device and observe that is visible in
<code class="docutils literal"><span class="pre">/sys/bus/devices</span></code>. Delete it and observe it disapears from <code class="docutils literal"><span class="pre">sysfs</span></code>.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p>Use echo to write into the bus attributes:</p>
<div class="last highlight-shell"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s2">&quot;name type 1&quot;</span> &gt; /sys/bus/bex/add
$ <span class="nb">echo</span> <span class="s2">&quot;name&quot;</span> &gt; /sys/bus/bex/del
</pre></div>
</div>
</div>
</div>
<div class="section" id="register-the-bex-misc-driver">
<h3>4. Register the bex misc driver<a class="headerlink" href="#register-the-bex-misc-driver" title="Permalink to this headline">¶</a></h3>
<p>Modify <strong>bex-misc.c</strong> so that it registers the driver with the bex
bus. Insert the <code class="docutils literal"><span class="pre">bmx_misc.ko</span></code> module and create a new bex device from
sysfs with the name &quot;test&quot;, type &quot;misc&quot;, version 2. Follow the <strong>TODO
4</strong> markings.</p>
<p>Observe that the driver is visible in <code class="docutils literal"><span class="pre">/sys/bus/bex/drivers</span></code>.</p>
<p>Why isn't the probe function called?</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Notice that the bus match function in <strong>bex.c</strong> is not
implemented.</p>
</div>
<p>Implement the bus matching function in <strong>bex.c</strong>. Follow the <strong>TODO 5</strong>
markings. Try again to create a new bex device and observe that this
time the <code class="docutils literal"><span class="pre">probe</span></code> function from the <code class="docutils literal"><span class="pre">bex_misc</span></code> driver is called.</p>
</div>
<div class="section" id="register-misc-device-in-the-bex-misc-probe-function">
<h3>5. Register misc device in the bex_misc probe function<a class="headerlink" href="#register-misc-device-in-the-bex-misc-probe-function" title="Permalink to this headline">¶</a></h3>
<p>Modify <strong>bex_misc.c</strong> to refuse probing if <code class="docutils literal"><span class="pre">version</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>. Also, register the
defined misc device in <code class="docutils literal"><span class="pre">bex_misc_probe</span></code> and deregister it in
<code class="docutils literal"><span class="pre">bex_misc_remove</span></code>. Follow the <strong>TODO 6</strong> markings.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">Use <code class="xref c c-func docutils literal"><span class="pre">misc_register()</span></code> and <code class="xref c c-func docutils literal"><span class="pre">misc_deregister()</span></code>.</p>
</div>
<p>Create a new device with the name &quot;test&quot;, type &quot;misc&quot; and version 2
and observe that the probe fails. Create a new device with the name
&quot;test2&quot;, type &quot;misc&quot; and version 1 and observe that the probe is
successful.</p>
<p>Inspect <code class="docutils literal"><span class="pre">/sys/bus/bex/devices/test2</span></code> and observe that we have a new
entry. Identify the major and minor for the misc device, create a
character device file and try to read and write from the misc device
buffer.</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">The major and minor should be visible in the dev attribute
of the misc device</p>
</div>
</div>
<div class="section" id="monitor-uevent-notifications">
<h3>6. Monitor uevent notifications<a class="headerlink" href="#monitor-uevent-notifications" title="Permalink to this headline">¶</a></h3>
<p>Use the <code class="docutils literal"><span class="pre">udevadm</span> <span class="pre">monitor</span></code> command and observe what happens when:</p>
<ul class="simple">
<li>the <code class="docutils literal"><span class="pre">bex.ko</span></code> and <code class="docutils literal"><span class="pre">bex_misc.ko</span></code> modules are inserted</li>
<li>a new device with the type &quot;type&quot; is created</li>
<li>a new device with the type &quot;misc&quot; and version 2 is created</li>
<li>a new device with the type &quot;misc&quot; and version 1 is created</li>
<li>all of the above are removed</li>
</ul>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="memory_mapping.html" class="btn btn-neutral float-left" title="Memory mapping" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kernel_profiling.html" class="btn btn-neutral float-right" title="Kernel Profiling" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>