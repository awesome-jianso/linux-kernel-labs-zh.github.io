<!DOCTYPE html>
<html class="writer-html4" lang="zh-CN" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Linux 设备模型 &mdash; Linux 系统内核文档</title><link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/asciinema-player.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
      <script>
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../',
              VERSION:'',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/asciinema-player.js"></script>
        <script src="../_static/translations.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="内核分析" href="kernel_profiling.html" />
    <link rel="prev" title="内存映射" href="memory_mapping.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Linux 系统内核
          </a>
              <div class="version">
                5.10.14
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../so2/index.html">Operating Systems 2</a></li>
</ul>
<p class="caption"><span class="caption-text">课程</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../lectures/intro.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/syscalls.html">系统调用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/processes.html">进程</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/interrupts.html">中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/smp.html">对称多处理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/address-space.html">地址空间</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/memory-management.html">内存管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/fs.html">文件系统管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/debugging.html">调试</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/networking.html">网络管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/arch.html">Architecture Layer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/virt.html">Virtualization</a></li>
</ul>
<p class="caption"><span class="caption-text">实验</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="infrastructure.html">基础设施</a></li>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_modules.html">内核模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="kernel_api.html">内核 API</a></li>
<li class="toctree-l1"><a class="reference internal" href="device_drivers.html">字符设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="interrupts.html">I/O 访问和中断</a></li>
<li class="toctree-l1"><a class="reference internal" href="deferred_work.html">延迟工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="block_device_drivers.html">块设备驱动程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part1.html">文件系统驱动程序（第一部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="filesystems_part2.html">文件系统驱动程序（第二部分）</a></li>
<li class="toctree-l1"><a class="reference internal" href="networking.html">网络</a></li>
<li class="toctree-l1"><a class="reference internal" href="arm_kernel_development.html">ARM 内核开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_mapping.html">内存映射</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Linux 设备模型</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#section-1">概述</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sysfs">sysfs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#linux-1">Linux 设备中的基本结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#kobject">kobject 结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-2">总线</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-3">设备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-4">驱动程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-5">类</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-6">热插拔</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-7">即插即用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pnp">PNP 总线</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pnp-1">PNP 操作</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-8">添加驱动程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-9">移除驱动程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-10">添加新设备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-11">移除设备</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#section-12">练习</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#section-13">0. 引言</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-14">1. 总线实现</a></li>
<li class="toctree-l3"><a class="reference internal" href="#section-15">2. 添加类型和版本设备属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#del-add">3. 添加 del 和 add 总线属性</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bex">4. 注册 bex 杂项驱动程序</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bex-misc-probe">5. 在 bex_misc probe 函数中注册杂项设备</a></li>
<li class="toctree-l3"><a class="reference internal" href="#uevent">6. 监视 uevent 通知</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="kernel_profiling.html">内核分析</a></li>
</ul>
<p class="caption"><span class="caption-text">有用信息</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../info/vm.html">虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/extra-vm.html">自定义虚拟机配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/contributing.html">对 Linux 内核实验室项目做贡献</a></li>
<li class="toctree-l1"><a class="reference internal" href="../info/chinese-localization-info.html">中文翻译介绍</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Linux 系统内核</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Linux 设备模型</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/labs/device_model.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="linux">
<h1>Linux 设备模型<a class="headerlink" href="#linux" title="永久链接至标题">¶</a></h1>
<div class="section" id="section-1">
<h2>概述<a class="headerlink" href="#section-1" title="永久链接至标题">¶</a></h2>
<p>即插即用（Plug and Play）是一种技术，它支持自动添加和移除设备到系统中。它通过在系统启动时自动配置设备，来减少与这些设备使用的资源相关的冲突。为了实现这些目标，需要具备以下特性：</p>
<blockquote>
<div><ul class="simple">
<li>自动检测系统中添加和移除的设备（设备及其总线必须通知相应的驱动程序发生了配置更改）。</li>
<li>资源管理（地址、中断线、DMA 通道、内存区域），包括为设备分配资源并解决可能出现的冲突。</li>
<li>设备必须允许进行软件配置（设备资源（端口、中断以及 DMA 资源）必须允许驱动程序进行分配）。</li>
<li>操作系统在需要时必须自动加载新设备所需的驱动程序。</li>
<li>如果设备及其总线允许的话，系统应能够在运行时添加或移除设备，而无需重新启动系统（热插拔）。</li>
</ul>
</div></blockquote>
<p>要支持即插即用，BIOS、操作系统和设备都必须支持这项技术。设备必须具有提供给驱动程序进行识别的 ID，并且操作系统必须能够在配置更改出现时进行识别。</p>
<p>即插即用设备包括：PCI 设备（网卡）、USB（键盘、鼠标、打印机）等。</p>
<p>在 2.6 版本之前，内核没有统一的模型用来获取有关设备的信息。因此，Linux 开发团队开发了 Linux 设备模型，用于 Linux 设备。</p>
<p>该模型的主要目的是维护反映系统状态和结构的内部数据结构。这些信息包括系统中有哪些设备、它们在电源管理方面的状态如何，连接到哪个总线，有哪些驱动程序，以及系统中总线、设备、驱动程序的结构。</p>
<p>为了维护这些信息，内核使用以下对象：</p>
<blockquote>
<div><ul class="simple">
<li>设备（device）——连接到总线的物理设备</li>
<li>驱动程序（driver）——可与设备关联并对其执行操作的软件对象</li>
<li>总线（bus）——可连接其他设备的设备</li>
<li>类别（class）——具有类似行为的设备类型；存在用于磁盘、分区、串口等的类别。</li>
<li>子系统（subsystem）——对系统结构的视图；内核子系统包括设备（对系统中所有设备的分层视图）、总线（根据设备连接到总线的方式的总线视图）、类别等。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="sysfs">
<h2>sysfs<a class="headerlink" href="#sysfs" title="永久链接至标题">¶</a></h2>
<p>内核通过 sysfs 虚拟文件系统在用户空间提供其模型的表示。它通常挂载在 /sys 目录下，包含以下子目录：</p>
<blockquote>
<div><ul class="simple">
<li>block——系统中所有可用的块设备（磁盘、分区）</li>
<li>bus——物理设备连接的总线类型（pci、ide、usb）</li>
<li>class——系统中可用的驱动程序类别（网络、声音、usb）</li>
<li>devices——连接到系统的设备的层次结构</li>
<li>firmware——来自系统固件（ACPI）的信息</li>
<li>fs——挂载的文件系统的信息</li>
<li>kernel——内核状态信息（已登录用户、热插拔）</li>
<li>module——当前加载的模块列表</li>
<li>power——与电源管理子系统相关的信息</li>
</ul>
</div></blockquote>
<p>可以看出，在 sysfs 虚拟文件系统中的子目录与之前所描述的模型中的内核数据结构之间存在关联。尽管这种相似性可能导致你对两个概念产生混淆，但它们是不同的。内核设备模型可以在没有 sysfs 文件系统的情况下工作，但反之则不成立。</p>
<p>sysfs 信息存储在包含属性的文件中。一些标准属性（由具有相同名称的文件或目录表示）如下：</p>
<blockquote>
<div><ul class="simple">
<li>dev——主设备号和次设备号。可用于自动创建 /dev 目录中的条目。</li>
<li>device——指向包含设备的目录的符号链接；可用于发现提供特定服务的硬件设备（例如 ethi PCI 卡）。</li>
<li>driver——指向驱动程序目录的符号链接（位于 /sys/bus/*/drivers 中）。</li>
</ul>
</div></blockquote>
<p>根据使用的总线和驱动程序，还有其他可用的属性。</p>
<img alt="../_images/ditaa-a5f399cb84561893770eb45ceeb827ce6d4a2336.png" src="../_images/ditaa-a5f399cb84561893770eb45ceeb827ce6d4a2336.png" />
</div>
<div class="section" id="linux-1">
<h2>Linux 设备中的基本结构<a class="headerlink" href="#linux-1" title="永久链接至标题">¶</a></h2>
<p>Linux 设备模型提供了一些结构，以确保硬件设备和设备驱动程序之间的交互。整个模型基于 kobject 结构构建层级，实现了以下结构：</p>
<blockquote>
<div><ul class="simple">
<li>struct bus_type</li>
<li>struct device</li>
<li>struct device_driver</li>
</ul>
</div></blockquote>
<img alt="../_images/ditaa-f7ee56960e76c3e80fcbe59fafa38c3d93eac261.png" src="../_images/ditaa-f7ee56960e76c3e80fcbe59fafa38c3d93eac261.png" />
<div class="section" id="kobject">
<h3>kobject 结构<a class="headerlink" href="#kobject" title="永久链接至标题">¶</a></h3>
<p>kobject 结构本身并不执行单一功能。通常，这个结构被整合到更大的结构中。kobject 结构实际上包含了一组功能，将提供给 Linux 设备模型层次结构中更高级别的抽象对象。</p>
<p>例如，cdev 结构具有以下定义：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">cdev</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kob</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
        <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
        <span class="kt">dev_t</span> <span class="n">dev</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>请注意，这个结构包含了一个 <code class="docutils literal"><span class="pre">kobject</span></code> 结构字段。</p>
<p>kobject 结构定义如下：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">kobject</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">entry</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span>          <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kset</span>             <span class="o">*</span><span class="n">kset</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobj_type</span>        <span class="o">*</span><span class="n">ktype</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">sysfs_dirent</span>     <span class="o">*</span><span class="n">sd</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kref</span>             <span class="n">kref</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_initialized</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_in_sysfs</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_add_uevent_sent</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">state_remove_uevent_sent</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nl">uevent_suppress</span><span class="p">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>可以看出，kobject 结构是有层次的：每一个对象都有一个父对象，并持有一个 kset 成员，其中包含相同级别的对象。</p>
<p>要想使用这个结构，你需要使用 <code class="xref c c-func docutils literal"><span class="pre">kobject_init()</span></code> 函数对其进行初始化。在初始化过程中，你需要使用 kobject_set_name 函数设置 <code class="docutils literal"><span class="pre">kobject</span></code> 结构的名称，该名称将显示在 sysfs 中。</p>
<p>对 kobject 的任何操作都是通过增加其内部计数器来完成的，这些操作使用 <code class="xref c c-func docutils literal"><span class="pre">kobject_get()</span></code> 函数来增加内部计数器，如果不再使用，则应使用 <code class="xref c c-func docutils literal"><span class="pre">kobject_put()</span></code> 函数进行减少。因此，只有当 kobject 对象的内部计数器达到 0 时，它才会被释放。我们需要一种用于通知的方法，以释放与包含 kobject 结构的设备结构（例如 cdev）相关联的资源。该方法是 <code class="docutils literal"><span class="pre">release</span></code>，其通过 ktype 字段 (<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">kobj_type</span></code> 类型) 与该对象关联。</p>
<p>kobject 结构是 Linux 设备模型的基本结构。模型中较高级别的结构包括 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code>, <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> 和 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code>。</p>
</div>
<div class="section" id="section-2">
<h3>总线<a class="headerlink" href="#section-2" title="永久链接至标题">¶</a></h3>
<p>总线是处理器与输入/输出设备之间的通信通道。为了确保模型能够通用，所有输入/输出设备都通过这样的总线连接到处理器（即使它可以是没有物理硬件对应的虚拟总线）。</p>
<p>在添加系统总线后，它将出现在 sysfs 文件系统的 <code class="docutils literal"><span class="pre">/sys/bus</span></code> 目录中。与 kobjects 一样，总线可以组织成层次结构，并在 sysfs 中表示。</p>
<p>在 Linux 设备模型中，总线由结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code> 表示：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bus_type</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">dev_name</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device</span>           <span class="o">*</span><span class="n">dev_root</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">bus_attribute</span>    <span class="o">*</span><span class="n">bus_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">driver_attribute</span> <span class="o">*</span><span class="n">drv_attrs</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">subsys_private</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">match</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">drv</span><span class="p">);</span>
        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="kt">int</span>             <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
        <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>可以注意到，总线具有名称、默认属性列表、一些特定函数和驱动程序的私有数据。 <code class="docutils literal"><span class="pre">uevent</span></code> 函数（以前称为 <code class="docutils literal"><span class="pre">hotplug</span></code>）用于热插拔设备。</p>
<p>总线操作包括注册、实现在结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code> 中描述的操作，以及迭代和检查连接到总线上的设备。</p>
<p>我们使用 <code class="xref c c-func docutils literal"><span class="pre">bus_register()</span></code> 函数进行总线注册，并使用 <code class="xref c c-func docutils literal"><span class="pre">bus_unregister()</span></code> 函数取消注册。</p>
<p>实现示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp"></span>
<span class="cm">/* mybus.c */</span>

<span class="c1">// 总线类型</span>
<span class="k">struct</span> <span class="n">bus_type</span> <span class="n">my_bus_type</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">name</span>   <span class="o">=</span> <span class="s">&quot;mybus&quot;</span><span class="p">,</span>
  <span class="p">.</span><span class="n">match</span>  <span class="o">=</span> <span class="n">my_match</span><span class="p">,</span>
  <span class="p">.</span><span class="n">uevent</span> <span class="o">=</span> <span class="n">my_uevent</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="c1">//...</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">bus_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
  <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_bus_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//...</span>
  <span class="n">bus_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">);</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>通常在 bus_type 结构中初始化的函数包括 <code class="docutils literal"><span class="pre">match</span></code> 和 <code class="docutils literal"><span class="pre">uevent</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/device.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;linux/string.h&gt;</span><span class="cp"></span>
<span class="cm">/* mybus.c */</span>

<span class="c1">// 将设备与驱动程序进行匹配；只需进行简单的名称测试</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_match</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span> <span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// 响应热插拔用户事件；添加环境变量 DEV_NAME</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">my_uevent</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">add_uevent_var</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;DEV_NAME=%s&quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">(</span><span class="n">dev</span><span class="p">));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">match</span></code> 函数在向总线添加新设备或新驱动程序时使用。其作用是比较设备 ID 和驱动程序 ID。 <code class="docutils literal"><span class="pre">uevent</span></code> 函数在生成用户空间的热插拔事件之前调用，其作用是添加环境变量。</p>
<p>总线上的其他操作可能包括遍历附加的驱动程序或设备。虽然我们无法直接访问它们（驱动程序和设备的列表存储在驱动程序的私有数据中，即 <code class="docutils literal"><span class="pre">subsys_private</span> <span class="pre">*p</span></code> 字段），但我们可以使用 <code class="xref c c-macro docutils literal"><span class="pre">bus_for_each_dev</span></code> 和 <code class="xref c c-macro docutils literal"><span class="pre">bus_for_each_drv</span></code> 宏来对其进行遍历。</p>
<p>你可以通过 Linux 设备模型接口为关联的对象创建属性。这些属性在 sysfs 中的 bus 子目录中具有相应的文件。与总线相关联的属性由 bus_attribute 结构描述。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">bus_attribute</span> <span class="p">{</span>
         <span class="k">struct</span> <span class="n">attribute</span>        <span class="n">attr</span><span class="p">;</span>
         <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">show</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
         <span class="kt">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">store</span><span class="p">)(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>通常，属性由宏 <code class="xref c c-macro docutils literal"><span class="pre">BUS_ATTR</span></code> 定义。我们可以使用函数 <code class="xref c c-func docutils literal"><span class="pre">bus_create_file()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">bus_remove_file()</span></code> 在总线结构中添加/删除属性。</p>
<p>下面是定义 <code class="docutils literal"><span class="pre">my_bus</span></code> 属性的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mybus.c */</span>

<span class="cp">#define MY_BUS_DESCR     &quot;SO2 永远统治&quot;</span>

<span class="c1">// 导出某个简单的总线属性</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">my_show_bus_descr</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bus</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">MY_BUS_DESCR</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 定义属性——属性名为 descr；</span>
<span class="cm"> * 全名为 bus_attr_descr；</span>
<span class="cm"> * sysfs 条目应为 /sys/bus/mybus/descr</span>
<span class="cm"> */</span>
<span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">descr</span><span class="p">,</span> <span class="mo">0444</span><span class="p">,</span> <span class="n">my_show_bus_descr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="c1">// 在模块初始化函数中指定属性</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_bus_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        <span class="c1">//...</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">bus_create_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_descr</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 处理错误 */</span>
        <span class="p">}</span>
        <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_bus_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">//...</span>
        <span class="n">bus_remove_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bus_attr_descr</span><span class="p">);</span>
        <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>总线由 <code class="docutils literal"><span class="pre">bus_type</span></code> 对象和 <code class="docutils literal"><span class="pre">device</span></code> 对象表示，我们稍后将进一步了解（总线也是一种设备）。</p>
</div>
<div class="section" id="section-3">
<h3>设备<a class="headerlink" href="#section-3" title="永久链接至标题">¶</a></h3>
<p>系统中的任何设备都与 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> 结构相关联。设备可以通过多种不同的内核方法（热插拔、设备驱动程序、系统初始化）被发现并注册到系统中。内核中的每个设备在 <code class="docutils literal"><span class="pre">/sys/devices</span></code> 目录下都有一个条目。</p>
<p>在 Linux 设备模型中，设备在最低级别上由 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> 结构表示：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="k">struct</span> <span class="n">device</span>           <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">device_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">kobject</span>          <span class="n">kobj</span><span class="p">;</span>

        <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">init_name</span><span class="p">;</span> <span class="cm">/* 设备的初始名称 */</span>
        <span class="c1">//...</span>
        <span class="k">struct</span> <span class="n">bus_type</span>         <span class="o">*</span><span class="n">bus</span><span class="p">;</span>       <span class="cm">/* 设备所在的总线类型 */</span>
        <span class="k">struct</span> <span class="n">device_driver</span>    <span class="o">*</span><span class="n">driver</span><span class="p">;</span>    <span class="cm">/* 分配该设备的驱动程序 */</span>
        <span class="c1">//...</span>
        <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>结构字段包括父设备（通常是控制器），相关的 <code class="docutils literal"><span class="pre">kobject</span></code>，设备连接的总线，设备驱动程序以及在设备计数器达到 0 时调用的函数 (<code class="docutils literal"><span class="pre">release</span></code>)。</p>
<p>像往常一样，我们有注册函数 <code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code> 和取消注册函数 <code class="xref c c-func docutils literal"><span class="pre">device_unregister()</span></code>。</p>
<p>要处理属性，我们有结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_attribute</span></code> 以及宏 <code class="xref c c-macro docutils literal"><span class="pre">DEVICE_ATTR</span></code> 用于定义属性，还有函数 <code class="xref c c-func docutils literal"><span class="pre">device_create_file()</span></code> 以及 <code class="xref c c-func docutils literal"><span class="pre">device_remove_file()</span></code> 用于将属性添加到设备或从设备中删除属性。</p>
<p>需要注意的是，我们通常不直接使用结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> ，而是将其添加到另一个结构体中。例如：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="c1">// 我的设备类型</span>
<span class="k">struct</span> <span class="n">my_device</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>通常，总线驱动程序会导出用于添加或移除此类设备的函数，如下所示：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mybus.c */</span>

<span class="cm">/* 总线设备（父设备）*/</span>

<span class="c1">// 父设备释放函数</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_bus_device_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">// 父设备</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">device</span> <span class="n">my_bus_device</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">init_name</span>   <span class="o">=</span> <span class="s">&quot;mybus0&quot;</span><span class="p">,</span>
  <span class="p">.</span><span class="n">release</span>     <span class="o">=</span> <span class="n">my_bus_device_release</span>
<span class="p">};</span>

<span class="cm">/* 设备 */</span>

<span class="cm">/*</span>
<span class="cm"> * 由于我们不使用引用计数，我们使用一个无操作的</span>
<span class="cm"> * 释放函数</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">my_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">my_register_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">mydev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">;</span>
  <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_bus_device</span><span class="p">;</span>
  <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">my_dev_release</span><span class="p">;</span>
  <span class="n">dev_set_name</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">mydev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">device_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_unregister_device</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_device</span> <span class="o">*</span><span class="n">mydev</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">device_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 导出注册/注销设备函数 */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_register_device</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_unregister_device</span><span class="p">);</span>
</pre></div>
</div>
<p>如上所示，函数 <code class="docutils literal"><span class="pre">my_register_device</span></code> 和 <code class="docutils literal"><span class="pre">my_unregister_device</span></code> 用于向总线添加/移除设备的操作，这两个函数与总线定义处于同一个文件。这里设备结构体没有被初始化；它们在系统通过热插拔或驱动程序的直接注册发现设备时，将被初始化，之后系统会调用函数 <code class="docutils literal"><span class="pre">my_register_device</span></code> 来将设备添加到总线中。</p>
<p>要在驱动程序实现中使用上述定义的总线，我们必须定义一个类型为 <code class="docutils literal"><span class="pre">my_device</span></code> 的结构体，对其进行初始化，并使用总线导出的函数 (<code class="docutils literal"><span class="pre">my_register_device</span></code>) 进行注册。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mydriver.c */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_device</span> <span class="n">mydev</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">devname</span><span class="p">[</span><span class="n">NAME_SIZE</span><span class="p">];</span>
<span class="c1">//...</span>

<span class="c1">// 注册设备</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

<span class="n">sprintf</span><span class="p">(</span><span class="n">devname</span><span class="p">,</span> <span class="s">&quot;mydev0&quot;</span><span class="p">);</span>
<span class="n">mydev</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">devname</span><span class="p">;</span>
<span class="n">mydev</span><span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mydriver</span><span class="p">;</span>
<span class="n">dev_set_drvdata</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mydev</span><span class="p">);</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">my_register_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>

<span class="c1">//..</span>

<span class="c1">// 注销设备</span>
<span class="n">my_unregister_device</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydev</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="section-4">
<h3>驱动程序<a class="headerlink" href="#section-4" title="永久链接至标题">¶</a></h3>
<p>借助 Linux 设备模型，我们可以实现系统设备和驱动程序之间的简单关联。驱动程序可以独立于物理设备导出信息。</p>
<p>在 sysfs 中，驱动程序信息没有单独的子目录与之关联；它们可以在不同位置的目录结构中找到：加载的模块在 <code class="docutils literal"><span class="pre">/sys/module</span></code> 中，在 <code class="docutils literal"><span class="pre">/sys/devices</span></code> 中可以找到与每个设备关联的驱动程序，在 <code class="docutils literal"><span class="pre">/sys/class</span></code> 中是属于某个类的驱动程序，在 <code class="docutils literal"><span class="pre">/sys/bus</span></code> 中是与每个总线关联的驱动程序。</p>
<p>系统通过结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code> 来区分设备驱动：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device_driver</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">bus_type</span>         <span class="o">*</span><span class="n">bus</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">driver_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">module</span>           <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
         <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">mod_name</span><span class="p">;</span>     <span class="cm">/* 用于内置模块 */</span>

         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">probe</span><span class="p">)</span>        <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">remove</span><span class="p">)</span>       <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)</span>     <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">suspend</span><span class="p">)</span>      <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">pm_message_t</span> <span class="n">state</span><span class="p">);</span>
         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">resume</span><span class="p">)</span>       <span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在本结构体字段中，我们可以找到驱动程序的名称（出现在 <code class="docutils literal"><span class="pre">sysfs</span></code> 中），与驱动程序一起工作的总线以及在设备操作的各个时刻调用的函数。</p>
<p>与之前一样，我们有函数 <code class="xref c c-func docutils literal"><span class="pre">driver_register()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">driver_unregister()</span></code> 来注册/注销驱动程序。</p>
<p>要处理属性，我们有结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">driver_attribute</span></code> 与宏 <code class="xref c c-type docutils literal"><span class="pre">DRIVER_ATTR</span></code> 用于定义属性，并且有函数 <code class="xref c c-func docutils literal"><span class="pre">driver_create_file()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">driver_remove_file()</span></code> 用于向设备添加属性。</p>
<p>与设备一样，结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code> 通常被纳入到特定总线 (PCI、USB 等) 对应的另一个结构体中：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mybus.c */</span>

<span class="c1">// 我的驱动类型</span>
<span class="k">struct</span> <span class="n">my_driver</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">module</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">device_driver</span> <span class="n">driver</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define to_my_driver(drv) container_of(drv, struct my_driver, driver);</span>

<span class="kt">int</span> <span class="nf">my_register_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

  <span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">.</span><span class="n">bus</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_bus_type</span><span class="p">;</span>
  <span class="n">err</span><span class="o">=</span> <span class="n">driver_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">my_unregister_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">my_driver</span> <span class="o">*</span><span class="n">driver</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">driver_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">driver</span><span class="o">-&gt;</span><span class="n">driver</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 导出注册/取消注册驱动程序函数 */</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_register_driver</span><span class="p">);</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">my_unregister_driver</span><span class="p">);</span>
</pre></div>
</div>
<p>驱动程序的注册/注销操作被导出以供其他模块使用。</p>
<p>与设备一样，驱动程序的操作在总线初始化时定义，并导出供驱动程序使用。当实现一个与连接到总线上的设备配合工作的驱动程序时，我们将调用函数 <code class="docutils literal"><span class="pre">my_register_driver</span></code> 和 <code class="docutils literal"><span class="pre">my_unregister_driver</span></code> 来与总线关联。</p>
<p>要使用这些函数（在驱动程序实现中），我们必须声明一个类型为 <code class="docutils literal"><span class="pre">my_driver</span></code> 的结构体，对其进行初始化，并使用总线导出的函数进行注册。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* mydriver.c */</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">my_driver</span> <span class="n">mydriver</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">.</span><span class="n">module</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
  <span class="p">.</span><span class="n">driver</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;mydriver&quot;</span><span class="p">,</span>
  <span class="p">},</span>
<span class="p">};</span>
<span class="c1">//...</span>

<span class="c1">// 注册</span>
<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">my_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydriver</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="cm">/* 处理错误 */</span>
<span class="p">}</span>
<span class="c1">//..</span>

<span class="c1">// 取消注册</span>
<span class="n">my_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mydriver</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="section-5">
<h3>类<a class="headerlink" href="#section-5" title="永久链接至标题">¶</a></h3>
<p>类是 Linux 设备模型的高层次视图，它抽象了实现细节。例如，SCSI 和 ATA 驱动程序虽然有所不同，但都属于磁盘类。类根据功能对设备进行分组，而不考虑它们的连接方式或工作原理。类在 <code class="docutils literal"><span class="pre">/sys/classes</span></code> 中有对应的表示。</p>
<p>主要有两个结构用来描述类，分别是 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code> 和 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code>。<code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code> 结构描述了通用类，而结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> 则描述了与设备有关联的类。对于每种结构体，都有用于初始化/反初始化和添加属性的函数，这些函数在 <code class="docutils literal"><span class="pre">include/linux/device.h</span></code> 中有描述。</p>
<p>使用类的优势在于，我们可以借助用户空间中的 <code class="docutils literal"><span class="pre">udev</span></code> 程序（我们稍后将讨论），根据类信息自动在 <code class="docutils literal"><span class="pre">/dev</span></code> 目录中创建设备。</p>
<p>因此，我们将继续介绍一小组函数，这些函数与类一起使用以简化即插即用机制。</p>
<p>通用类由结构体 class 描述：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">class</span> <span class="p">{</span>
         <span class="k">const</span> <span class="kt">char</span>              <span class="o">*</span><span class="n">name</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">module</span>           <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">kobject</span>          <span class="o">*</span><span class="n">dev_kobj</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">subsys_private</span>   <span class="o">*</span><span class="n">p</span><span class="p">;</span>

         <span class="k">struct</span> <span class="n">class_attribute</span>          <span class="o">*</span><span class="n">class_attrs</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">class_device_attribute</span>   <span class="o">*</span><span class="n">class_dev_attrs</span><span class="p">;</span>
         <span class="k">struct</span> <span class="n">device_attribute</span>         <span class="o">*</span><span class="n">dev_attrs</span><span class="p">;</span>

         <span class="kt">int</span>     <span class="p">(</span><span class="o">*</span><span class="n">dev_uevent</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobj_uevent_env</span> <span class="o">*</span><span class="n">env</span><span class="p">);</span>
         <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">class_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">class</span> <span class="o">*</span><span class="n">class</span><span class="p">);</span>
         <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">dev_release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>你可以使用 <code class="xref c c-func docutils literal"><span class="pre">class_register()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">class_unregister()</span></code> 函数对类进行初始化/反初始化。</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">class</span> <span class="n">my_class</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;myclass&quot;</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
        <span class="c1">//...</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">class_register</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 处理错误 */</span>
        <span class="p">}</span>
        <span class="c1">//...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="c1">//...</span>
        <span class="n">class_unregister</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">);</span>
        <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>与设备关联的类由结构体 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code> 描述。函数 <code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">device_destroy()</span></code> 负责初始化/反初始化。函数 <code class="xref c c-func docutils literal"><span class="pre">device_create()</span></code> 初始化 <code class="docutils literal"><span class="pre">device</span></code> 结构体，并将通用的 <code class="docutils literal"><span class="pre">class</span></code> 结构体和作为参数接收到的设备分配给它；此外，它还将创建类的属性 <code class="docutils literal"><span class="pre">dev</span></code>，其中包含设备的次设备号和主设备号 (<code class="docutils literal"><span class="pre">minor:major</span></code>)。因此，用户态的 udev 实用程序可以从该属性文件中读取所需的数据，通过调用 <code class="docutils literal"><span class="pre">mknod</span></code> 在 <code class="docutils literal"><span class="pre">/dev</span></code> 目录中创建一个节点。</p>
<p>以下是初始化的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">device</span><span class="o">*</span> <span class="n">my_classdev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">device</span> <span class="n">dev</span><span class="p">;</span>

<span class="c1">// 为设备 cdev.dev 初始化类</span>
<span class="n">my_classdev</span> <span class="o">=</span> <span class="n">device_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="s">&quot;myclass0&quot;</span><span class="p">);</span>

<span class="c1">// 销毁设备 cdev.dev 的类</span>
<span class="n">device_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_class</span><span class="p">,</span> <span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">);</span>
</pre></div>
</div>
<p>当发现新设备时，将为其分配一个类和节点，并在 <code class="docutils literal"><span class="pre">/dev</span></code> 目录中创建一个节点。对于上面的示例，将生成节点 <code class="docutils literal"><span class="pre">/dev/myclass0</span></code>。</p>
</div>
<div class="section" id="section-6">
<h3>热插拔<a class="headerlink" href="#section-6" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">热插拔</span></code> 描述了在系统运行时添加或移除设备而无需重新启动系统的机制。</p>
<p>热插拔事件是内核向用户空间发送的通知，用于指示系统配置发生了变化。这些事件在从内核创建或删除 kobject 时生成。由于这些对象是 Linux 设备模型的基础，包含在所有结构体中 (<code class="docutils literal"><span class="pre">struct</span> <span class="pre">bus_type</span></code>, <code class="docutils literal"><span class="pre">struct</span> <span class="pre">device</span></code>, <code class="docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code> 以及 <code class="docutils literal"><span class="pre">struct</span> <span class="pre">class</span></code> 等)，当创建或删除任何这些结构体时，都会生成热插拔事件 (<code class="docutils literal"><span class="pre">uevent</span></code>)。</p>
<p>当在系统中发现设备时，将生成事件。根据设备在 Linux 设备模型中所处的位置，将调用相应的事件函数（通常是与总线或类关联的 <code class="docutils literal"><span class="pre">uevent</span></code> 函数）。借助这些函数，驱动程序可以为用户空间设置系统变量。生成的事件然后到达用户空间。在这里 <code class="docutils literal"><span class="pre">udev</span></code> 程序会捕获这些事件。在 <code class="docutils literal"><span class="pre">/etc/udev/</span></code> 目录中有针对该程序的配置文件。可以指定不同的规则来捕获特定事件并执行特定操作，这取决于内核或 <code class="docutils literal"><span class="pre">uevent</span></code> 函数中设置的系统变量。</p>
<p>通过这种方式，我们可以实现即插即用的机制。借助于 <code class="docutils literal"><span class="pre">udev</span></code> 和上述的类，可以自动为设备在 <code class="docutils literal"><span class="pre">/dev/</span></code> 目录中创建条目，并且使用 <code class="docutils literal"><span class="pre">udev</span></code> 可以自动为设备加载驱动程序。</p>
<p>关于 <code class="docutils literal"><span class="pre">udev</span></code> 的规则位于 <code class="docutils literal"><span class="pre">/etc/udev/rules.d</span></code> 目录下。当事件发生时，该目录中以 <code class="docutils literal"><span class="pre">.rules</span></code> 结尾的任何文件都将被解析。有关如何在这些文件中编写规则的详细信息，请参阅 <a class="reference external" href="http://www.reactivated.net/writing_udev_rules.html">编写 udev 规则</a>。用于测试的程序包括 <code class="docutils literal"><span class="pre">udevmonitor</span></code>, <code class="docutils literal"><span class="pre">udevinfo</span></code> 和 <code class="docutils literal"><span class="pre">udevtest</span></code>。</p>
<p>举个简单示例，假设我们希望在事件发生时自动加载设备的驱动程序。我们可以创建名为 <code class="docutils literal"><span class="pre">/etc/udev/rules.d/myrules.rules</span></code> 的新文件，其中包含以下内容：</p>
<div class="highlight-bash"><div class="highlight"><pre><span></span><span class="nv">SUBSYSTEM</span><span class="o">==</span><span class="s2">&quot;pnp&quot;</span>, ATTRS<span class="o">{</span>id<span class="o">}==</span><span class="s2">&quot;PNP0400&quot;</span>, <span class="nv">RUN</span><span class="o">+=</span><span class="s2">&quot;/sbin/insmod /root/mydriver.ko&quot;</span>
</pre></div>
</div>
<p>这将仅选择属于 <code class="docutils literal"><span class="pre">pnp</span></code> 子系统（连接到 <code class="docutils literal"><span class="pre">PNP</span></code> 总线）且具有值为 <code class="docutils literal"><span class="pre">PNP0400</span></code> 的 id 属性的生成事件。</p>
<p>当找到这个规则时，将执行在 <code class="docutils literal"><span class="pre">RUN</span></code> 下指定的命令，将适当的驱动程序插入内核中。</p>
</div>
</div>
<div class="section" id="section-7">
<h2>即插即用<a class="headerlink" href="#section-7" title="永久链接至标题">¶</a></h2>
<p>如上所述，在 Linux 设备模型中，所有设备都通过总线连接，不管总线具有相应的物理硬件或者仅仅是虚拟设备。</p>
<p>内核已经使用 <code class="docutils literal"><span class="pre">bus_type</span></code> 结构和用于注册/取消注册驱动程序与设备的函数实现了大多数总线。要实现一个驱动程序，我们必须首先确定其所支持的设备连接的总线，并使用该总线导出的结构和函数。主要的总线包括 <code class="docutils literal"><span class="pre">PCI</span></code>, <code class="docutils literal"><span class="pre">USB</span></code>, <code class="docutils literal"><span class="pre">PNP</span></code>, <code class="docutils literal"><span class="pre">IDE</span></code>, <code class="docutils literal"><span class="pre">SCSI</span></code>, <code class="docutils literal"><span class="pre">platform</span></code> 以及 <code class="docutils literal"><span class="pre">ACPI</span></code> 等等。</p>
<div class="section" id="pnp">
<h3>PNP 总线<a class="headerlink" href="#pnp" title="永久链接至标题">¶</a></h3>
<p>即插即用机制提供了一种检测和设置未配置的传统驱动程序之类的资源的手段。所有的即插即用驱动程序、协议和服务都基于即插即用级别。它负责在驱动程序和协议之间进行信息交换。以下协议可用：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">PNPBIOS</span></code> ——用于串行和并行端口等系统</li>
<li><code class="docutils literal"><span class="pre">ISAPNP</span></code> ——提供对 ISA 总线的支持</li>
<li><code class="docutils literal"><span class="pre">ACPI</span></code> ——提供了关于系统级设备的信息等</li>
</ul>
<p>内核包含一个名为 <code class="docutils literal"><span class="pre">pnp_bus</span></code> 的总线，用于连接许多驱动程序。该总线的实现和工作遵循 Linux 设备模型，与我们上面讨论的内容非常相似。</p>
<p>由该总线导出的可以供驱动程序使用的函数和结构，主要包括：</p>
<ul class="simple">
<li><code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pnp_driver</span></code>——与总线关联的驱动程序类型</li>
<li><code class="xref c c-func docutils literal"><span class="pre">pnp_register_driver()</span></code>——用于在系统中注册 PNP 驱动程序的函数</li>
<li><code class="xref c c-func docutils literal"><span class="pre">pnp_unregister_driver()</span></code>——用于从系统中取消注册 PNP 驱动程序的函数</li>
</ul>
<p>前面的小节中我们提到，总线具有一个名为 <code class="docutils literal"><span class="pre">match</span></code> 的函数，用于将设备与适当的驱动程序关联起来。例如，当发现新设备时，符合 <code class="docutils literal"><span class="pre">match</span></code> 函数所给条件的驱动程序会与新设备相关。通常，这个条件是对 ID（驱动程序 ID 和设备 ID）进行比较。常见的方法是在每个驱动程序中使用一个静态表，该表包含驱动程序支持的设备的信息，总线在验证时将使用该表。例如，对于并行端口设备，我们有表格 <code class="docutils literal"><span class="pre">parport_pc_pnp_tbl</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="cm">/* 标准 LPT 打印机端口 */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0400&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="cm">/* ECP 打印机端口 */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0401&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">);</span>
</pre></div>
</div>
<p>每个驱动程序声明并初始化一个 <code class="docutils literal"><span class="pre">pnp_driver</span></code> 结构，例如 <code class="docutils literal"><span class="pre">parport_pc_pnp_driver</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">parport_pc_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">card_id</span><span class="p">,</span>
                                                     <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">parport_pc_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span><span class="o">*</span> <span class="n">dev</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">parport_pc_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">&quot;parport_pc&quot;</span><span class="p">,</span>
         <span class="p">.</span><span class="n">id_table</span>       <span class="o">=</span> <span class="n">parport_pc_pnp_tbl</span><span class="p">,</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">parport_pc_pnp_probe</span><span class="p">,</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">parport_pc_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>我们可以注意到，该结构的字段包括对上述表格的指针和两个函数，系统在检测到新设备以及在设备从系统中移除时调用这些函数。与上面介绍的所有结构一样，驱动程序必须向系统注册：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">parport_pc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_pc_pnp_driver</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="cm">/* 处理错误 */</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">parport_pc_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parport_pc_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pnp-1">
<h3>PNP 操作<a class="headerlink" href="#pnp-1" title="永久链接至标题">¶</a></h3>
<p>到目前为止，我们已经讨论了 Linux 设备模型及其 API。要实现即插即用驱动程序，我们必须遵循 Linux 设备模型。</p>
<p>通常情况下，我们不需要在内核中添加新的总线，因为大多数现有的总线已经实现了（如 PCI、USB 等）。因此，我们首先必须确定设备连接的总线。在下面的示例中，我们将假设该总线为 PNP 总线，并使用上述描述的结构和函数。</p>
<img alt="../_images/ditaa-4e1f9758808dba9e61bc0e48faf4365d377f9d32.png" src="../_images/ditaa-4e1f9758808dba9e61bc0e48faf4365d377f9d32.png" />
</div>
<div class="section" id="section-8">
<h3>添加驱动程序<a class="headerlink" href="#section-8" title="永久链接至标题">¶</a></h3>
<p>除了常规操作外，驱动程序必须遵循 Linux 设备模型。因此，它将使用总线提供的函数在系统中注册。通常，总线提供一个特定的驱动程序结构，其中包含 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">device_driver</span></code> 结构，驱动程序必须初始化并使用 <code class="docutils literal"><span class="pre">*_register_driver</span></code> 函数进行注册。例如，对于 <code class="docutils literal"><span class="pre">PNP</span></code> 总线，驱动程序必须声明并初始化一个类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pnp_driver</span></code> 的结构，并使用 <code class="docutils literal"><span class="pre">pnp_register_driver</span></code> 进行注册：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="p">.</span><span class="n">name</span>           <span class="o">=</span> <span class="s">&quot;mydriver&quot;</span><span class="p">,</span>
         <span class="p">.</span><span class="n">id_table</span>       <span class="o">=</span> <span class="n">my_pnp_tbl</span><span class="p">,</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">my_pnp_probe</span><span class="p">,</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">my_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">my_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">pnp_register_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>与传统驱动程序不同，即插即用驱动程序不会在初始化函数（上面示例中的 <code class="docutils literal"><span class="pre">my_init</span></code>）中使用 <code class="xref c c-func docutils literal"><span class="pre">register_device()</span></code> 注册设备。</p>
<p>如上所述，每个总线都有一个 <cite>match</cite> 函数，当系统检测到新设备时会调用该函数，以确定关联的驱动程序。因此，每个驱动程序需要能够导出其支持的设备的信息，以允许此检查通过并进一步调用其函数。在本实验中介绍的示例中，匹配函数执行设备名称和驱动程序名称之间的简单比较。大多数驱动程序使用包含设备信息的表，并将指向该表的指针存储在驱动程序结构中。例如，与 <code class="docutils literal"><span class="pre">PNP</span></code> 总线关联的驱动程序定义了类型为 <code class="xref c c-type docutils literal"><span class="pre">struct</span> <span class="pre">pnp_device_id</span></code> 的表，并使用指向它的指针初始化结构体 <code class="docutils literal"><span class="pre">pnp_driver</span> <span class="pre">my_pnp_driver</span></code> 中的字段 <code class="docutils literal"><span class="pre">id_table</span></code>：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_device_id</span> <span class="n">my_pnp_tbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
         <span class="cm">/* 标准 LPT 打印机端口 */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0400&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="cm">/* ECP 打印机端口 */</span>
         <span class="p">{.</span><span class="n">id</span> <span class="o">=</span> <span class="s">&quot;PNP0401&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">driver_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">},</span>
         <span class="p">{</span> <span class="p">}</span>
<span class="p">};</span>

<span class="n">MODULE_DEVICE_TABLE</span><span class="p">(</span><span class="n">pnp</span><span class="p">,</span><span class="n">my_pnp_tbl</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">id_table</span>       <span class="o">=</span> <span class="n">my_pnp_tbl</span><span class="p">,</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在上面的示例中，驱动程序支持多个并行端口设备，这些设备在表格 <code class="docutils literal"><span class="pre">my_pnp_tbl</span></code> 中定义。总线在 <code class="docutils literal"><span class="pre">match_device</span></code> 函数中使用此信息。在添加驱动程序时，总线驱动程序将与其关联，并根据驱动程序名称在 <code class="docutils literal"><span class="pre">sysfs</span></code> 中创建新条目。然后，总线的 <code class="docutils literal"><span class="pre">match</span></code> 函数将针对每个支持的设备调用，以将驱动程序与其支持的任何连接设备关联起来。</p>
</div>
<div class="section" id="section-9">
<h3>移除驱动程序<a class="headerlink" href="#section-9" title="永久链接至标题">¶</a></h3>
<p>要从内核中移除驱动程序，除了传统驱动程序所需的操作外，我们还必须取消注册 <code class="docutils literal"><span class="pre">device_driver</span></code> 结构。对于与 <code class="docutils literal"><span class="pre">PNP</span></code> 总线关联的驱动程序，我们必须使用 <code class="xref c c-func docutils literal"><span class="pre">pnp_unregister_driver()</span></code> 函数取消注册 <code class="docutils literal"><span class="pre">pnp_driver</span></code> 结构：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">my_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">pnp_unregister_driver</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_pnp_driver</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>与传统驱动程序不同，即插即用驱动程序不会在模块卸载函数 (<code class="docutils literal"><span class="pre">my_exit</span></code>) 中取消注册设备。当驱动程序被移除时，所有它支持的设备对它的引用将被删除，并且 <code class="docutils literal"><span class="pre">sysfs</span></code> 中的条目也将被删除。</p>
</div>
<div class="section" id="section-10">
<h3>添加新设备<a class="headerlink" href="#section-10" title="永久链接至标题">¶</a></h3>
<p>如上所述，即插即用驱动程序在初始化时不会注册设备。这个操作将在检测到新设备时调用的 <code class="docutils literal"><span class="pre">probe</span></code> 函数中进行。连接到 <code class="docutils literal"><span class="pre">PNP</span></code> 总线的设备将通过 <code class="docutils literal"><span class="pre">pnp_driver</span></code> 结构的 <code class="docutils literal"><span class="pre">probe</span></code> 函数添加到系统中：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">my_pnp_probe</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">card_id</span><span class="p">,</span>
                                             <span class="k">const</span> <span class="k">struct</span> <span class="n">pnp_id</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">iobase</span><span class="p">,</span> <span class="n">nr_ports</span><span class="p">,</span> <span class="n">irq</span><span class="p">;</span>

        <span class="c1">//获取中断和端口</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pnp_irq_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">irq</span> <span class="o">=</span> <span class="n">pnp_irq</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pnp_port_valid</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">iobase</span> <span class="o">=</span> <span class="n">pnp_port_start</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
        <span class="n">nr_ports</span> <span class="o">=</span> <span class="n">pnp_port_len</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="cm">/* 注册设备 dev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">probe</span>          <span class="o">=</span> <span class="n">my_pnp_probe</span><span class="p">,</span>
         <span class="c1">//...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>在内核中检测到设备（在引导时或通过“热插拔”插入设备）时，系统会生成中断并传递给总线驱动程序。使用函数 <code class="xref c c-func docutils literal"><span class="pre">device_register()</span></code> 注册设备，并将其连接到总线。然后还会生成对用户空间的调用，事件可以由 <code class="docutils literal"><span class="pre">udev</span></code> 处理。然后, <code class="docutils literal"><span class="pre">udev</span></code> 将迭代与总线关联的驱动程序列表，并对每个驱动程序调用 <code class="docutils literal"><span class="pre">match</span></code> 函数。 <code class="docutils literal"><span class="pre">match</span></code> 函数尝试为新设备找到驱动程序。找到合适的驱动程序后，将调用驱动程序的 <code class="docutils literal"><span class="pre">probe</span></code> 函数。如果函数成功结束，设备将添加到驱动程序的设备列表中，并根据设备名称在 <code class="docutils literal"><span class="pre">sysfs</span></code> 中创建新条目。</p>
</div>
<div class="section" id="section-11">
<h3>移除设备<a class="headerlink" href="#section-11" title="永久链接至标题">¶</a></h3>
<p>如上所述，即插即用驱动程序在卸载驱动程序时不会取消注册设备。这个操作是在从系统中移除设备时调用的 <code class="docutils literal"><span class="pre">remove</span></code> 函数中完成的。对于连接到 <code class="docutils literal"><span class="pre">PNP</span></code> 总线的设备，取消注册将在 <code class="docutils literal"><span class="pre">pnp_driver</span></code> 结构中指定的 <code class="docutils literal"><span class="pre">remove</span></code> 函数中进行：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">my_pnp_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnp_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
         <span class="cm">/* 取消注册设备 dev */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnp_driver</span> <span class="n">my_pnp_driver</span> <span class="o">=</span> <span class="p">{</span>
         <span class="c1">//...</span>
         <span class="p">.</span><span class="n">remove</span>         <span class="o">=</span> <span class="n">my_pnp_remove</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>
</div>
<p>如上例所示，当检测到设备被移除时，将调用 <code class="docutils literal"><span class="pre">my_pnp_remove</span></code> 函数。还会生成对用户空间的调用，可以被 <code class="docutils literal"><span class="pre">udev</span></code> 检测到，并且会从 <code class="docutils literal"><span class="pre">sysfs</span></code> 中删除条目。</p>
</div>
</div>
<div class="section" id="section-12">
<h2>练习<a class="headerlink" href="#section-12" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p>要解决练习，你需要执行以下步骤：</p>
<blockquote>
<div><ul class="simple">
<li>用模板来准备骨架</li>
<li>构建模块</li>
<li>将模块复制到虚拟机</li>
<li>启动虚拟机并在虚拟机中测试模块。</li>
</ul>
</div></blockquote>
<p>当前实验名称为 设备模型。请参阅任务名称的练习。</p>
<p>骨架代码是从位于 <code class="file docutils literal"><span class="pre">tools/labs/templates</span></code> 的完整源代码示例中生成的。要解决任务，首先要为所有实验生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make clean
tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt; make skels
</pre></div>
</div>
<p>你还可以使用以下命令为单个任务生成骨架代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ <span class="nv">LABS</span><span class="o">=</span>&lt;lab name&gt;/&lt;task name&gt; make skels
</pre></div>
</div>
<p>生成骨架驱动程序后，构建源代码：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make build
</pre></div>
</div>
<p>然后，复制模块并启动虚拟机：</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>tools/labs $ make copy
tools/labs $ make boot
</pre></div>
</div>
<p>模块将放置在 /home/root/skels/设备模型/&lt;task_name&gt; 目录中。</p>
<p>或者，我们可以通过 <strong class="command">scp</strong> 命令复制文件，以避免重新启动虚拟机。有关通过网络连接到虚拟机的详细信息，请参阅 <a class="reference internal" href="../info/vm.html#vm-interaction-link"><span class="std std-ref">连接到虚拟机</span></a>。</p>
<p class="last">请查看 <a class="reference internal" href="#section-12">练习</a> 部分以获取更详细的信息。</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>在开始练习或生成骨架之前，请在 Linux 仓库中运行 <strong>git pull</strong> 命令，以确保你拥有最新版本的练习。</p>
<p>如果你有本地更改，pull 命令将失败。使用 <code class="docutils literal"><span class="pre">git</span> <span class="pre">status</span></code> 检查本地更改。如果要保留更改，在 <code class="docutils literal"><span class="pre">pull</span></code> 之前运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span></code>，之后运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">stash</span> <span class="pre">pop</span></code>。要放弃更改，请运行 <code class="docutils literal"><span class="pre">git</span> <span class="pre">reset</span> <span class="pre">--hard</span> <span class="pre">master</span></code>。</p>
<p class="last">如果你在 <code class="docutils literal"><span class="pre">git</span> <span class="pre">pull</span></code> 之前已经生成了骨架，你需要再次生成骨架。</p>
</div>
<div class="section" id="section-13">
<h3>0. 引言<a class="headerlink" href="#section-13" title="永久链接至标题">¶</a></h3>
<p>在 Linux 内核中找到以下符号的定义：</p>
<blockquote>
<div><ul class="simple">
<li>函数 <code class="docutils literal"><span class="pre">dev_name</span></code>, <code class="docutils literal"><span class="pre">dev_set_name</span></code>。</li>
<li>函数 <code class="docutils literal"><span class="pre">pnp_device_probe</span></code>, <code class="docutils literal"><span class="pre">pnp_bus_match</span></code>, <code class="docutils literal"><span class="pre">pnp_register_driver</span></code> 以及变量 <code class="docutils literal"><span class="pre">pnp_bus_type</span></code>。</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="section-14">
<h3>1. 总线实现<a class="headerlink" href="#section-14" title="永久链接至标题">¶</a></h3>
<p>分析 <code class="docutils literal"><span class="pre">bex.c</span></code> 的内容，这是一个实现总线驱动程序的模块。按照标记为 <strong>TODO 1</strong> 的注释，实现缺失的功能：注册总线驱动程序，并添加一个名为 <code class="docutils literal"><span class="pre">root</span></code>、类型为 <code class="docutils literal"><span class="pre">none</span></code>、版本为 1 的新设备。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">参考 <code class="xref c c-func docutils literal"><span class="pre">bex_add_dev()</span></code>。</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">注册和取消注册必须使用 <code class="xref c c-func docutils literal"><span class="pre">bus_register()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">bus_unregister()</span></code> 完成。</p>
</div>
<p>加载该模块，并验证总线是否在 <code class="docutils literal"><span class="pre">/sys/bus</span></code> 中可见。验证设备是否在 <code class="docutils literal"><span class="pre">/sys/bus/bex/devices</span></code> 中可见。</p>
<p>卸载该模块，并注意到 <code class="docutils literal"><span class="pre">sysfs</span></code> 条目已被删除。</p>
</div>
<div class="section" id="section-15">
<h3>2. 添加类型和版本设备属性<a class="headerlink" href="#section-15" title="永久链接至标题">¶</a></h3>
<p>添加两个只读设备属性, <code class="docutils literal"><span class="pre">type</span></code> 和 <code class="docutils literal"><span class="pre">version</span></code>。按照 <strong>TODO 2</strong> 的标记进行操作。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>你需要在 <code class="docutils literal"><span class="pre">bex_dev_attrs</span></code> 结构中添加这两个属性，如下所示：</p>
<p class="last"><code class="docutils literal"><span class="pre">&amp;dev_attr_&lt;insert-attribute-type-here&gt;.attr,</span></code></p>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>展示函数的一个可能实现如下所示：</p>
<div class="last highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">type_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">device</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">device_attribute</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">bex_device</span> <span class="o">*</span><span class="n">bex_dev</span> <span class="o">=</span> <span class="n">to_bex_device</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bex_dev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">DEVICE_ATTR_RO</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</pre></div>
</div>
</div>
<p>观察在 /sys/bus/bex/devices/root 中出现了两个新属性。检查这些属性的内容。</p>
</div>
<div class="section" id="del-add">
<h3>3. 添加 del 和 add 总线属性<a class="headerlink" href="#del-add" title="永久链接至标题">¶</a></h3>
<p>添加两个只写总线属性, <code class="docutils literal"><span class="pre">del</span></code> 和 <code class="docutils literal"><span class="pre">add</span></code>。 <code class="docutils literal"><span class="pre">del</span></code> 期望删除设备的名称，而 <code class="docutils literal"><span class="pre">add</span></code> 期望提供名称、类型和版本来创建一个新设备。按照 <strong>TODO 3</strong> 的标记进行操作，并查阅 <a href="#system-message-1"><span class="problematic" id="problematic-1">`Buses`_</span></a>。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">sscanf()</span></code> 解析来自 sysfs 的输入，并使用 <code class="xref c c-func docutils literal"><span class="pre">bex_del_dev()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">bex_add_dev()</span></code> 删除和创建新设备。</p>
</div>
<p>下面是 store 函数的示例：</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">add_store</span><span class="p">(</span><span class="k">struct</span> <span class="n">bus_type</span> <span class="o">*</span><span class="n">bt</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

  <span class="n">ret</span> <span class="o">=</span> <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%31s&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

  <span class="p">...</span>
<span class="p">}</span>
<span class="n">BUS_ATTR</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">S_IWUSR</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">add_store</span><span class="p">);</span>
</pre></div>
</div>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">如果 <code class="docutils literal"><span class="pre">bex_add_dev</span></code>/<code class="docutils literal"><span class="pre">bex_del_dev</span></code> 失败，store 函数应返回 <code class="docutils literal"><span class="pre">0</span></code>，否则返回 <code class="docutils literal"><span class="pre">count</span></code>。</p>
</div>
<p>创建一个新设备，并观察它在 <code class="docutils literal"><span class="pre">/sys/bus/devices</span></code> 中可见。然后删除它，并观察它从 <code class="docutils literal"><span class="pre">sysfs</span></code> 中消失。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p>使用 echo 命令将内容写入总线属性：</p>
<div class="last highlight-shell"><div class="highlight"><pre><span></span>$ <span class="nb">echo</span> <span class="s2">&quot;name type 1&quot;</span> &gt; /sys/bus/bex/add
$ <span class="nb">echo</span> <span class="s2">&quot;name&quot;</span> &gt; /sys/bus/bex/del
</pre></div>
</div>
</div>
</div>
<div class="section" id="bex">
<h3>4. 注册 bex 杂项驱动程序<a class="headerlink" href="#bex" title="永久链接至标题">¶</a></h3>
<p>修改 <strong>bex-misc.c</strong>，使其在 bex 总线上注册驱动程序。插入 <code class="docutils literal"><span class="pre">bmx_misc.ko</span></code> 模块，并从 sysfs 创建一个名为“test”、类型为“misc”、版本为 2 的新 bex 设备。按照 <strong>TODO 4</strong> 的标记进行操作。</p>
<p>观察驱动程序在 <code class="docutils literal"><span class="pre">/sys/bus/bex/drivers</span></code> 中可见。</p>
<p>为什么没有调用 probe 函数？</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">注意到 <strong>bex.c</strong> 中的总线匹配函数未实现。</p>
</div>
<p>在 <strong>bex.c</strong> 中实现总线匹配函数。按照 <strong>TODO 5</strong> 的标记进行操作。再次尝试创建一个新的 bex 设备，并观察这次 <code class="docutils literal"><span class="pre">bex_misc</span></code> 驱动程序的 <code class="docutils literal"><span class="pre">probe</span></code> 函数被调用。</p>
</div>
<div class="section" id="bex-misc-probe">
<h3>5. 在 bex_misc probe 函数中注册杂项设备<a class="headerlink" href="#bex-misc-probe" title="永久链接至标题">¶</a></h3>
<p>修改 <strong>bex_misc.c</strong>，如果 <code class="docutils literal"><span class="pre">version</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>，则拒绝探测。此外，在 <code class="docutils literal"><span class="pre">bex_misc_probe</span></code> 中注册定义的杂项设备，并在 <code class="docutils literal"><span class="pre">bex_misc_remove</span></code> 中取消注册。按照 <strong>TODO 6</strong> 的标记进行操作。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">使用 <code class="xref c c-func docutils literal"><span class="pre">misc_register()</span></code> 和 <code class="xref c c-func docutils literal"><span class="pre">misc_deregister()</span></code>。</p>
</div>
<p>创建一个名称为“test”、类型为“misc”、版本为 2 的新设备，并观察探测失败。创建一个名称为“test2”、类型为“misc”、版本为 1 的新设备，并观察探测成功。</p>
<p>检查 <code class="docutils literal"><span class="pre">/sys/bus/bex/devices/test2</span></code>，观察到我们有了一个新条目。确定杂项设备的主设备号和次设备号，创建一个字符设备文件，并尝试从杂项设备缓冲区中读取和写入数据。</p>
<div class="admonition hint">
<p class="first admonition-title">提示</p>
<p class="last">主设备号和次设备号应该在杂项设备的 dev 属性中可见。</p>
</div>
</div>
<div class="section" id="uevent">
<h3>6. 监视 uevent 通知<a class="headerlink" href="#uevent" title="永久链接至标题">¶</a></h3>
<p>使用命令 <code class="docutils literal"><span class="pre">udevadm</span> <span class="pre">monitor</span></code>，观察以下情况发生时会发生什么：</p>
<ul class="simple">
<li>插入 <code class="docutils literal"><span class="pre">bex.ko</span></code> 和 <code class="docutils literal"><span class="pre">bex_misc.ko</span></code> 模块</li>
<li>创建一个类型为“type”的新设备</li>
<li>创建一个类型为“misc”、版本为 2 的新设备</li>
<li>创建一个类型为“misc”、版本为 1 的新设备</li>
<li>移除上述所有设备</li>
</ul>
</div>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="memory_mapping.html" class="btn btn-neutral float-left" title="内存映射" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kernel_profiling.html" class="btn btn-neutral float-right" title="内核分析" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>